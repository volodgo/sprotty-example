(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);

  // node_modules/sprotty/lib/base/actions/action.js
  var require_action = __commonJS({
    "node_modules/sprotty/lib/base/actions/action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isLabeledAction = exports.LabeledAction = void 0;
      var LabeledAction = class {
        constructor(label, actions, icon) {
          this.label = label;
          this.actions = actions;
          this.icon = icon;
        }
      };
      exports.LabeledAction = LabeledAction;
      function isLabeledAction(element) {
        return element !== void 0 && element.label !== void 0 && element.actions !== void 0;
      }
      exports.isLabeledAction = isLabeledAction;
    }
  });

  // node_modules/inversify/lib/constants/metadata_keys.js
  var require_metadata_keys = __commonJS({
    "node_modules/inversify/lib/constants/metadata_keys.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NON_CUSTOM_TAG_KEYS = exports.PRE_DESTROY = exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
      exports.NAMED_TAG = "named";
      exports.NAME_TAG = "name";
      exports.UNMANAGED_TAG = "unmanaged";
      exports.OPTIONAL_TAG = "optional";
      exports.INJECT_TAG = "inject";
      exports.MULTI_INJECT_TAG = "multi_inject";
      exports.TAGGED = "inversify:tagged";
      exports.TAGGED_PROP = "inversify:tagged_props";
      exports.PARAM_TYPES = "inversify:paramtypes";
      exports.DESIGN_PARAM_TYPES = "design:paramtypes";
      exports.POST_CONSTRUCT = "post_construct";
      exports.PRE_DESTROY = "pre_destroy";
      function getNonCustomTagKeys() {
        return [
          exports.INJECT_TAG,
          exports.MULTI_INJECT_TAG,
          exports.NAME_TAG,
          exports.UNMANAGED_TAG,
          exports.NAMED_TAG,
          exports.OPTIONAL_TAG
        ];
      }
      exports.NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
    }
  });

  // node_modules/inversify/lib/constants/literal_types.js
  var require_literal_types = __commonJS({
    "node_modules/inversify/lib/constants/literal_types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = void 0;
      var BindingScopeEnum = {
        Request: "Request",
        Singleton: "Singleton",
        Transient: "Transient"
      };
      exports.BindingScopeEnum = BindingScopeEnum;
      var BindingTypeEnum = {
        ConstantValue: "ConstantValue",
        Constructor: "Constructor",
        DynamicValue: "DynamicValue",
        Factory: "Factory",
        Function: "Function",
        Instance: "Instance",
        Invalid: "Invalid",
        Provider: "Provider"
      };
      exports.BindingTypeEnum = BindingTypeEnum;
      var TargetTypeEnum = {
        ClassProperty: "ClassProperty",
        ConstructorArgument: "ConstructorArgument",
        Variable: "Variable"
      };
      exports.TargetTypeEnum = TargetTypeEnum;
    }
  });

  // node_modules/inversify/lib/utils/id.js
  var require_id = __commonJS({
    "node_modules/inversify/lib/utils/id.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.id = void 0;
      var idCounter = 0;
      function id() {
        return idCounter++;
      }
      exports.id = id;
    }
  });

  // node_modules/inversify/lib/bindings/binding.js
  var require_binding = __commonJS({
    "node_modules/inversify/lib/bindings/binding.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Binding = void 0;
      var literal_types_1 = require_literal_types();
      var id_1 = require_id();
      var Binding = function() {
        function Binding2(serviceIdentifier, scope) {
          this.id = (0, id_1.id)();
          this.activated = false;
          this.serviceIdentifier = serviceIdentifier;
          this.scope = scope;
          this.type = literal_types_1.BindingTypeEnum.Invalid;
          this.constraint = function(request) {
            return true;
          };
          this.implementationType = null;
          this.cache = null;
          this.factory = null;
          this.provider = null;
          this.onActivation = null;
          this.onDeactivation = null;
          this.dynamicValue = null;
        }
        Binding2.prototype.clone = function() {
          var clone = new Binding2(this.serviceIdentifier, this.scope);
          clone.activated = clone.scope === literal_types_1.BindingScopeEnum.Singleton ? this.activated : false;
          clone.implementationType = this.implementationType;
          clone.dynamicValue = this.dynamicValue;
          clone.scope = this.scope;
          clone.type = this.type;
          clone.factory = this.factory;
          clone.provider = this.provider;
          clone.constraint = this.constraint;
          clone.onActivation = this.onActivation;
          clone.onDeactivation = this.onDeactivation;
          clone.cache = this.cache;
          return clone;
        };
        return Binding2;
      }();
      exports.Binding = Binding;
    }
  });

  // node_modules/inversify/lib/constants/error_msgs.js
  var require_error_msgs = __commonJS({
    "node_modules/inversify/lib/constants/error_msgs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.STACK_OVERFLOW = exports.CIRCULAR_DEPENDENCY_IN_FACTORY = exports.ON_DEACTIVATION_ERROR = exports.PRE_DESTROY_ERROR = exports.POST_CONSTRUCT_ERROR = exports.ASYNC_UNBIND_REQUIRED = exports.MULTIPLE_POST_CONSTRUCT_METHODS = exports.MULTIPLE_PRE_DESTROY_METHODS = exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = exports.ARGUMENTS_LENGTH_MISMATCH = exports.INVALID_DECORATOR_OPERATION = exports.INVALID_TO_SELF_VALUE = exports.LAZY_IN_SYNC = exports.INVALID_FUNCTION_BINDING = exports.INVALID_MIDDLEWARE_RETURN = exports.NO_MORE_SNAPSHOTS_AVAILABLE = exports.INVALID_BINDING_TYPE = exports.NOT_IMPLEMENTED = exports.CIRCULAR_DEPENDENCY = exports.UNDEFINED_INJECT_ANNOTATION = exports.MISSING_INJECT_ANNOTATION = exports.MISSING_INJECTABLE_ANNOTATION = exports.NOT_REGISTERED = exports.CANNOT_UNBIND = exports.AMBIGUOUS_MATCH = exports.KEY_NOT_FOUND = exports.NULL_ARGUMENT = exports.DUPLICATED_METADATA = exports.DUPLICATED_INJECTABLE_DECORATOR = void 0;
      exports.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
      exports.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
      exports.NULL_ARGUMENT = "NULL argument";
      exports.KEY_NOT_FOUND = "Key Not Found";
      exports.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
      exports.CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
      exports.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
      exports.MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
      exports.MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
      var UNDEFINED_INJECT_ANNOTATION = function(name) {
        return "@inject called with undefined this could mean that the class " + name + " has a circular dependency problem. You can use a LazyServiceIdentifier to  overcome this limitation.";
      };
      exports.UNDEFINED_INJECT_ANNOTATION = UNDEFINED_INJECT_ANNOTATION;
      exports.CIRCULAR_DEPENDENCY = "Circular dependency found:";
      exports.NOT_IMPLEMENTED = "Sorry, this feature is not fully implemented yet.";
      exports.INVALID_BINDING_TYPE = "Invalid binding type:";
      exports.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
      exports.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
      exports.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
      var LAZY_IN_SYNC = function(key) {
        return "You are attempting to construct '" + key + "' in a synchronous way\n but it has asynchronous dependencies.";
      };
      exports.LAZY_IN_SYNC = LAZY_IN_SYNC;
      exports.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier";
      exports.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
      var ARGUMENTS_LENGTH_MISMATCH = function() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          values[_i] = arguments[_i];
        }
        return "The number of constructor arguments in the derived class " + (values[0] + " must be >= than the number of constructor arguments of its base class.");
      };
      exports.ARGUMENTS_LENGTH_MISMATCH = ARGUMENTS_LENGTH_MISMATCH;
      exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.";
      exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must be a string ("singleton" or "transient").';
      exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean";
      exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean";
      exports.MULTIPLE_PRE_DESTROY_METHODS = "Cannot apply @preDestroy decorator multiple times in the same class";
      exports.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
      exports.ASYNC_UNBIND_REQUIRED = "Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)";
      var POST_CONSTRUCT_ERROR = function(clazz, errorMessage) {
        return "@postConstruct error in class " + clazz + ": " + errorMessage;
      };
      exports.POST_CONSTRUCT_ERROR = POST_CONSTRUCT_ERROR;
      var PRE_DESTROY_ERROR = function(clazz, errorMessage) {
        return "@preDestroy error in class " + clazz + ": " + errorMessage;
      };
      exports.PRE_DESTROY_ERROR = PRE_DESTROY_ERROR;
      var ON_DEACTIVATION_ERROR = function(clazz, errorMessage) {
        return "onDeactivation() error in class " + clazz + ": " + errorMessage;
      };
      exports.ON_DEACTIVATION_ERROR = ON_DEACTIVATION_ERROR;
      var CIRCULAR_DEPENDENCY_IN_FACTORY = function(factoryType, serviceIdentifier) {
        return "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings with " + ("service identifier '" + serviceIdentifier + "'.");
      };
      exports.CIRCULAR_DEPENDENCY_IN_FACTORY = CIRCULAR_DEPENDENCY_IN_FACTORY;
      exports.STACK_OVERFLOW = "Maximum call stack size exceeded";
    }
  });

  // node_modules/inversify/lib/planning/metadata_reader.js
  var require_metadata_reader = __commonJS({
    "node_modules/inversify/lib/planning/metadata_reader.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MetadataReader = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var MetadataReader = function() {
        function MetadataReader2() {
        }
        MetadataReader2.prototype.getConstructorMetadata = function(constructorFunc) {
          var compilerGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.PARAM_TYPES, constructorFunc);
          var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, constructorFunc);
          return {
            compilerGeneratedMetadata,
            userGeneratedMetadata: userGeneratedMetadata || {}
          };
        };
        MetadataReader2.prototype.getPropertiesMetadata = function(constructorFunc) {
          var userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED_PROP, constructorFunc) || [];
          return userGeneratedMetadata;
        };
        return MetadataReader2;
      }();
      exports.MetadataReader = MetadataReader;
    }
  });

  // node_modules/inversify/lib/bindings/binding_count.js
  var require_binding_count = __commonJS({
    "node_modules/inversify/lib/bindings/binding_count.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingCount = void 0;
      exports.BindingCount = {
        MultipleBindingsAvailable: 2,
        NoBindingsAvailable: 0,
        OnlyOneBindingAvailable: 1
      };
    }
  });

  // node_modules/inversify/lib/utils/exceptions.js
  var require_exceptions = __commonJS({
    "node_modules/inversify/lib/utils/exceptions.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tryAndThrowErrorIfStackOverflow = exports.isStackOverflowExeption = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      function isStackOverflowExeption(error) {
        return error instanceof RangeError || error.message === ERROR_MSGS.STACK_OVERFLOW;
      }
      exports.isStackOverflowExeption = isStackOverflowExeption;
      var tryAndThrowErrorIfStackOverflow = function(fn, errorCallback) {
        try {
          return fn();
        } catch (error) {
          if (isStackOverflowExeption(error)) {
            error = errorCallback();
          }
          throw error;
        }
      };
      exports.tryAndThrowErrorIfStackOverflow = tryAndThrowErrorIfStackOverflow;
    }
  });

  // node_modules/inversify/lib/utils/serialization.js
  var require_serialization = __commonJS({
    "node_modules/inversify/lib/utils/serialization.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSymbolDescription = exports.circularDependencyToException = exports.listMetadataForTarget = exports.listRegisteredBindingsForServiceIdentifier = exports.getServiceIdentifierAsString = exports.getFunctionName = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      function getServiceIdentifierAsString(serviceIdentifier) {
        if (typeof serviceIdentifier === "function") {
          var _serviceIdentifier = serviceIdentifier;
          return _serviceIdentifier.name;
        } else if (typeof serviceIdentifier === "symbol") {
          return serviceIdentifier.toString();
        } else {
          var _serviceIdentifier = serviceIdentifier;
          return _serviceIdentifier;
        }
      }
      exports.getServiceIdentifierAsString = getServiceIdentifierAsString;
      function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
        var registeredBindingsList = "";
        var registeredBindings = getBindings(container, serviceIdentifier);
        if (registeredBindings.length !== 0) {
          registeredBindingsList = "\nRegistered bindings:";
          registeredBindings.forEach(function(binding) {
            var name = "Object";
            if (binding.implementationType !== null) {
              name = getFunctionName(binding.implementationType);
            }
            registeredBindingsList = registeredBindingsList + "\n " + name;
            if (binding.constraint.metaData) {
              registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
            }
          });
        }
        return registeredBindingsList;
      }
      exports.listRegisteredBindingsForServiceIdentifier = listRegisteredBindingsForServiceIdentifier;
      function alreadyDependencyChain(request, serviceIdentifier) {
        if (request.parentRequest === null) {
          return false;
        } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
          return true;
        } else {
          return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
        }
      }
      function dependencyChainToString(request) {
        function _createStringArr(req, result) {
          if (result === void 0) {
            result = [];
          }
          var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
          result.push(serviceIdentifier);
          if (req.parentRequest !== null) {
            return _createStringArr(req.parentRequest, result);
          }
          return result;
        }
        var stringArr = _createStringArr(request);
        return stringArr.reverse().join(" --> ");
      }
      function circularDependencyToException(request) {
        request.childRequests.forEach(function(childRequest) {
          if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
            var services = dependencyChainToString(childRequest);
            throw new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY + " " + services);
          } else {
            circularDependencyToException(childRequest);
          }
        });
      }
      exports.circularDependencyToException = circularDependencyToException;
      function listMetadataForTarget(serviceIdentifierString, target) {
        if (target.isTagged() || target.isNamed()) {
          var m_1 = "";
          var namedTag = target.getNamedTag();
          var otherTags = target.getCustomTags();
          if (namedTag !== null) {
            m_1 += namedTag.toString() + "\n";
          }
          if (otherTags !== null) {
            otherTags.forEach(function(tag) {
              m_1 += tag.toString() + "\n";
            });
          }
          return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
        } else {
          return " " + serviceIdentifierString;
        }
      }
      exports.listMetadataForTarget = listMetadataForTarget;
      function getFunctionName(func) {
        if (func.name) {
          return func.name;
        } else {
          var name_1 = func.toString();
          var match = name_1.match(/^function\s*([^\s(]+)/);
          return match ? match[1] : "Anonymous function: " + name_1;
        }
      }
      exports.getFunctionName = getFunctionName;
      function getSymbolDescription(symbol) {
        return symbol.toString().slice(7, -1);
      }
      exports.getSymbolDescription = getSymbolDescription;
    }
  });

  // node_modules/inversify/lib/planning/context.js
  var require_context = __commonJS({
    "node_modules/inversify/lib/planning/context.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Context = void 0;
      var id_1 = require_id();
      var Context = function() {
        function Context2(container) {
          this.id = (0, id_1.id)();
          this.container = container;
        }
        Context2.prototype.addPlan = function(plan) {
          this.plan = plan;
        };
        Context2.prototype.setCurrentRequest = function(currentRequest) {
          this.currentRequest = currentRequest;
        };
        return Context2;
      }();
      exports.Context = Context;
    }
  });

  // node_modules/inversify/lib/planning/metadata.js
  var require_metadata = __commonJS({
    "node_modules/inversify/lib/planning/metadata.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Metadata = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var Metadata = function() {
        function Metadata2(key, value) {
          this.key = key;
          this.value = value;
        }
        Metadata2.prototype.toString = function() {
          if (this.key === METADATA_KEY.NAMED_TAG) {
            return "named: " + String(this.value).toString() + " ";
          } else {
            return "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
          }
        };
        return Metadata2;
      }();
      exports.Metadata = Metadata;
    }
  });

  // node_modules/inversify/lib/planning/plan.js
  var require_plan = __commonJS({
    "node_modules/inversify/lib/planning/plan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Plan = void 0;
      var Plan = function() {
        function Plan2(parentContext, rootRequest) {
          this.parentContext = parentContext;
          this.rootRequest = rootRequest;
        }
        return Plan2;
      }();
      exports.Plan = Plan;
    }
  });

  // node_modules/inversify/lib/annotation/lazy_service_identifier.js
  var require_lazy_service_identifier = __commonJS({
    "node_modules/inversify/lib/annotation/lazy_service_identifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LazyServiceIdentifier = void 0;
      var LazyServiceIdentifier = function() {
        function LazyServiceIdentifier2(cb) {
          this._cb = cb;
        }
        LazyServiceIdentifier2.prototype.unwrap = function() {
          return this._cb();
        };
        return LazyServiceIdentifier2;
      }();
      exports.LazyServiceIdentifier = LazyServiceIdentifier;
    }
  });

  // node_modules/inversify/lib/planning/queryable_string.js
  var require_queryable_string = __commonJS({
    "node_modules/inversify/lib/planning/queryable_string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.QueryableString = void 0;
      var QueryableString = function() {
        function QueryableString2(str) {
          this.str = str;
        }
        QueryableString2.prototype.startsWith = function(searchString) {
          return this.str.indexOf(searchString) === 0;
        };
        QueryableString2.prototype.endsWith = function(searchString) {
          var reverseString = "";
          var reverseSearchString = searchString.split("").reverse().join("");
          reverseString = this.str.split("").reverse().join("");
          return this.startsWith.call({ str: reverseString }, reverseSearchString);
        };
        QueryableString2.prototype.contains = function(searchString) {
          return this.str.indexOf(searchString) !== -1;
        };
        QueryableString2.prototype.equals = function(compareString) {
          return this.str === compareString;
        };
        QueryableString2.prototype.value = function() {
          return this.str;
        };
        return QueryableString2;
      }();
      exports.QueryableString = QueryableString;
    }
  });

  // node_modules/inversify/lib/planning/target.js
  var require_target = __commonJS({
    "node_modules/inversify/lib/planning/target.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Target = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var id_1 = require_id();
      var serialization_1 = require_serialization();
      var metadata_1 = require_metadata();
      var queryable_string_1 = require_queryable_string();
      var Target = function() {
        function Target2(type, identifier, serviceIdentifier, namedOrTagged) {
          this.id = (0, id_1.id)();
          this.type = type;
          this.serviceIdentifier = serviceIdentifier;
          var queryableName = typeof identifier === "symbol" ? (0, serialization_1.getSymbolDescription)(identifier) : identifier;
          this.name = new queryable_string_1.QueryableString(queryableName || "");
          this.identifier = identifier;
          this.metadata = new Array();
          var metadataItem = null;
          if (typeof namedOrTagged === "string") {
            metadataItem = new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, namedOrTagged);
          } else if (namedOrTagged instanceof metadata_1.Metadata) {
            metadataItem = namedOrTagged;
          }
          if (metadataItem !== null) {
            this.metadata.push(metadataItem);
          }
        }
        Target2.prototype.hasTag = function(key) {
          for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
            var m = _a[_i];
            if (m.key === key) {
              return true;
            }
          }
          return false;
        };
        Target2.prototype.isArray = function() {
          return this.hasTag(METADATA_KEY.MULTI_INJECT_TAG);
        };
        Target2.prototype.matchesArray = function(name) {
          return this.matchesTag(METADATA_KEY.MULTI_INJECT_TAG)(name);
        };
        Target2.prototype.isNamed = function() {
          return this.hasTag(METADATA_KEY.NAMED_TAG);
        };
        Target2.prototype.isTagged = function() {
          return this.metadata.some(function(metadata) {
            return METADATA_KEY.NON_CUSTOM_TAG_KEYS.every(function(key) {
              return metadata.key !== key;
            });
          });
        };
        Target2.prototype.isOptional = function() {
          return this.matchesTag(METADATA_KEY.OPTIONAL_TAG)(true);
        };
        Target2.prototype.getNamedTag = function() {
          if (this.isNamed()) {
            return this.metadata.filter(function(m) {
              return m.key === METADATA_KEY.NAMED_TAG;
            })[0];
          }
          return null;
        };
        Target2.prototype.getCustomTags = function() {
          if (this.isTagged()) {
            return this.metadata.filter(function(metadata) {
              return METADATA_KEY.NON_CUSTOM_TAG_KEYS.every(function(key) {
                return metadata.key !== key;
              });
            });
          } else {
            return null;
          }
        };
        Target2.prototype.matchesNamedTag = function(name) {
          return this.matchesTag(METADATA_KEY.NAMED_TAG)(name);
        };
        Target2.prototype.matchesTag = function(key) {
          var _this = this;
          return function(value) {
            for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
              var m = _a[_i];
              if (m.key === key && m.value === value) {
                return true;
              }
            }
            return false;
          };
        };
        return Target2;
      }();
      exports.Target = Target;
    }
  });

  // node_modules/inversify/lib/planning/reflection_utils.js
  var require_reflection_utils = __commonJS({
    "node_modules/inversify/lib/planning/reflection_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFunctionName = exports.getBaseClassDependencyCount = exports.getDependencies = void 0;
      var lazy_service_identifier_1 = require_lazy_service_identifier();
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var serialization_1 = require_serialization();
      Object.defineProperty(exports, "getFunctionName", { enumerable: true, get: function() {
        return serialization_1.getFunctionName;
      } });
      var target_1 = require_target();
      function getDependencies(metadataReader, func) {
        var constructorName = (0, serialization_1.getFunctionName)(func);
        return getTargets(metadataReader, constructorName, func, false);
      }
      exports.getDependencies = getDependencies;
      function getTargets(metadataReader, constructorName, func, isBaseClass) {
        var metadata = metadataReader.getConstructorMetadata(func);
        var serviceIdentifiers = metadata.compilerGeneratedMetadata;
        if (serviceIdentifiers === void 0) {
          var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
          throw new Error(msg);
        }
        var constructorArgsMetadata = metadata.userGeneratedMetadata;
        var keys = Object.keys(constructorArgsMetadata);
        var hasUserDeclaredUnknownInjections = func.length === 0 && keys.length > 0;
        var hasOptionalParameters = keys.length > func.length;
        var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func.length;
        var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
        var propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName);
        var targets = __spreadArray(__spreadArray([], constructorTargets, true), propertyTargets, true);
        return targets;
      }
      function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
        var targetMetadata = constructorArgsMetadata[index.toString()] || [];
        var metadata = formatTargetMetadata(targetMetadata);
        var isManaged = metadata.unmanaged !== true;
        var serviceIdentifier = serviceIdentifiers[index];
        var injectIdentifier = metadata.inject || metadata.multiInject;
        serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;
        if (serviceIdentifier instanceof lazy_service_identifier_1.LazyServiceIdentifier) {
          serviceIdentifier = serviceIdentifier.unwrap();
        }
        if (isManaged) {
          var isObject = serviceIdentifier === Object;
          var isFunction = serviceIdentifier === Function;
          var isUndefined = serviceIdentifier === void 0;
          var isUnknownType = isObject || isFunction || isUndefined;
          if (!isBaseClass && isUnknownType) {
            var msg = ERROR_MSGS.MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
            throw new Error(msg);
          }
          var target = new target_1.Target(literal_types_1.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
          target.metadata = targetMetadata;
          return target;
        }
        return null;
      }
      function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
        var targets = [];
        for (var i = 0; i < iterations; i++) {
          var index = i;
          var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
          if (target !== null) {
            targets.push(target);
          }
        }
        return targets;
      }
      function _getServiceIdentifierForProperty(inject4, multiInject, propertyName, className) {
        var serviceIdentifier = inject4 || multiInject;
        if (serviceIdentifier === void 0) {
          var msg = ERROR_MSGS.MISSING_INJECTABLE_ANNOTATION + " for property " + String(propertyName) + " in class " + className + ".";
          throw new Error(msg);
        }
        return serviceIdentifier;
      }
      function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
        var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
        var targets = [];
        var symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata);
        var stringKeys = Object.keys(classPropsMetadata);
        var keys = stringKeys.concat(symbolKeys);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          var targetMetadata = classPropsMetadata[key];
          var metadata = formatTargetMetadata(targetMetadata);
          var identifier = metadata.targetName || key;
          var serviceIdentifier = _getServiceIdentifierForProperty(metadata.inject, metadata.multiInject, key, constructorName);
          var target = new target_1.Target(literal_types_1.TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);
          target.metadata = targetMetadata;
          targets.push(target);
        }
        var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
        if (baseConstructor !== Object) {
          var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);
          targets = __spreadArray(__spreadArray([], targets, true), baseTargets, true);
        }
        return targets;
      }
      function getBaseClassDependencyCount(metadataReader, func) {
        var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
        if (baseConstructor !== Object) {
          var baseConstructorName = (0, serialization_1.getFunctionName)(baseConstructor);
          var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
          var metadata = targets.map(function(t) {
            return t.metadata.filter(function(m) {
              return m.key === METADATA_KEY.UNMANAGED_TAG;
            });
          });
          var unmanagedCount = [].concat.apply([], metadata).length;
          var dependencyCount = targets.length - unmanagedCount;
          if (dependencyCount > 0) {
            return dependencyCount;
          } else {
            return getBaseClassDependencyCount(metadataReader, baseConstructor);
          }
        } else {
          return 0;
        }
      }
      exports.getBaseClassDependencyCount = getBaseClassDependencyCount;
      function formatTargetMetadata(targetMetadata) {
        var targetMetadataMap = {};
        targetMetadata.forEach(function(m) {
          targetMetadataMap[m.key.toString()] = m.value;
        });
        return {
          inject: targetMetadataMap[METADATA_KEY.INJECT_TAG],
          multiInject: targetMetadataMap[METADATA_KEY.MULTI_INJECT_TAG],
          targetName: targetMetadataMap[METADATA_KEY.NAME_TAG],
          unmanaged: targetMetadataMap[METADATA_KEY.UNMANAGED_TAG]
        };
      }
    }
  });

  // node_modules/inversify/lib/planning/request.js
  var require_request = __commonJS({
    "node_modules/inversify/lib/planning/request.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Request = void 0;
      var id_1 = require_id();
      var Request = function() {
        function Request2(serviceIdentifier, parentContext, parentRequest, bindings, target) {
          this.id = (0, id_1.id)();
          this.serviceIdentifier = serviceIdentifier;
          this.parentContext = parentContext;
          this.parentRequest = parentRequest;
          this.target = target;
          this.childRequests = [];
          this.bindings = Array.isArray(bindings) ? bindings : [bindings];
          this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null;
        }
        Request2.prototype.addChildRequest = function(serviceIdentifier, bindings, target) {
          var child = new Request2(serviceIdentifier, this.parentContext, this, bindings, target);
          this.childRequests.push(child);
          return child;
        };
        return Request2;
      }();
      exports.Request = Request;
    }
  });

  // node_modules/inversify/lib/planning/planner.js
  var require_planner = __commonJS({
    "node_modules/inversify/lib/planning/planner.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBindingDictionary = exports.createMockRequest = exports.plan = void 0;
      var binding_count_1 = require_binding_count();
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var exceptions_1 = require_exceptions();
      var serialization_1 = require_serialization();
      var context_1 = require_context();
      var metadata_1 = require_metadata();
      var plan_1 = require_plan();
      var reflection_utils_1 = require_reflection_utils();
      var request_1 = require_request();
      var target_1 = require_target();
      function getBindingDictionary(cntnr) {
        return cntnr._bindingDictionary;
      }
      exports.getBindingDictionary = getBindingDictionary;
      function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
        var metadataKey = isMultiInject ? METADATA_KEY.MULTI_INJECT_TAG : METADATA_KEY.INJECT_TAG;
        var injectMetadata = new metadata_1.Metadata(metadataKey, serviceIdentifier);
        var target = new target_1.Target(targetType, name, serviceIdentifier, injectMetadata);
        if (key !== void 0) {
          var tagMetadata = new metadata_1.Metadata(key, value);
          target.metadata.push(tagMetadata);
        }
        return target;
      }
      function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
        var bindings = getBindings(context.container, target.serviceIdentifier);
        var activeBindings = [];
        if (bindings.length === binding_count_1.BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
          context.container.bind(target.serviceIdentifier).toSelf();
          bindings = getBindings(context.container, target.serviceIdentifier);
        }
        if (!avoidConstraints) {
          activeBindings = bindings.filter(function(binding) {
            var request = new request_1.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
            return binding.constraint(request);
          });
        } else {
          activeBindings = bindings;
        }
        _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
        return activeBindings;
      }
      function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
        switch (bindings.length) {
          case binding_count_1.BindingCount.NoBindingsAvailable:
            if (target.isOptional()) {
              return bindings;
            } else {
              var serviceIdentifierString = (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier);
              var msg = ERROR_MSGS.NOT_REGISTERED;
              msg += (0, serialization_1.listMetadataForTarget)(serviceIdentifierString, target);
              msg += (0, serialization_1.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);
              throw new Error(msg);
            }
          case binding_count_1.BindingCount.OnlyOneBindingAvailable:
            return bindings;
          case binding_count_1.BindingCount.MultipleBindingsAvailable:
          default:
            if (!target.isArray()) {
              var serviceIdentifierString = (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier);
              var msg = ERROR_MSGS.AMBIGUOUS_MATCH + " " + serviceIdentifierString;
              msg += (0, serialization_1.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);
              throw new Error(msg);
            } else {
              return bindings;
            }
        }
      }
      function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
        var activeBindings;
        var childRequest;
        if (parentRequest === null) {
          activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
          childRequest = new request_1.Request(serviceIdentifier, context, null, activeBindings, target);
          var thePlan = new plan_1.Plan(context, childRequest);
          context.addPlan(thePlan);
        } else {
          activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
          childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
        }
        activeBindings.forEach(function(binding) {
          var subChildRequest = null;
          if (target.isArray()) {
            subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
          } else {
            if (binding.cache) {
              return;
            }
            subChildRequest = childRequest;
          }
          if (binding.type === literal_types_1.BindingTypeEnum.Instance && binding.implementationType !== null) {
            var dependencies = (0, reflection_utils_1.getDependencies)(metadataReader, binding.implementationType);
            if (!context.container.options.skipBaseClassChecks) {
              var baseClassDependencyCount = (0, reflection_utils_1.getBaseClassDependencyCount)(metadataReader, binding.implementationType);
              if (dependencies.length < baseClassDependencyCount) {
                var error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH((0, reflection_utils_1.getFunctionName)(binding.implementationType));
                throw new Error(error);
              }
            }
            dependencies.forEach(function(dependency) {
              _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
            });
          }
        });
      }
      function getBindings(container, serviceIdentifier) {
        var bindings = [];
        var bindingDictionary = getBindingDictionary(container);
        if (bindingDictionary.hasKey(serviceIdentifier)) {
          bindings = bindingDictionary.get(serviceIdentifier);
        } else if (container.parent !== null) {
          bindings = getBindings(container.parent, serviceIdentifier);
        }
        return bindings;
      }
      function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
        if (avoidConstraints === void 0) {
          avoidConstraints = false;
        }
        var context = new context_1.Context(container);
        var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
        try {
          _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
          return context;
        } catch (error) {
          if ((0, exceptions_1.isStackOverflowExeption)(error)) {
            (0, serialization_1.circularDependencyToException)(context.plan.rootRequest);
          }
          throw error;
        }
      }
      exports.plan = plan;
      function createMockRequest(container, serviceIdentifier, key, value) {
        var target = new target_1.Target(literal_types_1.TargetTypeEnum.Variable, "", serviceIdentifier, new metadata_1.Metadata(key, value));
        var context = new context_1.Context(container);
        var request = new request_1.Request(serviceIdentifier, context, null, [], target);
        return request;
      }
      exports.createMockRequest = createMockRequest;
    }
  });

  // node_modules/inversify/lib/utils/async.js
  var require_async = __commonJS({
    "node_modules/inversify/lib/utils/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPromiseOrContainsPromise = exports.isPromise = void 0;
      function isPromise(object) {
        var isObjectOrFunction = typeof object === "object" && object !== null || typeof object === "function";
        return isObjectOrFunction && typeof object.then === "function";
      }
      exports.isPromise = isPromise;
      function isPromiseOrContainsPromise(object) {
        if (isPromise(object)) {
          return true;
        }
        return Array.isArray(object) && object.some(isPromise);
      }
      exports.isPromiseOrContainsPromise = isPromiseOrContainsPromise;
    }
  });

  // node_modules/inversify/lib/scope/scope.js
  var require_scope = __commonJS({
    "node_modules/inversify/lib/scope/scope.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.saveToScope = exports.tryGetFromScope = void 0;
      var literal_types_1 = require_literal_types();
      var async_1 = require_async();
      var tryGetFromScope = function(requestScope, binding) {
        if (binding.scope === literal_types_1.BindingScopeEnum.Singleton && binding.activated) {
          return binding.cache;
        }
        if (binding.scope === literal_types_1.BindingScopeEnum.Request && requestScope.has(binding.id)) {
          return requestScope.get(binding.id);
        }
        return null;
      };
      exports.tryGetFromScope = tryGetFromScope;
      var saveToScope = function(requestScope, binding, result) {
        if (binding.scope === literal_types_1.BindingScopeEnum.Singleton) {
          _saveToSingletonScope(binding, result);
        }
        if (binding.scope === literal_types_1.BindingScopeEnum.Request) {
          _saveToRequestScope(requestScope, binding, result);
        }
      };
      exports.saveToScope = saveToScope;
      var _saveToRequestScope = function(requestScope, binding, result) {
        if (!requestScope.has(binding.id)) {
          requestScope.set(binding.id, result);
        }
      };
      var _saveToSingletonScope = function(binding, result) {
        binding.cache = result;
        binding.activated = true;
        if ((0, async_1.isPromise)(result)) {
          void _saveAsyncResultToSingletonScope(binding, result);
        }
      };
      var _saveAsyncResultToSingletonScope = function(binding, asyncResult) {
        return __awaiter(void 0, void 0, void 0, function() {
          var result, ex_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, asyncResult];
              case 1:
                result = _a.sent();
                binding.cache = result;
                return [3, 3];
              case 2:
                ex_1 = _a.sent();
                binding.cache = null;
                binding.activated = false;
                throw ex_1;
              case 3:
                return [2];
            }
          });
        });
      };
    }
  });

  // node_modules/inversify/lib/utils/factory_type.js
  var require_factory_type = __commonJS({
    "node_modules/inversify/lib/utils/factory_type.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FactoryType = void 0;
      var FactoryType;
      (function(FactoryType2) {
        FactoryType2["DynamicValue"] = "toDynamicValue";
        FactoryType2["Factory"] = "toFactory";
        FactoryType2["Provider"] = "toProvider";
      })(FactoryType = exports.FactoryType || (exports.FactoryType = {}));
    }
  });

  // node_modules/inversify/lib/utils/binding_utils.js
  var require_binding_utils = __commonJS({
    "node_modules/inversify/lib/utils/binding_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFactoryDetails = exports.ensureFullyBound = exports.multiBindToService = void 0;
      var serialization_1 = require_serialization();
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var factory_type_1 = require_factory_type();
      var multiBindToService = function(container) {
        return function(service) {
          return function() {
            var types = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              types[_i] = arguments[_i];
            }
            return types.forEach(function(t) {
              return container.bind(t).toService(service);
            });
          };
        };
      };
      exports.multiBindToService = multiBindToService;
      var ensureFullyBound = function(binding) {
        var boundValue = null;
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.ConstantValue:
          case literal_types_1.BindingTypeEnum.Function:
            boundValue = binding.cache;
            break;
          case literal_types_1.BindingTypeEnum.Constructor:
          case literal_types_1.BindingTypeEnum.Instance:
            boundValue = binding.implementationType;
            break;
          case literal_types_1.BindingTypeEnum.DynamicValue:
            boundValue = binding.dynamicValue;
            break;
          case literal_types_1.BindingTypeEnum.Provider:
            boundValue = binding.provider;
            break;
          case literal_types_1.BindingTypeEnum.Factory:
            boundValue = binding.factory;
            break;
        }
        if (boundValue === null) {
          var serviceIdentifierAsString = (0, serialization_1.getServiceIdentifierAsString)(binding.serviceIdentifier);
          throw new Error(ERROR_MSGS.INVALID_BINDING_TYPE + " " + serviceIdentifierAsString);
        }
      };
      exports.ensureFullyBound = ensureFullyBound;
      var getFactoryDetails = function(binding) {
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.Factory:
            return { factory: binding.factory, factoryType: factory_type_1.FactoryType.Factory };
          case literal_types_1.BindingTypeEnum.Provider:
            return { factory: binding.provider, factoryType: factory_type_1.FactoryType.Provider };
          case literal_types_1.BindingTypeEnum.DynamicValue:
            return { factory: binding.dynamicValue, factoryType: factory_type_1.FactoryType.DynamicValue };
          default:
            throw new Error("Unexpected factory type " + binding.type);
        }
      };
      exports.getFactoryDetails = getFactoryDetails;
    }
  });

  // node_modules/inversify/lib/resolution/instantiation.js
  var require_instantiation = __commonJS({
    "node_modules/inversify/lib/resolution/instantiation.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolveInstance = void 0;
      var error_msgs_1 = require_error_msgs();
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var async_1 = require_async();
      function _resolveRequests(childRequests, resolveRequest) {
        return childRequests.reduce(function(resolvedRequests, childRequest) {
          var injection = resolveRequest(childRequest);
          var targetType = childRequest.target.type;
          if (targetType === literal_types_1.TargetTypeEnum.ConstructorArgument) {
            resolvedRequests.constructorInjections.push(injection);
          } else {
            resolvedRequests.propertyRequests.push(childRequest);
            resolvedRequests.propertyInjections.push(injection);
          }
          if (!resolvedRequests.isAsync) {
            resolvedRequests.isAsync = (0, async_1.isPromiseOrContainsPromise)(injection);
          }
          return resolvedRequests;
        }, { constructorInjections: [], propertyInjections: [], propertyRequests: [], isAsync: false });
      }
      function _createInstance(constr, childRequests, resolveRequest) {
        var result;
        if (childRequests.length > 0) {
          var resolved = _resolveRequests(childRequests, resolveRequest);
          var createInstanceWithInjectionsArg = __assign(__assign({}, resolved), { constr });
          if (resolved.isAsync) {
            result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);
          } else {
            result = createInstanceWithInjections(createInstanceWithInjectionsArg);
          }
        } else {
          result = new constr();
        }
        return result;
      }
      function createInstanceWithInjections(args) {
        var _a;
        var instance = new ((_a = args.constr).bind.apply(_a, __spreadArray([void 0], args.constructorInjections, false)))();
        args.propertyRequests.forEach(function(r, index) {
          var property = r.target.identifier;
          var injection = args.propertyInjections[index];
          if (!r.target.isOptional() || injection !== void 0) {
            instance[property] = injection;
          }
        });
        return instance;
      }
      function createInstanceWithInjectionsAsync(args) {
        return __awaiter(this, void 0, void 0, function() {
          var constructorInjections, propertyInjections;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, possiblyWaitInjections(args.constructorInjections)];
              case 1:
                constructorInjections = _a.sent();
                return [4, possiblyWaitInjections(args.propertyInjections)];
              case 2:
                propertyInjections = _a.sent();
                return [2, createInstanceWithInjections(__assign(__assign({}, args), { constructorInjections, propertyInjections }))];
            }
          });
        });
      }
      function possiblyWaitInjections(possiblePromiseinjections) {
        return __awaiter(this, void 0, void 0, function() {
          var injections, _i, possiblePromiseinjections_1, injection;
          return __generator(this, function(_a) {
            injections = [];
            for (_i = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i < possiblePromiseinjections_1.length; _i++) {
              injection = possiblePromiseinjections_1[_i];
              if (Array.isArray(injection)) {
                injections.push(Promise.all(injection));
              } else {
                injections.push(injection);
              }
            }
            return [2, Promise.all(injections)];
          });
        });
      }
      function _getInstanceAfterPostConstruct(constr, result) {
        var postConstructResult = _postConstruct(constr, result);
        if ((0, async_1.isPromise)(postConstructResult)) {
          return postConstructResult.then(function() {
            return result;
          });
        } else {
          return result;
        }
      }
      function _postConstruct(constr, instance) {
        var _a, _b;
        if (Reflect.hasMetadata(METADATA_KEY.POST_CONSTRUCT, constr)) {
          var data = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, constr);
          try {
            return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);
          } catch (e) {
            if (e instanceof Error) {
              throw new Error((0, error_msgs_1.POST_CONSTRUCT_ERROR)(constr.name, e.message));
            }
          }
        }
      }
      function _validateInstanceResolution(binding, constr) {
        if (binding.scope !== literal_types_1.BindingScopeEnum.Singleton) {
          _throwIfHandlingDeactivation(binding, constr);
        }
      }
      function _throwIfHandlingDeactivation(binding, constr) {
        var scopeErrorMessage = "Class cannot be instantiated in " + (binding.scope === literal_types_1.BindingScopeEnum.Request ? "request" : "transient") + " scope.";
        if (typeof binding.onDeactivation === "function") {
          throw new Error((0, error_msgs_1.ON_DEACTIVATION_ERROR)(constr.name, scopeErrorMessage));
        }
        if (Reflect.hasMetadata(METADATA_KEY.PRE_DESTROY, constr)) {
          throw new Error((0, error_msgs_1.PRE_DESTROY_ERROR)(constr.name, scopeErrorMessage));
        }
      }
      function resolveInstance(binding, constr, childRequests, resolveRequest) {
        _validateInstanceResolution(binding, constr);
        var result = _createInstance(constr, childRequests, resolveRequest);
        if ((0, async_1.isPromise)(result)) {
          return result.then(function(resolvedResult) {
            return _getInstanceAfterPostConstruct(constr, resolvedResult);
          });
        } else {
          return _getInstanceAfterPostConstruct(constr, result);
        }
      }
      exports.resolveInstance = resolveInstance;
    }
  });

  // node_modules/inversify/lib/resolution/resolver.js
  var require_resolver = __commonJS({
    "node_modules/inversify/lib/resolution/resolver.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolve = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var planner_1 = require_planner();
      var scope_1 = require_scope();
      var async_1 = require_async();
      var binding_utils_1 = require_binding_utils();
      var exceptions_1 = require_exceptions();
      var instantiation_1 = require_instantiation();
      var _resolveRequest = function(requestScope) {
        return function(request) {
          request.parentContext.setCurrentRequest(request);
          var bindings = request.bindings;
          var childRequests = request.childRequests;
          var targetIsAnArray = request.target && request.target.isArray();
          var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
          if (targetIsAnArray && targetParentIsNotAnArray) {
            return childRequests.map(function(childRequest) {
              var _f = _resolveRequest(requestScope);
              return _f(childRequest);
            });
          } else {
            if (request.target.isOptional() && bindings.length === 0) {
              return void 0;
            }
            var binding = bindings[0];
            return _resolveBinding(requestScope, request, binding);
          }
        };
      };
      var _resolveFactoryFromBinding = function(binding, context) {
        var factoryDetails = (0, binding_utils_1.getFactoryDetails)(binding);
        return (0, exceptions_1.tryAndThrowErrorIfStackOverflow)(function() {
          return factoryDetails.factory.bind(binding)(context);
        }, function() {
          return new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString()));
        });
      };
      var _getResolvedFromBinding = function(requestScope, request, binding) {
        var result;
        var childRequests = request.childRequests;
        (0, binding_utils_1.ensureFullyBound)(binding);
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.ConstantValue:
          case literal_types_1.BindingTypeEnum.Function:
            result = binding.cache;
            break;
          case literal_types_1.BindingTypeEnum.Constructor:
            result = binding.implementationType;
            break;
          case literal_types_1.BindingTypeEnum.Instance:
            result = (0, instantiation_1.resolveInstance)(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
            break;
          default:
            result = _resolveFactoryFromBinding(binding, request.parentContext);
        }
        return result;
      };
      var _resolveInScope = function(requestScope, binding, resolveFromBinding) {
        var result = (0, scope_1.tryGetFromScope)(requestScope, binding);
        if (result !== null) {
          return result;
        }
        result = resolveFromBinding();
        (0, scope_1.saveToScope)(requestScope, binding, result);
        return result;
      };
      var _resolveBinding = function(requestScope, request, binding) {
        return _resolveInScope(requestScope, binding, function() {
          var result = _getResolvedFromBinding(requestScope, request, binding);
          if ((0, async_1.isPromise)(result)) {
            result = result.then(function(resolved) {
              return _onActivation(request, binding, resolved);
            });
          } else {
            result = _onActivation(request, binding, result);
          }
          return result;
        });
      };
      function _onActivation(request, binding, resolved) {
        var result = _bindingActivation(request.parentContext, binding, resolved);
        var containersIterator = _getContainersIterator(request.parentContext.container);
        var container;
        var containersIteratorResult = containersIterator.next();
        do {
          container = containersIteratorResult.value;
          var context_1 = request.parentContext;
          var serviceIdentifier = request.serviceIdentifier;
          var activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
          if ((0, async_1.isPromise)(result)) {
            result = _activateContainerAsync(activationsIterator, context_1, result);
          } else {
            result = _activateContainer(activationsIterator, context_1, result);
          }
          containersIteratorResult = containersIterator.next();
        } while (containersIteratorResult.done !== true && !(0, planner_1.getBindingDictionary)(container).hasKey(request.serviceIdentifier));
        return result;
      }
      var _bindingActivation = function(context, binding, previousResult) {
        var result;
        if (typeof binding.onActivation === "function") {
          result = binding.onActivation(context, previousResult);
        } else {
          result = previousResult;
        }
        return result;
      };
      var _activateContainer = function(activationsIterator, context, result) {
        var activation = activationsIterator.next();
        while (!activation.done) {
          result = activation.value(context, result);
          if ((0, async_1.isPromise)(result)) {
            return _activateContainerAsync(activationsIterator, context, result);
          }
          activation = activationsIterator.next();
        }
        return result;
      };
      var _activateContainerAsync = function(activationsIterator, context, resultPromise) {
        return __awaiter(void 0, void 0, void 0, function() {
          var result, activation;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, resultPromise];
              case 1:
                result = _a.sent();
                activation = activationsIterator.next();
                _a.label = 2;
              case 2:
                if (!!activation.done)
                  return [3, 4];
                return [4, activation.value(context, result)];
              case 3:
                result = _a.sent();
                activation = activationsIterator.next();
                return [3, 2];
              case 4:
                return [2, result];
            }
          });
        });
      };
      var _getContainerActivationsForService = function(container, serviceIdentifier) {
        var activations = container._activations;
        return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
      };
      var _getContainersIterator = function(container) {
        var containersStack = [container];
        var parent = container.parent;
        while (parent !== null) {
          containersStack.push(parent);
          parent = parent.parent;
        }
        var getNextContainer = function() {
          var nextContainer = containersStack.pop();
          if (nextContainer !== void 0) {
            return { done: false, value: nextContainer };
          } else {
            return { done: true, value: void 0 };
          }
        };
        var containersIterator = {
          next: getNextContainer
        };
        return containersIterator;
      };
      function resolve(context) {
        var _f = _resolveRequest(context.plan.rootRequest.requestScope);
        return _f(context.plan.rootRequest);
      }
      exports.resolve = resolve;
    }
  });

  // node_modules/inversify/lib/syntax/constraint_helpers.js
  var require_constraint_helpers = __commonJS({
    "node_modules/inversify/lib/syntax/constraint_helpers.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var traverseAncerstors = function(request, constraint) {
        var parent = request.parentRequest;
        if (parent !== null) {
          return constraint(parent) ? true : traverseAncerstors(parent, constraint);
        } else {
          return false;
        }
      };
      exports.traverseAncerstors = traverseAncerstors;
      var taggedConstraint = function(key) {
        return function(value) {
          var constraint = function(request) {
            return request !== null && request.target !== null && request.target.matchesTag(key)(value);
          };
          constraint.metaData = new metadata_1.Metadata(key, value);
          return constraint;
        };
      };
      exports.taggedConstraint = taggedConstraint;
      var namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);
      exports.namedConstraint = namedConstraint;
      var typeConstraint = function(type) {
        return function(request) {
          var binding = null;
          if (request !== null) {
            binding = request.bindings[0];
            if (typeof type === "string") {
              var serviceIdentifier = binding.serviceIdentifier;
              return serviceIdentifier === type;
            } else {
              var constructor = request.bindings[0].implementationType;
              return type === constructor;
            }
          }
          return false;
        };
      };
      exports.typeConstraint = typeConstraint;
    }
  });

  // node_modules/inversify/lib/syntax/binding_when_syntax.js
  var require_binding_when_syntax = __commonJS({
    "node_modules/inversify/lib/syntax/binding_when_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingWhenSyntax = void 0;
      var binding_on_syntax_1 = require_binding_on_syntax();
      var constraint_helpers_1 = require_constraint_helpers();
      var BindingWhenSyntax = function() {
        function BindingWhenSyntax2(binding) {
          this._binding = binding;
        }
        BindingWhenSyntax2.prototype.when = function(constraint) {
          this._binding.constraint = constraint;
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenTargetNamed = function(name) {
          this._binding.constraint = (0, constraint_helpers_1.namedConstraint)(name);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenTargetIsDefault = function() {
          this._binding.constraint = function(request) {
            if (request === null) {
              return false;
            }
            var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
            return targetIsDefault;
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenTargetTagged = function(tag, value) {
          this._binding.constraint = (0, constraint_helpers_1.taggedConstraint)(tag)(value);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenInjectedInto = function(parent) {
          this._binding.constraint = function(request) {
            return request !== null && (0, constraint_helpers_1.typeConstraint)(parent)(request.parentRequest);
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenParentNamed = function(name) {
          this._binding.constraint = function(request) {
            return request !== null && (0, constraint_helpers_1.namedConstraint)(name)(request.parentRequest);
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenParentTagged = function(tag, value) {
          this._binding.constraint = function(request) {
            return request !== null && (0, constraint_helpers_1.taggedConstraint)(tag)(value)(request.parentRequest);
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
          this._binding.constraint = function(request) {
            return request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.typeConstraint)(ancestor));
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
          this._binding.constraint = function(request) {
            return request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.typeConstraint)(ancestor));
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenAnyAncestorNamed = function(name) {
          this._binding.constraint = function(request) {
            return request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.namedConstraint)(name));
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenNoAncestorNamed = function(name) {
          this._binding.constraint = function(request) {
            return request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.namedConstraint)(name));
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
          this._binding.constraint = function(request) {
            return request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.taggedConstraint)(tag)(value));
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
          this._binding.constraint = function(request) {
            return request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.taggedConstraint)(tag)(value));
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
          this._binding.constraint = function(request) {
            return request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, constraint);
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        BindingWhenSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
          this._binding.constraint = function(request) {
            return request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, constraint);
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        };
        return BindingWhenSyntax2;
      }();
      exports.BindingWhenSyntax = BindingWhenSyntax;
    }
  });

  // node_modules/inversify/lib/syntax/binding_on_syntax.js
  var require_binding_on_syntax = __commonJS({
    "node_modules/inversify/lib/syntax/binding_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingOnSyntax = void 0;
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingOnSyntax = function() {
        function BindingOnSyntax2(binding) {
          this._binding = binding;
        }
        BindingOnSyntax2.prototype.onActivation = function(handler) {
          this._binding.onActivation = handler;
          return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        };
        BindingOnSyntax2.prototype.onDeactivation = function(handler) {
          this._binding.onDeactivation = handler;
          return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        };
        return BindingOnSyntax2;
      }();
      exports.BindingOnSyntax = BindingOnSyntax;
    }
  });

  // node_modules/inversify/lib/syntax/binding_when_on_syntax.js
  var require_binding_when_on_syntax = __commonJS({
    "node_modules/inversify/lib/syntax/binding_when_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingWhenOnSyntax = void 0;
      var binding_on_syntax_1 = require_binding_on_syntax();
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingWhenOnSyntax = function() {
        function BindingWhenOnSyntax2(binding) {
          this._binding = binding;
          this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
          this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        BindingWhenOnSyntax2.prototype.when = function(constraint) {
          return this._bindingWhenSyntax.when(constraint);
        };
        BindingWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
          return this._bindingWhenSyntax.whenTargetNamed(name);
        };
        BindingWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        };
        BindingWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
          return this._bindingWhenSyntax.whenTargetTagged(tag, value);
        };
        BindingWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
          return this._bindingWhenSyntax.whenInjectedInto(parent);
        };
        BindingWhenOnSyntax2.prototype.whenParentNamed = function(name) {
          return this._bindingWhenSyntax.whenParentNamed(name);
        };
        BindingWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
          return this._bindingWhenSyntax.whenParentTagged(tag, value);
        };
        BindingWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
        };
        BindingWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
          return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
        };
        BindingWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
        };
        BindingWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
        };
        BindingWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(name);
        };
        BindingWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
        };
        BindingWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
        };
        BindingWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
        };
        BindingWhenOnSyntax2.prototype.onActivation = function(handler) {
          return this._bindingOnSyntax.onActivation(handler);
        };
        BindingWhenOnSyntax2.prototype.onDeactivation = function(handler) {
          return this._bindingOnSyntax.onDeactivation(handler);
        };
        return BindingWhenOnSyntax2;
      }();
      exports.BindingWhenOnSyntax = BindingWhenOnSyntax;
    }
  });

  // node_modules/inversify/lib/syntax/binding_in_syntax.js
  var require_binding_in_syntax = __commonJS({
    "node_modules/inversify/lib/syntax/binding_in_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingInSyntax = void 0;
      var literal_types_1 = require_literal_types();
      var binding_when_on_syntax_1 = require_binding_when_on_syntax();
      var BindingInSyntax = function() {
        function BindingInSyntax2(binding) {
          this._binding = binding;
        }
        BindingInSyntax2.prototype.inRequestScope = function() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Request;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        BindingInSyntax2.prototype.inSingletonScope = function() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        BindingInSyntax2.prototype.inTransientScope = function() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Transient;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        return BindingInSyntax2;
      }();
      exports.BindingInSyntax = BindingInSyntax;
    }
  });

  // node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js
  var require_binding_in_when_on_syntax = __commonJS({
    "node_modules/inversify/lib/syntax/binding_in_when_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingInWhenOnSyntax = void 0;
      var binding_in_syntax_1 = require_binding_in_syntax();
      var binding_on_syntax_1 = require_binding_on_syntax();
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingInWhenOnSyntax = function() {
        function BindingInWhenOnSyntax2(binding) {
          this._binding = binding;
          this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
          this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
          this._bindingInSyntax = new binding_in_syntax_1.BindingInSyntax(binding);
        }
        BindingInWhenOnSyntax2.prototype.inRequestScope = function() {
          return this._bindingInSyntax.inRequestScope();
        };
        BindingInWhenOnSyntax2.prototype.inSingletonScope = function() {
          return this._bindingInSyntax.inSingletonScope();
        };
        BindingInWhenOnSyntax2.prototype.inTransientScope = function() {
          return this._bindingInSyntax.inTransientScope();
        };
        BindingInWhenOnSyntax2.prototype.when = function(constraint) {
          return this._bindingWhenSyntax.when(constraint);
        };
        BindingInWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
          return this._bindingWhenSyntax.whenTargetNamed(name);
        };
        BindingInWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        };
        BindingInWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
          return this._bindingWhenSyntax.whenTargetTagged(tag, value);
        };
        BindingInWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
          return this._bindingWhenSyntax.whenInjectedInto(parent);
        };
        BindingInWhenOnSyntax2.prototype.whenParentNamed = function(name) {
          return this._bindingWhenSyntax.whenParentNamed(name);
        };
        BindingInWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
          return this._bindingWhenSyntax.whenParentTagged(tag, value);
        };
        BindingInWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
        };
        BindingInWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
          return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
        };
        BindingInWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
        };
        BindingInWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
        };
        BindingInWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(name);
        };
        BindingInWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
        };
        BindingInWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
        };
        BindingInWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
        };
        BindingInWhenOnSyntax2.prototype.onActivation = function(handler) {
          return this._bindingOnSyntax.onActivation(handler);
        };
        BindingInWhenOnSyntax2.prototype.onDeactivation = function(handler) {
          return this._bindingOnSyntax.onDeactivation(handler);
        };
        return BindingInWhenOnSyntax2;
      }();
      exports.BindingInWhenOnSyntax = BindingInWhenOnSyntax;
    }
  });

  // node_modules/inversify/lib/syntax/binding_to_syntax.js
  var require_binding_to_syntax = __commonJS({
    "node_modules/inversify/lib/syntax/binding_to_syntax.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingToSyntax = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var binding_in_when_on_syntax_1 = require_binding_in_when_on_syntax();
      var binding_when_on_syntax_1 = require_binding_when_on_syntax();
      var BindingToSyntax = function() {
        function BindingToSyntax2(binding) {
          this._binding = binding;
        }
        BindingToSyntax2.prototype.to = function(constructor) {
          this._binding.type = literal_types_1.BindingTypeEnum.Instance;
          this._binding.implementationType = constructor;
          return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
        };
        BindingToSyntax2.prototype.toSelf = function() {
          if (typeof this._binding.serviceIdentifier !== "function") {
            throw new Error("" + ERROR_MSGS.INVALID_TO_SELF_VALUE);
          }
          var self2 = this._binding.serviceIdentifier;
          return this.to(self2);
        };
        BindingToSyntax2.prototype.toConstantValue = function(value) {
          this._binding.type = literal_types_1.BindingTypeEnum.ConstantValue;
          this._binding.cache = value;
          this._binding.dynamicValue = null;
          this._binding.implementationType = null;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        BindingToSyntax2.prototype.toDynamicValue = function(func) {
          this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
          this._binding.cache = null;
          this._binding.dynamicValue = func;
          this._binding.implementationType = null;
          return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
        };
        BindingToSyntax2.prototype.toConstructor = function(constructor) {
          this._binding.type = literal_types_1.BindingTypeEnum.Constructor;
          this._binding.implementationType = constructor;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        BindingToSyntax2.prototype.toFactory = function(factory) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = factory;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        BindingToSyntax2.prototype.toFunction = function(func) {
          if (typeof func !== "function") {
            throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);
          }
          var bindingWhenOnSyntax = this.toConstantValue(func);
          this._binding.type = literal_types_1.BindingTypeEnum.Function;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return bindingWhenOnSyntax;
        };
        BindingToSyntax2.prototype.toAutoFactory = function(serviceIdentifier) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = function(context) {
            var autofactory = function() {
              return context.container.get(serviceIdentifier);
            };
            return autofactory;
          };
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        BindingToSyntax2.prototype.toAutoNamedFactory = function(serviceIdentifier) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = function(context) {
            return function(named) {
              return context.container.getNamed(serviceIdentifier, named);
            };
          };
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        BindingToSyntax2.prototype.toProvider = function(provider) {
          this._binding.type = literal_types_1.BindingTypeEnum.Provider;
          this._binding.provider = provider;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        };
        BindingToSyntax2.prototype.toService = function(service) {
          this.toDynamicValue(function(context) {
            return context.container.get(service);
          });
        };
        return BindingToSyntax2;
      }();
      exports.BindingToSyntax = BindingToSyntax;
    }
  });

  // node_modules/inversify/lib/container/container_snapshot.js
  var require_container_snapshot = __commonJS({
    "node_modules/inversify/lib/container/container_snapshot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContainerSnapshot = void 0;
      var ContainerSnapshot = function() {
        function ContainerSnapshot2() {
        }
        ContainerSnapshot2.of = function(bindings, middleware, activations, deactivations, moduleActivationStore) {
          var snapshot = new ContainerSnapshot2();
          snapshot.bindings = bindings;
          snapshot.middleware = middleware;
          snapshot.deactivations = deactivations;
          snapshot.activations = activations;
          snapshot.moduleActivationStore = moduleActivationStore;
          return snapshot;
        };
        return ContainerSnapshot2;
      }();
      exports.ContainerSnapshot = ContainerSnapshot;
    }
  });

  // node_modules/inversify/lib/utils/clonable.js
  var require_clonable = __commonJS({
    "node_modules/inversify/lib/utils/clonable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isClonable = void 0;
      function isClonable(obj) {
        return typeof obj === "object" && obj !== null && "clone" in obj && typeof obj.clone === "function";
      }
      exports.isClonable = isClonable;
    }
  });

  // node_modules/inversify/lib/container/lookup.js
  var require_lookup = __commonJS({
    "node_modules/inversify/lib/container/lookup.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Lookup = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var clonable_1 = require_clonable();
      var Lookup = function() {
        function Lookup2() {
          this._map = /* @__PURE__ */ new Map();
        }
        Lookup2.prototype.getMap = function() {
          return this._map;
        };
        Lookup2.prototype.add = function(serviceIdentifier, value) {
          if (serviceIdentifier === null || serviceIdentifier === void 0) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
          if (value === null || value === void 0) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
          var entry = this._map.get(serviceIdentifier);
          if (entry !== void 0) {
            entry.push(value);
          } else {
            this._map.set(serviceIdentifier, [value]);
          }
        };
        Lookup2.prototype.get = function(serviceIdentifier) {
          if (serviceIdentifier === null || serviceIdentifier === void 0) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
          var entry = this._map.get(serviceIdentifier);
          if (entry !== void 0) {
            return entry;
          } else {
            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
          }
        };
        Lookup2.prototype.remove = function(serviceIdentifier) {
          if (serviceIdentifier === null || serviceIdentifier === void 0) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
          if (!this._map.delete(serviceIdentifier)) {
            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
          }
        };
        Lookup2.prototype.removeIntersection = function(lookup) {
          var _this = this;
          this.traverse(function(serviceIdentifier, value) {
            var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0;
            if (lookupActivations !== void 0) {
              var filteredValues = value.filter(function(lookupValue) {
                return !lookupActivations.some(function(moduleActivation) {
                  return lookupValue === moduleActivation;
                });
              });
              _this._setValue(serviceIdentifier, filteredValues);
            }
          });
        };
        Lookup2.prototype.removeByCondition = function(condition) {
          var _this = this;
          var removals = [];
          this._map.forEach(function(entries, key) {
            var updatedEntries = [];
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
              var entry = entries_1[_i];
              var remove = condition(entry);
              if (remove) {
                removals.push(entry);
              } else {
                updatedEntries.push(entry);
              }
            }
            _this._setValue(key, updatedEntries);
          });
          return removals;
        };
        Lookup2.prototype.hasKey = function(serviceIdentifier) {
          if (serviceIdentifier === null || serviceIdentifier === void 0) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
          return this._map.has(serviceIdentifier);
        };
        Lookup2.prototype.clone = function() {
          var copy = new Lookup2();
          this._map.forEach(function(value, key) {
            value.forEach(function(b) {
              return copy.add(key, (0, clonable_1.isClonable)(b) ? b.clone() : b);
            });
          });
          return copy;
        };
        Lookup2.prototype.traverse = function(func) {
          this._map.forEach(function(value, key) {
            func(key, value);
          });
        };
        Lookup2.prototype._setValue = function(serviceIdentifier, value) {
          if (value.length > 0) {
            this._map.set(serviceIdentifier, value);
          } else {
            this._map.delete(serviceIdentifier);
          }
        };
        return Lookup2;
      }();
      exports.Lookup = Lookup;
    }
  });

  // node_modules/inversify/lib/container/module_activation_store.js
  var require_module_activation_store = __commonJS({
    "node_modules/inversify/lib/container/module_activation_store.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModuleActivationStore = void 0;
      var lookup_1 = require_lookup();
      var ModuleActivationStore = function() {
        function ModuleActivationStore2() {
          this._map = /* @__PURE__ */ new Map();
        }
        ModuleActivationStore2.prototype.remove = function(moduleId) {
          if (this._map.has(moduleId)) {
            var handlers = this._map.get(moduleId);
            this._map.delete(moduleId);
            return handlers;
          }
          return this._getEmptyHandlersStore();
        };
        ModuleActivationStore2.prototype.addDeactivation = function(moduleId, serviceIdentifier, onDeactivation) {
          this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
        };
        ModuleActivationStore2.prototype.addActivation = function(moduleId, serviceIdentifier, onActivation) {
          this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
        };
        ModuleActivationStore2.prototype.clone = function() {
          var clone = new ModuleActivationStore2();
          this._map.forEach(function(handlersStore, moduleId) {
            clone._map.set(moduleId, {
              onActivations: handlersStore.onActivations.clone(),
              onDeactivations: handlersStore.onDeactivations.clone()
            });
          });
          return clone;
        };
        ModuleActivationStore2.prototype._getModuleActivationHandlers = function(moduleId) {
          var moduleActivationHandlers = this._map.get(moduleId);
          if (moduleActivationHandlers === void 0) {
            moduleActivationHandlers = this._getEmptyHandlersStore();
            this._map.set(moduleId, moduleActivationHandlers);
          }
          return moduleActivationHandlers;
        };
        ModuleActivationStore2.prototype._getEmptyHandlersStore = function() {
          var handlersStore = {
            onActivations: new lookup_1.Lookup(),
            onDeactivations: new lookup_1.Lookup()
          };
          return handlersStore;
        };
        return ModuleActivationStore2;
      }();
      exports.ModuleActivationStore = ModuleActivationStore;
    }
  });

  // node_modules/inversify/lib/container/container.js
  var require_container = __commonJS({
    "node_modules/inversify/lib/container/container.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Container = void 0;
      var binding_1 = require_binding();
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_reader_1 = require_metadata_reader();
      var planner_1 = require_planner();
      var resolver_1 = require_resolver();
      var binding_to_syntax_1 = require_binding_to_syntax();
      var async_1 = require_async();
      var id_1 = require_id();
      var serialization_1 = require_serialization();
      var container_snapshot_1 = require_container_snapshot();
      var lookup_1 = require_lookup();
      var module_activation_store_1 = require_module_activation_store();
      var Container2 = function() {
        function Container3(containerOptions) {
          var options = containerOptions || {};
          if (typeof options !== "object") {
            throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
          }
          if (options.defaultScope === void 0) {
            options.defaultScope = literal_types_1.BindingScopeEnum.Transient;
          } else if (options.defaultScope !== literal_types_1.BindingScopeEnum.Singleton && options.defaultScope !== literal_types_1.BindingScopeEnum.Transient && options.defaultScope !== literal_types_1.BindingScopeEnum.Request) {
            throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
          }
          if (options.autoBindInjectable === void 0) {
            options.autoBindInjectable = false;
          } else if (typeof options.autoBindInjectable !== "boolean") {
            throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
          }
          if (options.skipBaseClassChecks === void 0) {
            options.skipBaseClassChecks = false;
          } else if (typeof options.skipBaseClassChecks !== "boolean") {
            throw new Error("" + ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
          }
          this.options = {
            autoBindInjectable: options.autoBindInjectable,
            defaultScope: options.defaultScope,
            skipBaseClassChecks: options.skipBaseClassChecks
          };
          this.id = (0, id_1.id)();
          this._bindingDictionary = new lookup_1.Lookup();
          this._snapshots = [];
          this._middleware = null;
          this._activations = new lookup_1.Lookup();
          this._deactivations = new lookup_1.Lookup();
          this.parent = null;
          this._metadataReader = new metadata_reader_1.MetadataReader();
          this._moduleActivationStore = new module_activation_store_1.ModuleActivationStore();
        }
        Container3.merge = function(container1, container2) {
          var containers = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            containers[_i - 2] = arguments[_i];
          }
          var container = new Container3();
          var targetContainers = __spreadArray([container1, container2], containers, true).map(function(targetContainer) {
            return (0, planner_1.getBindingDictionary)(targetContainer);
          });
          var bindingDictionary = (0, planner_1.getBindingDictionary)(container);
          function copyDictionary(origin, destination) {
            origin.traverse(function(_key, value) {
              value.forEach(function(binding) {
                destination.add(binding.serviceIdentifier, binding.clone());
              });
            });
          }
          targetContainers.forEach(function(targetBindingDictionary) {
            copyDictionary(targetBindingDictionary, bindingDictionary);
          });
          return container;
        };
        Container3.prototype.load = function() {
          var modules = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
          }
          var getHelpers = this._getContainerModuleHelpersFactory();
          for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
            var currentModule = modules_1[_a];
            var containerModuleHelpers = getHelpers(currentModule.id);
            currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
          }
        };
        Container3.prototype.loadAsync = function() {
          var modules = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
          }
          return __awaiter(this, void 0, void 0, function() {
            var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  getHelpers = this._getContainerModuleHelpersFactory();
                  _a = 0, modules_2 = modules;
                  _b.label = 1;
                case 1:
                  if (!(_a < modules_2.length))
                    return [3, 4];
                  currentModule = modules_2[_a];
                  containerModuleHelpers = getHelpers(currentModule.id);
                  return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction)];
                case 2:
                  _b.sent();
                  _b.label = 3;
                case 3:
                  _a++;
                  return [3, 1];
                case 4:
                  return [2];
              }
            });
          });
        };
        Container3.prototype.unload = function() {
          var _this = this;
          var modules = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
          }
          modules.forEach(function(module2) {
            var deactivations = _this._removeModuleBindings(module2.id);
            _this._deactivateSingletons(deactivations);
            _this._removeModuleHandlers(module2.id);
          });
        };
        Container3.prototype.unloadAsync = function() {
          var modules = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
          }
          return __awaiter(this, void 0, void 0, function() {
            var _a, modules_3, module_1, deactivations;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = 0, modules_3 = modules;
                  _b.label = 1;
                case 1:
                  if (!(_a < modules_3.length))
                    return [3, 4];
                  module_1 = modules_3[_a];
                  deactivations = this._removeModuleBindings(module_1.id);
                  return [4, this._deactivateSingletonsAsync(deactivations)];
                case 2:
                  _b.sent();
                  this._removeModuleHandlers(module_1.id);
                  _b.label = 3;
                case 3:
                  _a++;
                  return [3, 1];
                case 4:
                  return [2];
              }
            });
          });
        };
        Container3.prototype.bind = function(serviceIdentifier) {
          var scope = this.options.defaultScope || literal_types_1.BindingScopeEnum.Transient;
          var binding = new binding_1.Binding(serviceIdentifier, scope);
          this._bindingDictionary.add(serviceIdentifier, binding);
          return new binding_to_syntax_1.BindingToSyntax(binding);
        };
        Container3.prototype.rebind = function(serviceIdentifier) {
          this.unbind(serviceIdentifier);
          return this.bind(serviceIdentifier);
        };
        Container3.prototype.rebindAsync = function(serviceIdentifier) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.unbindAsync(serviceIdentifier)];
                case 1:
                  _a.sent();
                  return [2, this.bind(serviceIdentifier)];
              }
            });
          });
        };
        Container3.prototype.unbind = function(serviceIdentifier) {
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            var bindings = this._bindingDictionary.get(serviceIdentifier);
            this._deactivateSingletons(bindings);
          }
          this._removeServiceFromDictionary(serviceIdentifier);
        };
        Container3.prototype.unbindAsync = function(serviceIdentifier) {
          return __awaiter(this, void 0, void 0, function() {
            var bindings;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!this._bindingDictionary.hasKey(serviceIdentifier))
                    return [3, 2];
                  bindings = this._bindingDictionary.get(serviceIdentifier);
                  return [4, this._deactivateSingletonsAsync(bindings)];
                case 1:
                  _a.sent();
                  _a.label = 2;
                case 2:
                  this._removeServiceFromDictionary(serviceIdentifier);
                  return [2];
              }
            });
          });
        };
        Container3.prototype.unbindAll = function() {
          var _this = this;
          this._bindingDictionary.traverse(function(_key, value) {
            _this._deactivateSingletons(value);
          });
          this._bindingDictionary = new lookup_1.Lookup();
        };
        Container3.prototype.unbindAllAsync = function() {
          return __awaiter(this, void 0, void 0, function() {
            var promises;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  promises = [];
                  this._bindingDictionary.traverse(function(_key, value) {
                    promises.push(_this._deactivateSingletonsAsync(value));
                  });
                  return [4, Promise.all(promises)];
                case 1:
                  _a.sent();
                  this._bindingDictionary = new lookup_1.Lookup();
                  return [2];
              }
            });
          });
        };
        Container3.prototype.onActivation = function(serviceIdentifier, onActivation) {
          this._activations.add(serviceIdentifier, onActivation);
        };
        Container3.prototype.onDeactivation = function(serviceIdentifier, onDeactivation) {
          this._deactivations.add(serviceIdentifier, onDeactivation);
        };
        Container3.prototype.isBound = function(serviceIdentifier) {
          var bound = this._bindingDictionary.hasKey(serviceIdentifier);
          if (!bound && this.parent) {
            bound = this.parent.isBound(serviceIdentifier);
          }
          return bound;
        };
        Container3.prototype.isCurrentBound = function(serviceIdentifier) {
          return this._bindingDictionary.hasKey(serviceIdentifier);
        };
        Container3.prototype.isBoundNamed = function(serviceIdentifier, named) {
          return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        };
        Container3.prototype.isBoundTagged = function(serviceIdentifier, key, value) {
          var bound = false;
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            var bindings = this._bindingDictionary.get(serviceIdentifier);
            var request_1 = (0, planner_1.createMockRequest)(this, serviceIdentifier, key, value);
            bound = bindings.some(function(b) {
              return b.constraint(request_1);
            });
          }
          if (!bound && this.parent) {
            bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
          }
          return bound;
        };
        Container3.prototype.snapshot = function() {
          this._snapshots.push(container_snapshot_1.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
        };
        Container3.prototype.restore = function() {
          var snapshot = this._snapshots.pop();
          if (snapshot === void 0) {
            throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);
          }
          this._bindingDictionary = snapshot.bindings;
          this._activations = snapshot.activations;
          this._deactivations = snapshot.deactivations;
          this._middleware = snapshot.middleware;
          this._moduleActivationStore = snapshot.moduleActivationStore;
        };
        Container3.prototype.createChild = function(containerOptions) {
          var child = new Container3(containerOptions || this.options);
          child.parent = this;
          return child;
        };
        Container3.prototype.applyMiddleware = function() {
          var middlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
          }
          var initial = this._middleware ? this._middleware : this._planAndResolve();
          this._middleware = middlewares.reduce(function(prev, curr) {
            return curr(prev);
          }, initial);
        };
        Container3.prototype.applyCustomMetadataReader = function(metadataReader) {
          this._metadataReader = metadataReader;
        };
        Container3.prototype.get = function(serviceIdentifier) {
          var getArgs = this._getNotAllArgs(serviceIdentifier, false);
          return this._getButThrowIfAsync(getArgs);
        };
        Container3.prototype.getAsync = function(serviceIdentifier) {
          return __awaiter(this, void 0, void 0, function() {
            var getArgs;
            return __generator(this, function(_a) {
              getArgs = this._getNotAllArgs(serviceIdentifier, false);
              return [2, this._get(getArgs)];
            });
          });
        };
        Container3.prototype.getTagged = function(serviceIdentifier, key, value) {
          var getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
          return this._getButThrowIfAsync(getArgs);
        };
        Container3.prototype.getTaggedAsync = function(serviceIdentifier, key, value) {
          return __awaiter(this, void 0, void 0, function() {
            var getArgs;
            return __generator(this, function(_a) {
              getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
              return [2, this._get(getArgs)];
            });
          });
        };
        Container3.prototype.getNamed = function(serviceIdentifier, named) {
          return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        };
        Container3.prototype.getNamedAsync = function(serviceIdentifier, named) {
          return this.getTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        };
        Container3.prototype.getAll = function(serviceIdentifier) {
          var getArgs = this._getAllArgs(serviceIdentifier);
          return this._getButThrowIfAsync(getArgs);
        };
        Container3.prototype.getAllAsync = function(serviceIdentifier) {
          var getArgs = this._getAllArgs(serviceIdentifier);
          return this._getAll(getArgs);
        };
        Container3.prototype.getAllTagged = function(serviceIdentifier, key, value) {
          var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
          return this._getButThrowIfAsync(getArgs);
        };
        Container3.prototype.getAllTaggedAsync = function(serviceIdentifier, key, value) {
          var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
          return this._getAll(getArgs);
        };
        Container3.prototype.getAllNamed = function(serviceIdentifier, named) {
          return this.getAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        };
        Container3.prototype.getAllNamedAsync = function(serviceIdentifier, named) {
          return this.getAllTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        };
        Container3.prototype.resolve = function(constructorFunction) {
          var isBound = this.isBound(constructorFunction);
          if (!isBound) {
            this.bind(constructorFunction).toSelf();
          }
          var resolved = this.get(constructorFunction);
          if (!isBound) {
            this.unbind(constructorFunction);
          }
          return resolved;
        };
        Container3.prototype._preDestroy = function(constructor, instance) {
          var _a, _b;
          if (Reflect.hasMetadata(METADATA_KEY.PRE_DESTROY, constructor)) {
            var data = Reflect.getMetadata(METADATA_KEY.PRE_DESTROY, constructor);
            return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);
          }
        };
        Container3.prototype._removeModuleHandlers = function(moduleId) {
          var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
          this._activations.removeIntersection(moduleActivationsHandlers.onActivations);
          this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
        };
        Container3.prototype._removeModuleBindings = function(moduleId) {
          return this._bindingDictionary.removeByCondition(function(binding) {
            return binding.moduleId === moduleId;
          });
        };
        Container3.prototype._deactivate = function(binding, instance) {
          var _this = this;
          var constructor = Object.getPrototypeOf(instance).constructor;
          try {
            if (this._deactivations.hasKey(binding.serviceIdentifier)) {
              var result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
              if ((0, async_1.isPromise)(result)) {
                return this._handleDeactivationError(result.then(function() {
                  return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor);
                }), constructor);
              }
            }
            var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
            if ((0, async_1.isPromise)(propagateDeactivationResult)) {
              return this._handleDeactivationError(propagateDeactivationResult, constructor);
            }
          } catch (ex) {
            if (ex instanceof Error) {
              throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR(constructor.name, ex.message));
            }
          }
        };
        Container3.prototype._handleDeactivationError = function(asyncResult, constructor) {
          return __awaiter(this, void 0, void 0, function() {
            var ex_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 2, , 3]);
                  return [4, asyncResult];
                case 1:
                  _a.sent();
                  return [3, 3];
                case 2:
                  ex_1 = _a.sent();
                  if (ex_1 instanceof Error) {
                    throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));
                  }
                  return [3, 3];
                case 3:
                  return [2];
              }
            });
          });
        };
        Container3.prototype._deactivateContainer = function(instance, deactivationsIterator) {
          var _this = this;
          var deactivation = deactivationsIterator.next();
          while (deactivation.value) {
            var result = deactivation.value(instance);
            if ((0, async_1.isPromise)(result)) {
              return result.then(function() {
                return _this._deactivateContainerAsync(instance, deactivationsIterator);
              });
            }
            deactivation = deactivationsIterator.next();
          }
        };
        Container3.prototype._deactivateContainerAsync = function(instance, deactivationsIterator) {
          return __awaiter(this, void 0, void 0, function() {
            var deactivation;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  deactivation = deactivationsIterator.next();
                  _a.label = 1;
                case 1:
                  if (!deactivation.value)
                    return [3, 3];
                  return [4, deactivation.value(instance)];
                case 2:
                  _a.sent();
                  deactivation = deactivationsIterator.next();
                  return [3, 1];
                case 3:
                  return [2];
              }
            });
          });
        };
        Container3.prototype._getContainerModuleHelpersFactory = function() {
          var _this = this;
          var setModuleId = function(bindingToSyntax, moduleId) {
            bindingToSyntax._binding.moduleId = moduleId;
          };
          var getBindFunction = function(moduleId) {
            return function(serviceIdentifier) {
              var bindingToSyntax = _this.bind(serviceIdentifier);
              setModuleId(bindingToSyntax, moduleId);
              return bindingToSyntax;
            };
          };
          var getUnbindFunction = function() {
            return function(serviceIdentifier) {
              return _this.unbind(serviceIdentifier);
            };
          };
          var getUnbindAsyncFunction = function() {
            return function(serviceIdentifier) {
              return _this.unbindAsync(serviceIdentifier);
            };
          };
          var getIsboundFunction = function() {
            return function(serviceIdentifier) {
              return _this.isBound(serviceIdentifier);
            };
          };
          var getRebindFunction = function(moduleId) {
            return function(serviceIdentifier) {
              var bindingToSyntax = _this.rebind(serviceIdentifier);
              setModuleId(bindingToSyntax, moduleId);
              return bindingToSyntax;
            };
          };
          var getOnActivationFunction = function(moduleId) {
            return function(serviceIdentifier, onActivation) {
              _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);
              _this.onActivation(serviceIdentifier, onActivation);
            };
          };
          var getOnDeactivationFunction = function(moduleId) {
            return function(serviceIdentifier, onDeactivation) {
              _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);
              _this.onDeactivation(serviceIdentifier, onDeactivation);
            };
          };
          return function(mId) {
            return {
              bindFunction: getBindFunction(mId),
              isboundFunction: getIsboundFunction(),
              onActivationFunction: getOnActivationFunction(mId),
              onDeactivationFunction: getOnDeactivationFunction(mId),
              rebindFunction: getRebindFunction(mId),
              unbindFunction: getUnbindFunction(),
              unbindAsyncFunction: getUnbindAsyncFunction()
            };
          };
        };
        Container3.prototype._getAll = function(getArgs) {
          return Promise.all(this._get(getArgs));
        };
        Container3.prototype._get = function(getArgs) {
          var planAndResolveArgs = __assign(__assign({}, getArgs), { contextInterceptor: function(context) {
            return context;
          }, targetType: literal_types_1.TargetTypeEnum.Variable });
          if (this._middleware) {
            var middlewareResult = this._middleware(planAndResolveArgs);
            if (middlewareResult === void 0 || middlewareResult === null) {
              throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);
            }
            return middlewareResult;
          }
          return this._planAndResolve()(planAndResolveArgs);
        };
        Container3.prototype._getButThrowIfAsync = function(getArgs) {
          var result = this._get(getArgs);
          if ((0, async_1.isPromiseOrContainsPromise)(result)) {
            throw new Error(ERROR_MSGS.LAZY_IN_SYNC(getArgs.serviceIdentifier));
          }
          return result;
        };
        Container3.prototype._getAllArgs = function(serviceIdentifier) {
          var getAllArgs = {
            avoidConstraints: true,
            isMultiInject: true,
            serviceIdentifier
          };
          return getAllArgs;
        };
        Container3.prototype._getNotAllArgs = function(serviceIdentifier, isMultiInject, key, value) {
          var getNotAllArgs = {
            avoidConstraints: false,
            isMultiInject,
            serviceIdentifier,
            key,
            value
          };
          return getNotAllArgs;
        };
        Container3.prototype._planAndResolve = function() {
          var _this = this;
          return function(args) {
            var context = (0, planner_1.plan)(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
            context = args.contextInterceptor(context);
            var result = (0, resolver_1.resolve)(context);
            return result;
          };
        };
        Container3.prototype._deactivateIfSingleton = function(binding) {
          var _this = this;
          if (!binding.activated) {
            return;
          }
          if ((0, async_1.isPromise)(binding.cache)) {
            return binding.cache.then(function(resolved) {
              return _this._deactivate(binding, resolved);
            });
          }
          return this._deactivate(binding, binding.cache);
        };
        Container3.prototype._deactivateSingletons = function(bindings) {
          for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {
            var binding = bindings_1[_i];
            var result = this._deactivateIfSingleton(binding);
            if ((0, async_1.isPromise)(result)) {
              throw new Error(ERROR_MSGS.ASYNC_UNBIND_REQUIRED);
            }
          }
        };
        Container3.prototype._deactivateSingletonsAsync = function(bindings) {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Promise.all(bindings.map(function(b) {
                    return _this._deactivateIfSingleton(b);
                  }))];
                case 1:
                  _a.sent();
                  return [2];
              }
            });
          });
        };
        Container3.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function(binding, instance, constructor) {
          if (this.parent) {
            return this._deactivate.bind(this.parent)(binding, instance);
          } else {
            return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
          }
        };
        Container3.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function(binding, instance, constructor) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!this.parent)
                    return [3, 2];
                  return [4, this._deactivate.bind(this.parent)(binding, instance)];
                case 1:
                  _a.sent();
                  return [3, 4];
                case 2:
                  return [4, this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor)];
                case 3:
                  _a.sent();
                  _a.label = 4;
                case 4:
                  return [2];
              }
            });
          });
        };
        Container3.prototype._removeServiceFromDictionary = function(serviceIdentifier) {
          try {
            this._bindingDictionary.remove(serviceIdentifier);
          } catch (e) {
            throw new Error(ERROR_MSGS.CANNOT_UNBIND + " " + (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier));
          }
        };
        Container3.prototype._bindingDeactivationAndPreDestroy = function(binding, instance, constructor) {
          var _this = this;
          if (typeof binding.onDeactivation === "function") {
            var result = binding.onDeactivation(instance);
            if ((0, async_1.isPromise)(result)) {
              return result.then(function() {
                return _this._preDestroy(constructor, instance);
              });
            }
          }
          return this._preDestroy(constructor, instance);
        };
        Container3.prototype._bindingDeactivationAndPreDestroyAsync = function(binding, instance, constructor) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!(typeof binding.onDeactivation === "function"))
                    return [3, 2];
                  return [4, binding.onDeactivation(instance)];
                case 1:
                  _a.sent();
                  _a.label = 2;
                case 2:
                  return [4, this._preDestroy(constructor, instance)];
                case 3:
                  _a.sent();
                  return [2];
              }
            });
          });
        };
        return Container3;
      }();
      exports.Container = Container2;
    }
  });

  // node_modules/inversify/lib/container/container_module.js
  var require_container_module = __commonJS({
    "node_modules/inversify/lib/container/container_module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncContainerModule = exports.ContainerModule = void 0;
      var id_1 = require_id();
      var ContainerModule4 = function() {
        function ContainerModule5(registry) {
          this.id = (0, id_1.id)();
          this.registry = registry;
        }
        return ContainerModule5;
      }();
      exports.ContainerModule = ContainerModule4;
      var AsyncContainerModule = function() {
        function AsyncContainerModule2(registry) {
          this.id = (0, id_1.id)();
          this.registry = registry;
        }
        return AsyncContainerModule2;
      }();
      exports.AsyncContainerModule = AsyncContainerModule;
    }
  });

  // node_modules/inversify/lib/utils/js.js
  var require_js = __commonJS({
    "node_modules/inversify/lib/utils/js.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFirstArrayDuplicate = void 0;
      function getFirstArrayDuplicate(array) {
        var seenValues = /* @__PURE__ */ new Set();
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
          var entry = array_1[_i];
          if (seenValues.has(entry)) {
            return entry;
          } else {
            seenValues.add(entry);
          }
        }
        return void 0;
      }
      exports.getFirstArrayDuplicate = getFirstArrayDuplicate;
    }
  });

  // node_modules/inversify/lib/annotation/decorator_utils.js
  var require_decorator_utils = __commonJS({
    "node_modules/inversify/lib/annotation/decorator_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createTaggedDecorator = exports.tagProperty = exports.tagParameter = exports.decorate = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var js_1 = require_js();
      function targetIsConstructorFunction(target) {
        return target.prototype !== void 0;
      }
      function _throwIfMethodParameter(parameterName) {
        if (parameterName !== void 0) {
          throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
        }
      }
      function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
        _throwIfMethodParameter(parameterName);
        _tagParameterOrProperty(METADATA_KEY.TAGGED, annotationTarget, parameterIndex.toString(), metadata);
      }
      exports.tagParameter = tagParameter;
      function tagProperty(annotationTarget, propertyName, metadata) {
        if (targetIsConstructorFunction(annotationTarget)) {
          throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
        }
        _tagParameterOrProperty(METADATA_KEY.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
      }
      exports.tagProperty = tagProperty;
      function _ensureNoMetadataKeyDuplicates(metadata) {
        var metadatas = [];
        if (Array.isArray(metadata)) {
          metadatas = metadata;
          var duplicate = (0, js_1.getFirstArrayDuplicate)(metadatas.map(function(md) {
            return md.key;
          }));
          if (duplicate !== void 0) {
            throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + duplicate.toString());
          }
        } else {
          metadatas = [metadata];
        }
        return metadatas;
      }
      function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
        var metadatas = _ensureNoMetadataKeyDuplicates(metadata);
        var paramsOrPropertiesMetadata = {};
        if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
          paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
        }
        var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
        if (paramOrPropertyMetadata === void 0) {
          paramOrPropertyMetadata = [];
        } else {
          var _loop_1 = function(m2) {
            if (metadatas.some(function(md) {
              return md.key === m2.key;
            })) {
              throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + m2.key.toString());
            }
          };
          for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
            var m = paramOrPropertyMetadata_1[_i];
            _loop_1(m);
          }
        }
        paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);
        paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
        Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
      }
      function createTaggedDecorator(metadata) {
        return function(target, targetKey, indexOrPropertyDescriptor) {
          if (typeof indexOrPropertyDescriptor === "number") {
            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
          } else {
            tagProperty(target, targetKey, metadata);
          }
        };
      }
      exports.createTaggedDecorator = createTaggedDecorator;
      function _decorate(decorators, target) {
        Reflect.decorate(decorators, target);
      }
      function _param(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function decorate(decorator, target, parameterIndexOrProperty) {
        if (typeof parameterIndexOrProperty === "number") {
          _decorate([_param(parameterIndexOrProperty, decorator)], target);
        } else if (typeof parameterIndexOrProperty === "string") {
          Reflect.decorate([decorator], target, parameterIndexOrProperty);
        } else {
          _decorate([decorator], target);
        }
      }
      exports.decorate = decorate;
    }
  });

  // node_modules/inversify/lib/annotation/injectable.js
  var require_injectable = __commonJS({
    "node_modules/inversify/lib/annotation/injectable.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.injectable = void 0;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      function injectable7() {
        return function(target) {
          if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {
            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);
          }
          var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];
          Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);
          return target;
        };
      }
      exports.injectable = injectable7;
    }
  });

  // node_modules/inversify/lib/annotation/tagged.js
  var require_tagged = __commonJS({
    "node_modules/inversify/lib/annotation/tagged.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tagged = void 0;
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function tagged(metadataKey, metadataValue) {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, metadataValue));
      }
      exports.tagged = tagged;
    }
  });

  // node_modules/inversify/lib/annotation/named.js
  var require_named = __commonJS({
    "node_modules/inversify/lib/annotation/named.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.named = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function named(name) {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, name));
      }
      exports.named = named;
    }
  });

  // node_modules/inversify/lib/annotation/inject_base.js
  var require_inject_base = __commonJS({
    "node_modules/inversify/lib/annotation/inject_base.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.injectBase = void 0;
      var error_msgs_1 = require_error_msgs();
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function injectBase(metadataKey) {
        return function(serviceIdentifier) {
          return function(target, targetKey, indexOrPropertyDescriptor) {
            if (serviceIdentifier === void 0) {
              var className = typeof target === "function" ? target.name : target.constructor.name;
              throw new Error((0, error_msgs_1.UNDEFINED_INJECT_ANNOTATION)(className));
            }
            return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
          };
        };
      }
      exports.injectBase = injectBase;
    }
  });

  // node_modules/inversify/lib/annotation/inject.js
  var require_inject = __commonJS({
    "node_modules/inversify/lib/annotation/inject.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.inject = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var inject_base_1 = require_inject_base();
      var inject4 = (0, inject_base_1.injectBase)(METADATA_KEY.INJECT_TAG);
      exports.inject = inject4;
    }
  });

  // node_modules/inversify/lib/annotation/optional.js
  var require_optional = __commonJS({
    "node_modules/inversify/lib/annotation/optional.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.optional = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function optional2() {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true));
      }
      exports.optional = optional2;
    }
  });

  // node_modules/inversify/lib/annotation/unmanaged.js
  var require_unmanaged = __commonJS({
    "node_modules/inversify/lib/annotation/unmanaged.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unmanaged = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function unmanaged() {
        return function(target, targetKey, index) {
          var metadata = new metadata_1.Metadata(METADATA_KEY.UNMANAGED_TAG, true);
          (0, decorator_utils_1.tagParameter)(target, targetKey, index, metadata);
        };
      }
      exports.unmanaged = unmanaged;
    }
  });

  // node_modules/inversify/lib/annotation/multi_inject.js
  var require_multi_inject = __commonJS({
    "node_modules/inversify/lib/annotation/multi_inject.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multiInject = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var inject_base_1 = require_inject_base();
      var multiInject = (0, inject_base_1.injectBase)(METADATA_KEY.MULTI_INJECT_TAG);
      exports.multiInject = multiInject;
    }
  });

  // node_modules/inversify/lib/annotation/target_name.js
  var require_target_name = __commonJS({
    "node_modules/inversify/lib/annotation/target_name.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.targetName = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function targetName(name) {
        return function(target, targetKey, index) {
          var metadata = new metadata_1.Metadata(METADATA_KEY.NAME_TAG, name);
          (0, decorator_utils_1.tagParameter)(target, targetKey, index, metadata);
        };
      }
      exports.targetName = targetName;
    }
  });

  // node_modules/inversify/lib/annotation/property_event_decorator.js
  var require_property_event_decorator = __commonJS({
    "node_modules/inversify/lib/annotation/property_event_decorator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.propertyEventDecorator = void 0;
      var metadata_1 = require_metadata();
      function propertyEventDecorator(eventKey, errorMessage) {
        return function() {
          return function(target, propertyKey) {
            var metadata = new metadata_1.Metadata(eventKey, propertyKey);
            if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {
              throw new Error(errorMessage);
            }
            Reflect.defineMetadata(eventKey, metadata, target.constructor);
          };
        };
      }
      exports.propertyEventDecorator = propertyEventDecorator;
    }
  });

  // node_modules/inversify/lib/annotation/post_construct.js
  var require_post_construct = __commonJS({
    "node_modules/inversify/lib/annotation/post_construct.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.postConstruct = void 0;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var property_event_decorator_1 = require_property_event_decorator();
      var postConstruct = (0, property_event_decorator_1.propertyEventDecorator)(METADATA_KEY.POST_CONSTRUCT, ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);
      exports.postConstruct = postConstruct;
    }
  });

  // node_modules/inversify/lib/annotation/pre_destroy.js
  var require_pre_destroy = __commonJS({
    "node_modules/inversify/lib/annotation/pre_destroy.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.preDestroy = void 0;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var property_event_decorator_1 = require_property_event_decorator();
      var preDestroy = (0, property_event_decorator_1.propertyEventDecorator)(METADATA_KEY.PRE_DESTROY, ERRORS_MSGS.MULTIPLE_PRE_DESTROY_METHODS);
      exports.preDestroy = preDestroy;
    }
  });

  // node_modules/inversify/lib/interfaces/interfaces.js
  var require_interfaces = __commonJS({
    "node_modules/inversify/lib/interfaces/interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.interfaces = void 0;
      var interfaces;
      (function(interfaces2) {
        ;
      })(interfaces || (interfaces = {}));
      exports.interfaces = interfaces;
    }
  });

  // node_modules/inversify/lib/inversify.js
  var require_inversify = __commonJS({
    "node_modules/inversify/lib/inversify.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multiBindToService = exports.getServiceIdentifierAsString = exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = exports.decorate = exports.interfaces = exports.id = exports.MetadataReader = exports.preDestroy = exports.postConstruct = exports.targetName = exports.multiInject = exports.unmanaged = exports.optional = exports.LazyServiceIdentifer = exports.LazyServiceIdentifier = exports.inject = exports.named = exports.tagged = exports.injectable = exports.createTaggedDecorator = exports.ContainerModule = exports.AsyncContainerModule = exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = exports.Container = exports.METADATA_KEY = void 0;
      var keys = __importStar(require_metadata_keys());
      exports.METADATA_KEY = keys;
      var container_1 = require_container();
      Object.defineProperty(exports, "Container", { enumerable: true, get: function() {
        return container_1.Container;
      } });
      var literal_types_1 = require_literal_types();
      Object.defineProperty(exports, "BindingScopeEnum", { enumerable: true, get: function() {
        return literal_types_1.BindingScopeEnum;
      } });
      Object.defineProperty(exports, "BindingTypeEnum", { enumerable: true, get: function() {
        return literal_types_1.BindingTypeEnum;
      } });
      Object.defineProperty(exports, "TargetTypeEnum", { enumerable: true, get: function() {
        return literal_types_1.TargetTypeEnum;
      } });
      var container_module_1 = require_container_module();
      Object.defineProperty(exports, "AsyncContainerModule", { enumerable: true, get: function() {
        return container_module_1.AsyncContainerModule;
      } });
      Object.defineProperty(exports, "ContainerModule", { enumerable: true, get: function() {
        return container_module_1.ContainerModule;
      } });
      var decorator_utils_1 = require_decorator_utils();
      Object.defineProperty(exports, "createTaggedDecorator", { enumerable: true, get: function() {
        return decorator_utils_1.createTaggedDecorator;
      } });
      var injectable_1 = require_injectable();
      Object.defineProperty(exports, "injectable", { enumerable: true, get: function() {
        return injectable_1.injectable;
      } });
      var tagged_1 = require_tagged();
      Object.defineProperty(exports, "tagged", { enumerable: true, get: function() {
        return tagged_1.tagged;
      } });
      var named_1 = require_named();
      Object.defineProperty(exports, "named", { enumerable: true, get: function() {
        return named_1.named;
      } });
      var inject_1 = require_inject();
      Object.defineProperty(exports, "inject", { enumerable: true, get: function() {
        return inject_1.inject;
      } });
      var lazy_service_identifier_1 = require_lazy_service_identifier();
      Object.defineProperty(exports, "LazyServiceIdentifier", { enumerable: true, get: function() {
        return lazy_service_identifier_1.LazyServiceIdentifier;
      } });
      var lazy_service_identifier_2 = require_lazy_service_identifier();
      Object.defineProperty(exports, "LazyServiceIdentifer", { enumerable: true, get: function() {
        return lazy_service_identifier_2.LazyServiceIdentifier;
      } });
      var optional_1 = require_optional();
      Object.defineProperty(exports, "optional", { enumerable: true, get: function() {
        return optional_1.optional;
      } });
      var unmanaged_1 = require_unmanaged();
      Object.defineProperty(exports, "unmanaged", { enumerable: true, get: function() {
        return unmanaged_1.unmanaged;
      } });
      var multi_inject_1 = require_multi_inject();
      Object.defineProperty(exports, "multiInject", { enumerable: true, get: function() {
        return multi_inject_1.multiInject;
      } });
      var target_name_1 = require_target_name();
      Object.defineProperty(exports, "targetName", { enumerable: true, get: function() {
        return target_name_1.targetName;
      } });
      var post_construct_1 = require_post_construct();
      Object.defineProperty(exports, "postConstruct", { enumerable: true, get: function() {
        return post_construct_1.postConstruct;
      } });
      var pre_destroy_1 = require_pre_destroy();
      Object.defineProperty(exports, "preDestroy", { enumerable: true, get: function() {
        return pre_destroy_1.preDestroy;
      } });
      var metadata_reader_1 = require_metadata_reader();
      Object.defineProperty(exports, "MetadataReader", { enumerable: true, get: function() {
        return metadata_reader_1.MetadataReader;
      } });
      var id_1 = require_id();
      Object.defineProperty(exports, "id", { enumerable: true, get: function() {
        return id_1.id;
      } });
      var interfaces_1 = require_interfaces();
      Object.defineProperty(exports, "interfaces", { enumerable: true, get: function() {
        return interfaces_1.interfaces;
      } });
      var decorator_utils_2 = require_decorator_utils();
      Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
        return decorator_utils_2.decorate;
      } });
      var constraint_helpers_1 = require_constraint_helpers();
      Object.defineProperty(exports, "traverseAncerstors", { enumerable: true, get: function() {
        return constraint_helpers_1.traverseAncerstors;
      } });
      Object.defineProperty(exports, "taggedConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.taggedConstraint;
      } });
      Object.defineProperty(exports, "namedConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.namedConstraint;
      } });
      Object.defineProperty(exports, "typeConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.typeConstraint;
      } });
      var serialization_1 = require_serialization();
      Object.defineProperty(exports, "getServiceIdentifierAsString", { enumerable: true, get: function() {
        return serialization_1.getServiceIdentifierAsString;
      } });
      var binding_utils_1 = require_binding_utils();
      Object.defineProperty(exports, "multiBindToService", { enumerable: true, get: function() {
        return binding_utils_1.multiBindToService;
      } });
    }
  });

  // node_modules/sprotty-protocol/lib/utils/object.js
  var require_object = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/object.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.safeAssign = exports.hasOwnProperty = exports.isObject = void 0;
      function isObject(data) {
        return typeof data === "object" && data !== null;
      }
      exports.isObject = isObject;
      function hasOwnProperty(arg, key, type) {
        if (!isObject(arg)) {
          return false;
        }
        if (Array.isArray(key)) {
          for (const k of key) {
            if (!Object.prototype.hasOwnProperty.call(arg, k)) {
              return false;
            }
            if (typeof type === "string" && typeof arg[k] !== type) {
              return false;
            } else if (typeof type === "function" && !type(arg[k])) {
              return false;
            }
          }
        } else {
          if (!Object.prototype.hasOwnProperty.call(arg, key)) {
            return false;
          }
          if (typeof type === "string") {
            return typeof arg[key] === type;
          }
          if (typeof type === "function") {
            return type(arg[key]);
          }
        }
        return true;
      }
      exports.hasOwnProperty = hasOwnProperty;
      function safeAssign(target, partial) {
        return Object.assign(target, partial);
      }
      exports.safeAssign = safeAssign;
    }
  });

  // node_modules/sprotty-protocol/lib/actions.js
  var require_actions = __commonJS({
    "node_modules/sprotty-protocol/lib/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReconnectAction = exports.ApplyLabelEditAction = exports.DeleteElementAction = exports.CreateElementAction = exports.HoverFeedbackAction = exports.MoveAction = exports.RedoAction = exports.UndoAction = exports.BringToFrontAction = exports.ViewportResult = exports.GetViewportAction = exports.SetViewportAction = exports.FitToScreenAction = exports.CenterAction = exports.LayoutAction = exports.OpenAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.SelectionResult = exports.GetSelectionAction = exports.SelectAllAction = exports.SelectAction = exports.LoggingAction = exports.ComputedBoundsAction = exports.RequestBoundsAction = exports.SetBoundsAction = exports.SetPopupModelAction = exports.RequestPopupModelAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = exports.RejectAction = exports.isResponseAction = exports.setRequestContext = exports.generateRequestId = exports.isRequestAction = exports.isAction = exports.isActionMessage = void 0;
      var object_1 = require_object();
      function isActionMessage(object) {
        return (0, object_1.hasOwnProperty)(object, "action");
      }
      exports.isActionMessage = isActionMessage;
      function isAction(object) {
        return (0, object_1.hasOwnProperty)(object, "kind", "string");
      }
      exports.isAction = isAction;
      function isRequestAction(object) {
        return (0, object_1.hasOwnProperty)(object, "requestId", "string");
      }
      exports.isRequestAction = isRequestAction;
      var requestContext = "";
      var nextRequestId = 1;
      function generateRequestId() {
        return `${requestContext}_${nextRequestId++}`;
      }
      exports.generateRequestId = generateRequestId;
      function setRequestContext(context) {
        requestContext = context;
      }
      exports.setRequestContext = setRequestContext;
      function isResponseAction(object) {
        return (0, object_1.hasOwnProperty)(object, "responseId", "string") && object.responseId !== "";
      }
      exports.isResponseAction = isResponseAction;
      var RejectAction;
      (function(RejectAction2) {
        RejectAction2.KIND = "rejectRequest";
        function create(options) {
          return {
            kind: RejectAction2.KIND,
            message: options.message,
            detail: options.detail,
            responseId: options.requestId
          };
        }
        RejectAction2.create = create;
      })(RejectAction || (exports.RejectAction = RejectAction = {}));
      var RequestModelAction2;
      (function(RequestModelAction3) {
        RequestModelAction3.KIND = "requestModel";
        function create(options) {
          return {
            kind: RequestModelAction3.KIND,
            options,
            requestId: generateRequestId()
          };
        }
        RequestModelAction3.create = create;
      })(RequestModelAction2 || (exports.RequestModelAction = RequestModelAction2 = {}));
      var SetModelAction;
      (function(SetModelAction2) {
        SetModelAction2.KIND = "setModel";
        function create(newRoot, requestId = "") {
          return {
            kind: SetModelAction2.KIND,
            newRoot,
            responseId: requestId
          };
        }
        SetModelAction2.create = create;
      })(SetModelAction || (exports.SetModelAction = SetModelAction = {}));
      var UpdateModelAction;
      (function(UpdateModelAction2) {
        UpdateModelAction2.KIND = "updateModel";
        function create(input, options = {}) {
          if (Array.isArray(input)) {
            return {
              kind: UpdateModelAction2.KIND,
              matches: input,
              animate: options.animate,
              cause: options.cause
            };
          } else {
            return {
              kind: UpdateModelAction2.KIND,
              newRoot: input,
              animate: options.animate,
              cause: options.cause
            };
          }
        }
        UpdateModelAction2.create = create;
      })(UpdateModelAction || (exports.UpdateModelAction = UpdateModelAction = {}));
      var RequestPopupModelAction;
      (function(RequestPopupModelAction2) {
        RequestPopupModelAction2.KIND = "requestPopupModel";
        function create(options) {
          return {
            kind: RequestPopupModelAction2.KIND,
            elementId: options.elementId,
            bounds: options.bounds,
            requestId: generateRequestId()
          };
        }
        RequestPopupModelAction2.create = create;
      })(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
      var SetPopupModelAction;
      (function(SetPopupModelAction2) {
        SetPopupModelAction2.KIND = "setPopupModel";
        function create(newRoot, requestId = "") {
          return {
            kind: SetPopupModelAction2.KIND,
            newRoot,
            responseId: requestId
          };
        }
        SetPopupModelAction2.create = create;
      })(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));
      var SetBoundsAction;
      (function(SetBoundsAction2) {
        SetBoundsAction2.KIND = "setBounds";
        function create(bounds) {
          return {
            kind: SetBoundsAction2.KIND,
            bounds
          };
        }
        SetBoundsAction2.create = create;
      })(SetBoundsAction || (exports.SetBoundsAction = SetBoundsAction = {}));
      var RequestBoundsAction;
      (function(RequestBoundsAction2) {
        RequestBoundsAction2.KIND = "requestBounds";
        function create(newRoot) {
          return {
            kind: RequestBoundsAction2.KIND,
            newRoot,
            requestId: generateRequestId()
          };
        }
        RequestBoundsAction2.create = create;
      })(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
      var ComputedBoundsAction;
      (function(ComputedBoundsAction2) {
        ComputedBoundsAction2.KIND = "computedBounds";
        function create(bounds, options = {}) {
          var _a;
          return {
            kind: ComputedBoundsAction2.KIND,
            bounds,
            revision: options.revision,
            alignments: options.alignments,
            responseId: (_a = options.requestId) !== null && _a !== void 0 ? _a : ""
          };
        }
        ComputedBoundsAction2.create = create;
      })(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
      var LoggingAction;
      (function(LoggingAction2) {
        LoggingAction2.KIND = "logging";
        function create(options) {
          return Object.assign({ kind: LoggingAction2.KIND }, options);
        }
        LoggingAction2.create = create;
      })(LoggingAction || (exports.LoggingAction = LoggingAction = {}));
      var SelectAction;
      (function(SelectAction2) {
        SelectAction2.KIND = "elementSelected";
        function create(options) {
          var _a, _b;
          return {
            kind: SelectAction2.KIND,
            selectedElementsIDs: (_a = options.selectedElementsIDs) !== null && _a !== void 0 ? _a : [],
            deselectedElementsIDs: (_b = options.deselectedElementsIDs) !== null && _b !== void 0 ? _b : []
          };
        }
        SelectAction2.create = create;
      })(SelectAction || (exports.SelectAction = SelectAction = {}));
      var SelectAllAction;
      (function(SelectAllAction2) {
        SelectAllAction2.KIND = "allSelected";
        function create(options = {}) {
          var _a;
          return {
            kind: SelectAllAction2.KIND,
            select: (_a = options.select) !== null && _a !== void 0 ? _a : true
          };
        }
        SelectAllAction2.create = create;
      })(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));
      var GetSelectionAction;
      (function(GetSelectionAction2) {
        GetSelectionAction2.KIND = "getSelection";
        function create() {
          return {
            kind: GetSelectionAction2.KIND,
            requestId: generateRequestId()
          };
        }
        GetSelectionAction2.create = create;
      })(GetSelectionAction || (exports.GetSelectionAction = GetSelectionAction = {}));
      var SelectionResult;
      (function(SelectionResult2) {
        SelectionResult2.KIND = "selectionResult";
        function create(selectedElementsIDs, requestId) {
          return {
            kind: SelectionResult2.KIND,
            selectedElementsIDs,
            responseId: requestId
          };
        }
        SelectionResult2.create = create;
      })(SelectionResult || (exports.SelectionResult = SelectionResult = {}));
      var CollapseExpandAction;
      (function(CollapseExpandAction2) {
        CollapseExpandAction2.KIND = "collapseExpand";
        function create(options) {
          var _a, _b;
          return {
            kind: CollapseExpandAction2.KIND,
            expandIds: (_a = options.expandIds) !== null && _a !== void 0 ? _a : [],
            collapseIds: (_b = options.collapseIds) !== null && _b !== void 0 ? _b : []
          };
        }
        CollapseExpandAction2.create = create;
      })(CollapseExpandAction || (exports.CollapseExpandAction = CollapseExpandAction = {}));
      var CollapseExpandAllAction;
      (function(CollapseExpandAllAction2) {
        CollapseExpandAllAction2.KIND = "collapseExpandAll";
        function create(options = {}) {
          var _a;
          return {
            kind: CollapseExpandAllAction2.KIND,
            expand: (_a = options.expand) !== null && _a !== void 0 ? _a : true
          };
        }
        CollapseExpandAllAction2.create = create;
      })(CollapseExpandAllAction || (exports.CollapseExpandAllAction = CollapseExpandAllAction = {}));
      var OpenAction;
      (function(OpenAction2) {
        OpenAction2.KIND = "open";
        function create(elementId) {
          return {
            kind: OpenAction2.KIND,
            elementId
          };
        }
        OpenAction2.create = create;
      })(OpenAction || (exports.OpenAction = OpenAction = {}));
      var LayoutAction;
      (function(LayoutAction2) {
        LayoutAction2.KIND = "layout";
        function create(options = {}) {
          return {
            kind: LayoutAction2.KIND,
            layoutType: options.layoutType,
            elementIds: options.elementIds
          };
        }
        LayoutAction2.create = create;
      })(LayoutAction || (exports.LayoutAction = LayoutAction = {}));
      var CenterAction;
      (function(CenterAction2) {
        CenterAction2.KIND = "center";
        function create(elementIds, options = {}) {
          var _a, _b;
          return {
            kind: CenterAction2.KIND,
            elementIds,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
            retainZoom: (_b = options.retainZoom) !== null && _b !== void 0 ? _b : false,
            zoomScale: options.zoomScale
          };
        }
        CenterAction2.create = create;
      })(CenterAction || (exports.CenterAction = CenterAction = {}));
      var FitToScreenAction;
      (function(FitToScreenAction2) {
        FitToScreenAction2.KIND = "fit";
        function create(elementIds, options = {}) {
          var _a;
          return {
            kind: FitToScreenAction2.KIND,
            elementIds,
            padding: options.padding,
            maxZoom: options.maxZoom,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
          };
        }
        FitToScreenAction2.create = create;
      })(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));
      var SetViewportAction;
      (function(SetViewportAction2) {
        SetViewportAction2.KIND = "viewport";
        function create(elementId, newViewport, options = {}) {
          var _a;
          return {
            kind: SetViewportAction2.KIND,
            elementId,
            newViewport,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
          };
        }
        SetViewportAction2.create = create;
      })(SetViewportAction || (exports.SetViewportAction = SetViewportAction = {}));
      var GetViewportAction;
      (function(GetViewportAction2) {
        GetViewportAction2.KIND = "getViewport";
        function create() {
          return {
            kind: GetViewportAction2.KIND,
            requestId: generateRequestId()
          };
        }
        GetViewportAction2.create = create;
      })(GetViewportAction || (exports.GetViewportAction = GetViewportAction = {}));
      var ViewportResult;
      (function(ViewportResult2) {
        ViewportResult2.KIND = "viewportResult";
        function create(viewport, canvasBounds, requestId) {
          return {
            kind: ViewportResult2.KIND,
            viewport,
            canvasBounds,
            responseId: requestId
          };
        }
        ViewportResult2.create = create;
      })(ViewportResult || (exports.ViewportResult = ViewportResult = {}));
      var BringToFrontAction;
      (function(BringToFrontAction2) {
        BringToFrontAction2.KIND = "bringToFront";
        function create(elementIDs) {
          return {
            kind: BringToFrontAction2.KIND,
            elementIDs
          };
        }
        BringToFrontAction2.create = create;
      })(BringToFrontAction || (exports.BringToFrontAction = BringToFrontAction = {}));
      var UndoAction;
      (function(UndoAction2) {
        UndoAction2.KIND = "undo";
        function create() {
          return {
            kind: UndoAction2.KIND
          };
        }
        UndoAction2.create = create;
      })(UndoAction || (exports.UndoAction = UndoAction = {}));
      var RedoAction;
      (function(RedoAction2) {
        RedoAction2.KIND = "redo";
        function create() {
          return {
            kind: RedoAction2.KIND
          };
        }
        RedoAction2.create = create;
      })(RedoAction || (exports.RedoAction = RedoAction = {}));
      var MoveAction2;
      (function(MoveAction3) {
        MoveAction3.KIND = "move";
        function create(moves, options = {}) {
          var _a, _b;
          return {
            kind: MoveAction3.KIND,
            moves,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
            finished: (_b = options.finished) !== null && _b !== void 0 ? _b : false
          };
        }
        MoveAction3.create = create;
      })(MoveAction2 || (exports.MoveAction = MoveAction2 = {}));
      var HoverFeedbackAction;
      (function(HoverFeedbackAction2) {
        HoverFeedbackAction2.KIND = "hoverFeedback";
        function create(options) {
          return {
            kind: HoverFeedbackAction2.KIND,
            mouseoverElement: options.mouseoverElement,
            mouseIsOver: options.mouseIsOver
          };
        }
        HoverFeedbackAction2.create = create;
      })(HoverFeedbackAction || (exports.HoverFeedbackAction = HoverFeedbackAction = {}));
      var CreateElementAction;
      (function(CreateElementAction2) {
        CreateElementAction2.KIND = "createElement";
        function create(elementSchema, options) {
          return {
            kind: CreateElementAction2.KIND,
            elementSchema,
            containerId: options.containerId
          };
        }
        CreateElementAction2.create = create;
      })(CreateElementAction || (exports.CreateElementAction = CreateElementAction = {}));
      var DeleteElementAction;
      (function(DeleteElementAction2) {
        DeleteElementAction2.KIND = "delete";
        function create(elementIds) {
          return {
            kind: DeleteElementAction2.KIND,
            elementIds
          };
        }
        DeleteElementAction2.create = create;
      })(DeleteElementAction || (exports.DeleteElementAction = DeleteElementAction = {}));
      var ApplyLabelEditAction;
      (function(ApplyLabelEditAction2) {
        ApplyLabelEditAction2.KIND = "applyLabelEdit";
        function create(labelId, text) {
          return {
            kind: ApplyLabelEditAction2.KIND,
            labelId,
            text
          };
        }
        ApplyLabelEditAction2.create = create;
      })(ApplyLabelEditAction || (exports.ApplyLabelEditAction = ApplyLabelEditAction = {}));
      var ReconnectAction;
      (function(ReconnectAction2) {
        ReconnectAction2.KIND = "reconnect";
        function create(options) {
          return {
            kind: ReconnectAction2.KIND,
            routableId: options.routableId,
            newSourceId: options.newSourceId,
            newTargetId: options.newTargetId
          };
        }
        ReconnectAction2.create = create;
      })(ReconnectAction || (exports.ReconnectAction = ReconnectAction = {}));
    }
  });

  // node_modules/sprotty-protocol/lib/utils/async.js
  var require_async2 = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Deferred = void 0;
      var Deferred = class {
        constructor() {
          this._state = "unresolved";
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
          this.promise.then((res) => this._state = "resolved", (rej) => this._state = "rejected");
        }
        set state(state) {
          if (this._state === "unresolved") {
            this._state = state;
          }
        }
        get state() {
          return this._state;
        }
      };
      exports.Deferred = Deferred;
    }
  });

  // node_modules/sprotty/lib/base/types.js
  var require_types = __commonJS({
    "node_modules/sprotty/lib/base/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TYPES = void 0;
      exports.TYPES = {
        Action: Symbol("Action"),
        IActionDispatcher: Symbol("IActionDispatcher"),
        IActionDispatcherProvider: Symbol("IActionDispatcherProvider"),
        IActionHandlerInitializer: Symbol("IActionHandlerInitializer"),
        ActionHandlerRegistration: Symbol("ActionHandlerRegistration"),
        ActionHandlerRegistryProvider: Symbol("ActionHandlerRegistryProvider"),
        IAnchorComputer: Symbol("IAnchor"),
        AnimationFrameSyncer: Symbol("AnimationFrameSyncer"),
        IButtonHandlerRegistration: Symbol("IButtonHandlerRegistration"),
        ICommandPaletteActionProvider: Symbol("ICommandPaletteActionProvider"),
        ICommandPaletteActionProviderRegistry: Symbol("ICommandPaletteActionProviderRegistry"),
        CommandRegistration: Symbol("CommandRegistration"),
        ICommandStack: Symbol("ICommandStack"),
        CommandStackOptions: Symbol("CommandStackOptions"),
        ICommandStackProvider: Symbol("ICommandStackProvider"),
        IContextMenuItemProvider: Symbol.for("IContextMenuProvider"),
        IContextMenuProviderRegistry: Symbol.for("IContextMenuProviderRegistry"),
        IContextMenuService: Symbol.for("IContextMenuService"),
        IContextMenuServiceProvider: Symbol.for("IContextMenuServiceProvider"),
        DOMHelper: Symbol("DOMHelper"),
        IDiagramLocker: Symbol("IDiagramLocker"),
        IEdgeRouter: Symbol("IEdgeRouter"),
        IEdgeRoutePostprocessor: Symbol("IEdgeRoutePostprocessor"),
        IEditLabelValidationDecorator: Symbol("IEditLabelValidationDecorator"),
        IEditLabelValidator: Symbol("IEditLabelValidator"),
        HiddenModelViewer: Symbol("HiddenModelViewer"),
        HiddenVNodePostprocessor: Symbol("HiddenVNodeDecorator"),
        HoverState: Symbol("HoverState"),
        KeyListener: Symbol("KeyListener"),
        LayoutRegistration: Symbol("LayoutRegistration"),
        LayoutRegistry: Symbol("LayoutRegistry"),
        Layouter: Symbol("Layouter"),
        LogLevel: Symbol("LogLevel"),
        ILogger: Symbol("ILogger"),
        IModelFactory: Symbol("IModelFactory"),
        IModelLayoutEngine: Symbol("IModelLayoutEngine"),
        ModelRendererFactory: Symbol("ModelRendererFactory"),
        ModelSource: Symbol("ModelSource"),
        ModelSourceProvider: Symbol("ModelSourceProvider"),
        ModelViewer: Symbol("ModelViewer"),
        MouseListener: Symbol("MouseListener"),
        PatcherProvider: Symbol("PatcherProvider"),
        IPopupModelProvider: Symbol("IPopupModelProvider"),
        PopupModelViewer: Symbol("PopupModelViewer"),
        PopupMouseListener: Symbol("PopupMouseListener"),
        PopupVNodePostprocessor: Symbol("PopupVNodeDecorator"),
        SModelElementRegistration: Symbol("SModelElementRegistration"),
        SModelRegistry: Symbol("SModelRegistry"),
        ISnapper: Symbol("ISnapper"),
        SvgExporter: Symbol("SvgExporter"),
        IUIExtension: Symbol("IUIExtension"),
        UIExtensionRegistry: Symbol("UIExtensionRegistry"),
        IVNodePostprocessor: Symbol("IVNodePostprocessor"),
        ViewRegistration: Symbol("ViewRegistration"),
        ViewRegistry: Symbol("ViewRegistry"),
        IViewer: Symbol("IViewer"),
        ViewerOptions: Symbol("ViewerOptions"),
        IViewerProvider: Symbol("IViewerProvider")
      };
    }
  });

  // node_modules/sprotty/lib/utils/registry.js
  var require_registry = __commonJS({
    "node_modules/sprotty/lib/utils/registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultiInstanceRegistry = exports.InstanceRegistry = exports.FactoryRegistry = exports.ProviderRegistry = void 0;
      var inversify_1 = require_inversify();
      var ProviderRegistry = class ProviderRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, cstr) {
          if (key === void 0)
            throw new Error("Key is undefined");
          if (this.hasKey(key))
            throw new Error("Key is already registered: " + key);
          this.elements.set(key, cstr);
        }
        deregister(key) {
          if (key === void 0)
            throw new Error("Key is undefined");
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key, arg) {
          const existingCstr = this.elements.get(key);
          if (existingCstr)
            return new existingCstr(arg);
          else
            return this.missing(key, arg);
        }
        missing(key, arg) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.ProviderRegistry = ProviderRegistry;
      exports.ProviderRegistry = ProviderRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], ProviderRegistry);
      var FactoryRegistry = class FactoryRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, factory) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            throw new Error("Key is already registered: " + key);
          }
          this.elements.set(key, factory);
        }
        deregister(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key, arg) {
          const existingFactory = this.elements.get(key);
          if (existingFactory) {
            return existingFactory(arg);
          } else {
            return this.missing(key, arg);
          }
        }
        missing(key, arg) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.FactoryRegistry = FactoryRegistry;
      exports.FactoryRegistry = FactoryRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], FactoryRegistry);
      var InstanceRegistry = class InstanceRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            throw new Error("Key is already registered: " + key);
          }
          this.elements.set(key, instance);
        }
        deregister(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key) {
          const existingInstance = this.elements.get(key);
          if (existingInstance) {
            return existingInstance;
          } else {
            return this.missing(key);
          }
        }
        missing(key) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.InstanceRegistry = InstanceRegistry;
      exports.InstanceRegistry = InstanceRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], InstanceRegistry);
      var MultiInstanceRegistry = class MultiInstanceRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          const instances = this.elements.get(key);
          if (instances !== void 0) {
            instances.push(instance);
          } else {
            this.elements.set(key, [instance]);
          }
        }
        deregisterAll(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        get(key) {
          const existingInstances = this.elements.get(key);
          if (existingInstances !== void 0) {
            return existingInstances;
          } else {
            return [];
          }
        }
      };
      exports.MultiInstanceRegistry = MultiInstanceRegistry;
      exports.MultiInstanceRegistry = MultiInstanceRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], MultiInstanceRegistry);
    }
  });

  // node_modules/sprotty-protocol/lib/utils/geometry.js
  var require_geometry = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/geometry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.almostEquals = exports.toRadians = exports.toDegrees = exports.Bounds = exports.isBounds = exports.Dimension = exports.centerOfLine = exports.angleBetweenPoints = exports.angleOfPoint = exports.Point = void 0;
      var object_1 = require_object();
      var Point5;
      (function(Point6) {
        Point6.ORIGIN = Object.freeze({
          x: 0,
          y: 0
        });
        function add(p1, p2) {
          return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
          };
        }
        Point6.add = add;
        function subtract(p1, p2) {
          return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
          };
        }
        Point6.subtract = subtract;
        function equals(point1, point2) {
          return point1.x === point2.x && point1.y === point2.y;
        }
        Point6.equals = equals;
        function shiftTowards(point, refPoint, distance) {
          const diff = subtract(refPoint, point);
          const normalized = normalize(diff);
          const shift = { x: normalized.x * distance, y: normalized.y * distance };
          return add(point, shift);
        }
        Point6.shiftTowards = shiftTowards;
        function normalize(point) {
          const mag = magnitude(point);
          if (mag === 0 || mag === 1) {
            return Point6.ORIGIN;
          }
          return {
            x: point.x / mag,
            y: point.y / mag
          };
        }
        Point6.normalize = normalize;
        function magnitude(point) {
          return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }
        Point6.magnitude = magnitude;
        function linear(p0, p1, lambda) {
          return {
            x: (1 - lambda) * p0.x + lambda * p1.x,
            y: (1 - lambda) * p0.y + lambda * p1.y
          };
        }
        Point6.linear = linear;
        function euclideanDistance(a, b) {
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          return Math.sqrt(dx * dx + dy * dy);
        }
        Point6.euclideanDistance = euclideanDistance;
        function manhattanDistance(a, b) {
          return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);
        }
        Point6.manhattanDistance = manhattanDistance;
        function maxDistance(a, b) {
          return Math.max(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
        }
        Point6.maxDistance = maxDistance;
      })(Point5 || (exports.Point = Point5 = {}));
      function angleOfPoint2(p) {
        return Math.atan2(p.y, p.x);
      }
      exports.angleOfPoint = angleOfPoint2;
      function angleBetweenPoints(a, b) {
        const lengthProduct = Math.sqrt((a.x * a.x + a.y * a.y) * (b.x * b.x + b.y * b.y));
        if (isNaN(lengthProduct) || lengthProduct === 0)
          return NaN;
        const dotProduct = a.x * b.x + a.y * b.y;
        return Math.acos(dotProduct / lengthProduct);
      }
      exports.angleBetweenPoints = angleBetweenPoints;
      function centerOfLine(s, e) {
        const b = {
          x: s.x > e.x ? e.x : s.x,
          y: s.y > e.y ? e.y : s.y,
          width: Math.abs(e.x - s.x),
          height: Math.abs(e.y - s.y)
        };
        return Bounds2.center(b);
      }
      exports.centerOfLine = centerOfLine;
      var Dimension;
      (function(Dimension2) {
        Dimension2.EMPTY = Object.freeze({
          width: -1,
          height: -1
        });
        function isValid(d) {
          return d.width >= 0 && d.height >= 0;
        }
        Dimension2.isValid = isValid;
      })(Dimension || (exports.Dimension = Dimension = {}));
      function isBounds(element) {
        return (0, object_1.hasOwnProperty)(element, ["x", "y", "width", "height"]);
      }
      exports.isBounds = isBounds;
      var Bounds2;
      (function(Bounds3) {
        Bounds3.EMPTY = Object.freeze({
          x: 0,
          y: 0,
          width: -1,
          height: -1
        });
        function combine(b0, b1) {
          if (!Dimension.isValid(b0))
            return Dimension.isValid(b1) ? b1 : Bounds3.EMPTY;
          if (!Dimension.isValid(b1))
            return b0;
          const minX = Math.min(b0.x, b1.x);
          const minY = Math.min(b0.y, b1.y);
          const maxX = Math.max(b0.x + (b0.width >= 0 ? b0.width : 0), b1.x + (b1.width >= 0 ? b1.width : 0));
          const maxY = Math.max(b0.y + (b0.height >= 0 ? b0.height : 0), b1.y + (b1.height >= 0 ? b1.height : 0));
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        }
        Bounds3.combine = combine;
        function translate(b, p) {
          return {
            x: b.x + p.x,
            y: b.y + p.y,
            width: b.width,
            height: b.height
          };
        }
        Bounds3.translate = translate;
        function center(b) {
          return {
            x: b.x + (b.width >= 0 ? 0.5 * b.width : 0),
            y: b.y + (b.height >= 0 ? 0.5 * b.height : 0)
          };
        }
        Bounds3.center = center;
        function includes(b, p) {
          return p.x >= b.x && p.x <= b.x + b.width && p.y >= b.y && p.y <= b.y + b.height;
        }
        Bounds3.includes = includes;
      })(Bounds2 || (exports.Bounds = Bounds2 = {}));
      function toDegrees2(a) {
        return a * 180 / Math.PI;
      }
      exports.toDegrees = toDegrees2;
      function toRadians(a) {
        return a * Math.PI / 180;
      }
      exports.toRadians = toRadians;
      function almostEquals(a, b) {
        return Math.abs(a - b) < 1e-3;
      }
      exports.almostEquals = almostEquals;
    }
  });

  // node_modules/sprotty/lib/utils/iterable.js
  var require_iterable = __commonJS({
    "node_modules/sprotty/lib/utils/iterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapIterable = exports.filterIterable = exports.DONE_RESULT = exports.toArray = exports.FluentIterableImpl = void 0;
      var FluentIterableImpl = class {
        constructor(startFn, nextFn) {
          this.startFn = startFn;
          this.nextFn = nextFn;
        }
        [Symbol.iterator]() {
          const iterator = {
            state: this.startFn(),
            next: () => this.nextFn(iterator.state),
            [Symbol.iterator]: () => iterator
          };
          return iterator;
        }
        filter(callback) {
          return filterIterable(this, callback);
        }
        map(callback) {
          return mapIterable(this, callback);
        }
        forEach(callback) {
          const iterator = this[Symbol.iterator]();
          let index = 0;
          let result;
          do {
            result = iterator.next();
            if (result.value !== void 0)
              callback(result.value, index);
            index++;
          } while (!result.done);
        }
        indexOf(element) {
          const iterator = this[Symbol.iterator]();
          let index = 0;
          let result;
          do {
            result = iterator.next();
            if (result.value === element)
              return index;
            index++;
          } while (!result.done);
          return -1;
        }
      };
      exports.FluentIterableImpl = FluentIterableImpl;
      function toArray(input) {
        if (input.constructor === Array) {
          return input;
        }
        const result = [];
        input.forEach((element) => result.push(element));
        return result;
      }
      exports.toArray = toArray;
      exports.DONE_RESULT = Object.freeze({ done: true, value: void 0 });
      function filterIterable(input, callback) {
        return new FluentIterableImpl(() => createIterator(input), (iterator) => {
          let result;
          do {
            result = iterator.next();
          } while (!result.done && !callback(result.value));
          return result;
        });
      }
      exports.filterIterable = filterIterable;
      function mapIterable(input, callback) {
        return new FluentIterableImpl(() => createIterator(input), (iterator) => {
          const { done, value } = iterator.next();
          if (done)
            return exports.DONE_RESULT;
          else
            return { done: false, value: callback(value) };
        });
      }
      exports.mapIterable = mapIterable;
      function createIterator(collection) {
        const method = collection[Symbol.iterator];
        if (typeof method === "function") {
          return method.call(collection);
        }
        const length = collection.length;
        if (typeof length === "number" && length >= 0) {
          return new ArrayIterator(collection);
        }
        return { next: () => exports.DONE_RESULT };
      }
      var ArrayIterator = class {
        constructor(array) {
          this.array = array;
          this.index = 0;
        }
        next() {
          if (this.index < this.array.length)
            return { done: false, value: this.array[this.index++] };
          else
            return exports.DONE_RESULT;
        }
        [Symbol.iterator]() {
          return this;
        }
      };
    }
  });

  // node_modules/sprotty/lib/base/model/smodel.js
  var require_smodel = __commonJS({
    "node_modules/sprotty/lib/base/model/smodel.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModelIndexImpl = exports.createRandomId = exports.SModelRootImpl = exports.SChildElementImpl = exports.SParentElementImpl = exports.isParent = exports.SModelElementImpl = void 0;
      var geometry_1 = require_geometry();
      var iterable_1 = require_iterable();
      var SModelElementImpl3 = class {
        get root() {
          let current = this;
          while (current) {
            if (current instanceof SModelRootImpl2)
              return current;
            else if (current instanceof SChildElementImpl)
              current = current.parent;
            else
              current = void 0;
          }
          throw new Error("Element has no root");
        }
        get index() {
          return this.root.index;
        }
        /**
         * A feature is a symbol identifying some functionality that can be enabled or disabled for
         * a model element. The set of supported features is determined by the `features` property.
         */
        hasFeature(feature) {
          return this.features !== void 0 && this.features.has(feature);
        }
      };
      exports.SModelElementImpl = SModelElementImpl3;
      function isParent(element) {
        const children = element.children;
        return children !== void 0 && children.constructor === Array;
      }
      exports.isParent = isParent;
      var SParentElementImpl = class extends SModelElementImpl3 {
        constructor() {
          super(...arguments);
          this.children = [];
        }
        add(child, index) {
          const children = this.children;
          if (index === void 0) {
            children.push(child);
          } else {
            if (index < 0 || index > this.children.length) {
              throw new Error(`Child index ${index} out of bounds (0..${children.length})`);
            }
            children.splice(index, 0, child);
          }
          child.parent = this;
          this.index.add(child);
        }
        remove(child) {
          const children = this.children;
          const i = children.indexOf(child);
          if (i < 0) {
            throw new Error(`No such child ${child.id}`);
          }
          children.splice(i, 1);
          this.index.remove(child);
        }
        removeAll(filter) {
          const children = this.children;
          if (filter !== void 0) {
            for (let i = children.length - 1; i >= 0; i--) {
              if (filter(children[i])) {
                const child = children.splice(i, 1)[0];
                this.index.remove(child);
              }
            }
          } else {
            children.forEach((child) => {
              this.index.remove(child);
            });
            children.splice(0, children.length);
          }
        }
        move(child, newIndex) {
          const children = this.children;
          const i = children.indexOf(child);
          if (i === -1) {
            throw new Error(`No such child ${child.id}`);
          } else {
            if (newIndex < 0 || newIndex > children.length - 1) {
              throw new Error(`Child index ${newIndex} out of bounds (0..${children.length})`);
            }
            children.splice(i, 1);
            children.splice(newIndex, 0, child);
          }
        }
        /**
         * Transform the given bounds from the local coordinate system of this element to the coordinate
         * system of its parent. This function should consider any transformation that is applied to the
         * view of this element and its contents.
         * The base implementation assumes that this element does not define a local coordinate system,
         * so it leaves the bounds unchanged.
         */
        localToParent(point) {
          return (0, geometry_1.isBounds)(point) ? point : { x: point.x, y: point.y, width: -1, height: -1 };
        }
        /**
         * Transform the given bounds from the coordinate system of this element's parent to its local
         * coordinate system. This function should consider any transformation that is applied to the
         * view of this element and its contents.
         * The base implementation assumes that this element does not define a local coordinate system,
         * so it leaves the bounds unchanged.
         */
        parentToLocal(point) {
          return (0, geometry_1.isBounds)(point) ? point : { x: point.x, y: point.y, width: -1, height: -1 };
        }
      };
      exports.SParentElementImpl = SParentElementImpl;
      var SChildElementImpl = class extends SParentElementImpl {
      };
      exports.SChildElementImpl = SChildElementImpl;
      var SModelRootImpl2 = class extends SParentElementImpl {
        constructor(index = new ModelIndexImpl()) {
          super();
          this.canvasBounds = geometry_1.Bounds.EMPTY;
          Object.defineProperty(this, "index", {
            value: index,
            writable: false
          });
        }
      };
      exports.SModelRootImpl = SModelRootImpl2;
      var ID_CHARS = "0123456789abcdefghijklmnopqrstuvwxyz";
      function createRandomId4(length = 8) {
        let id = "";
        for (let i = 0; i < length; i++) {
          id += ID_CHARS.charAt(Math.floor(Math.random() * ID_CHARS.length));
        }
        return id;
      }
      exports.createRandomId = createRandomId4;
      var ModelIndexImpl = class {
        constructor() {
          this.id2element = /* @__PURE__ */ new Map();
        }
        add(element) {
          if (!element.id) {
            do {
              element.id = createRandomId4();
            } while (this.contains(element));
          } else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
          }
          this.id2element.set(element.id, element);
          if (element instanceof SParentElementImpl) {
            for (const child of element.children) {
              this.add(child);
            }
          }
        }
        remove(element) {
          this.id2element.delete(element.id);
          if (element instanceof SParentElementImpl) {
            for (const child of element.children) {
              this.remove(child);
            }
          }
        }
        contains(element) {
          return this.id2element.has(element.id);
        }
        getById(id) {
          return this.id2element.get(id);
        }
        getAttachedElements(element) {
          return [];
        }
        all() {
          return (0, iterable_1.mapIterable)(this.id2element, ([key, value]) => value);
        }
      };
      exports.ModelIndexImpl = ModelIndexImpl;
    }
  });

  // node_modules/sprotty/lib/base/model/smodel-factory.js
  var require_smodel_factory = __commonJS({
    "node_modules/sprotty/lib/base/model/smodel-factory.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createFeatureSet = exports.EMPTY_ROOT = exports.SModelFactory = exports.SModelRegistry = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var smodel_1 = require_smodel();
      var SModelRegistry = class SModelRegistry extends registry_1.FactoryRegistry {
        constructor(registrations) {
          super();
          registrations.forEach((registration) => {
            let defaultFeatures = this.getDefaultFeatures(registration.constr);
            if (!defaultFeatures && registration.features && registration.features.enable)
              defaultFeatures = [];
            if (defaultFeatures) {
              const featureSet = createFeatureSet(defaultFeatures, registration.features);
              this.register(registration.type, () => {
                const element = new registration.constr();
                element.features = featureSet;
                return element;
              });
            } else {
              this.register(registration.type, () => new registration.constr());
            }
          });
        }
        getDefaultFeatures(constr) {
          let obj = constr;
          do {
            const defaultFeatures = obj.DEFAULT_FEATURES;
            if (defaultFeatures)
              return defaultFeatures;
            obj = Object.getPrototypeOf(obj);
          } while (obj);
          return void 0;
        }
      };
      exports.SModelRegistry = SModelRegistry;
      exports.SModelRegistry = SModelRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.SModelElementRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], SModelRegistry);
      var SModelFactory = class SModelFactory {
        createElement(schema, parent) {
          let child;
          if (this.registry.hasKey(schema.type)) {
            const regElement = this.registry.get(schema.type, void 0);
            if (!(regElement instanceof smodel_1.SChildElementImpl))
              throw new Error(`Element with type ${schema.type} was expected to be an SChildElement.`);
            child = regElement;
          } else {
            child = new smodel_1.SChildElementImpl();
          }
          return this.initializeChild(child, schema, parent);
        }
        createRoot(schema) {
          let root;
          if (this.registry.hasKey(schema.type)) {
            const regElement = this.registry.get(schema.type, void 0);
            if (!(regElement instanceof smodel_1.SModelRootImpl))
              throw new Error(`Element with type ${schema.type} was expected to be an SModelRoot.`);
            root = regElement;
          } else {
            root = new smodel_1.SModelRootImpl();
          }
          return this.initializeRoot(root, schema);
        }
        createSchema(element) {
          const schema = {};
          for (const key in element) {
            if (!this.isReserved(element, key)) {
              const value = element[key];
              if (typeof value !== "function")
                schema[key] = value;
            }
          }
          if (element instanceof smodel_1.SParentElementImpl)
            schema["children"] = element.children.map((child) => this.createSchema(child));
          return schema;
        }
        initializeElement(element, schema) {
          for (const key in schema) {
            if (!this.isReserved(element, key)) {
              const value = schema[key];
              if (typeof value !== "function")
                element[key] = value;
            }
          }
          return element;
        }
        isReserved(element, propertyName) {
          if (["children", "parent", "index"].indexOf(propertyName) >= 0)
            return true;
          let obj = element;
          do {
            const descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
            if (descriptor !== void 0)
              return descriptor.get !== void 0;
            obj = Object.getPrototypeOf(obj);
          } while (obj);
          return false;
        }
        initializeParent(parent, schema) {
          this.initializeElement(parent, schema);
          if ((0, smodel_1.isParent)(schema)) {
            parent.children = schema.children.map((childSchema) => this.createElement(childSchema, parent));
          }
          return parent;
        }
        initializeChild(child, schema, parent) {
          this.initializeParent(child, schema);
          if (parent !== void 0) {
            child.parent = parent;
          }
          return child;
        }
        initializeRoot(root, schema) {
          this.initializeParent(root, schema);
          root.index.add(root);
          return root;
        }
      };
      exports.SModelFactory = SModelFactory;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.SModelRegistry),
        __metadata("design:type", SModelRegistry)
      ], SModelFactory.prototype, "registry", void 0);
      exports.SModelFactory = SModelFactory = __decorate([
        (0, inversify_1.injectable)()
      ], SModelFactory);
      exports.EMPTY_ROOT = Object.freeze({
        type: "NONE",
        id: "EMPTY"
      });
      function createFeatureSet(defaults, custom) {
        const featureSet = new Set(defaults);
        if (custom && custom.enable) {
          for (const f of custom.enable) {
            featureSet.add(f);
          }
        }
        if (custom && custom.disable) {
          for (const f of custom.disable) {
            featureSet.delete(f);
          }
        }
        return featureSet;
      }
      exports.createFeatureSet = createFeatureSet;
    }
  });

  // node_modules/sprotty/lib/base/animations/animation-frame-syncer.js
  var require_animation_frame_syncer = __commonJS({
    "node_modules/sprotty/lib/base/animations/animation-frame-syncer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnimationFrameSyncer = void 0;
      var inversify_1 = require_inversify();
      var AnimationFrameSyncer = class AnimationFrameSyncer {
        constructor() {
          this.tasks = [];
          this.endTasks = [];
          this.triggered = false;
        }
        isAvailable() {
          return typeof requestAnimationFrame === "function";
        }
        onNextFrame(task) {
          this.tasks.push(task);
          this.trigger();
        }
        onEndOfNextFrame(task) {
          this.endTasks.push(task);
          this.trigger();
        }
        trigger() {
          if (!this.triggered) {
            this.triggered = true;
            if (this.isAvailable())
              requestAnimationFrame((time) => this.run(time));
            else
              setTimeout((time) => this.run(time));
          }
        }
        run(time) {
          const tasks = this.tasks;
          const endTasks = this.endTasks;
          this.triggered = false;
          this.tasks = [];
          this.endTasks = [];
          tasks.forEach((task) => task.call(void 0, time));
          endTasks.forEach((task) => task.call(void 0, time));
        }
      };
      exports.AnimationFrameSyncer = AnimationFrameSyncer;
      exports.AnimationFrameSyncer = AnimationFrameSyncer = __decorate([
        (0, inversify_1.injectable)()
      ], AnimationFrameSyncer);
    }
  });

  // node_modules/sprotty/lib/base/actions/action-dispatcher.js
  var require_action_dispatcher = __commonJS({
    "node_modules/sprotty/lib/base/actions/action-dispatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ActionDispatcher = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var async_1 = require_async2();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      (0, actions_1.setRequestContext)("client");
      var ActionDispatcher = class ActionDispatcher {
        constructor() {
          this.postponedActions = [];
          this.requests = /* @__PURE__ */ new Map();
        }
        initialize() {
          if (!this.initialized) {
            this.initialized = this.actionHandlerRegistryProvider().then((registry) => {
              this.actionHandlerRegistry = registry;
              this.handleAction(actions_1.SetModelAction.create(smodel_factory_1.EMPTY_ROOT)).catch(() => {
              });
            });
          }
          return this.initialized;
        }
        /**
         * Dispatch an action by querying all handlers that are registered for its kind.
         * The returned promise is resolved when all handler results (commands or actions)
         * have been processed.
         */
        dispatch(action) {
          return this.initialize().then(() => {
            if (this.blockUntil !== void 0) {
              return this.handleBlocked(action, this.blockUntil);
            } else if (this.diagramLocker.isAllowed(action)) {
              return this.handleAction(action);
            }
            return void 0;
          });
        }
        /**
         * Calls `dispatch` on every action in the given array. The returned promise
         * is resolved when the promises of all `dispatch` calls have been resolved.
         */
        dispatchAll(actions) {
          return Promise.all(actions.map((action) => this.dispatch(action)));
        }
        /**
         * Dispatch a request. The returned promise is resolved when a response with matching
         * identifier is dispatched. That response is _not_ passed to the registered action
         * handlers. Instead, it is the responsibility of the caller of this method to handle
         * the response properly. For example, it can be sent to the registered handlers by
         * passing it again to the `dispatch` method.
         */
        request(action) {
          if (!action.requestId) {
            return Promise.reject(new Error("Request without requestId"));
          }
          const deferred = new async_1.Deferred();
          this.requests.set(action.requestId, deferred);
          this.dispatch(action).catch(() => {
          });
          return deferred.promise;
        }
        handleAction(action) {
          if (action.kind === actions_1.UndoAction.KIND) {
            return this.commandStack.undo().then(() => {
            });
          }
          if (action.kind === actions_1.RedoAction.KIND) {
            return this.commandStack.redo().then(() => {
            });
          }
          if ((0, actions_1.isResponseAction)(action)) {
            const deferred = this.requests.get(action.responseId);
            if (deferred !== void 0) {
              this.requests.delete(action.responseId);
              if (action.kind === actions_1.RejectAction.KIND) {
                const rejectAction = action;
                deferred.reject(new Error(rejectAction.message));
                this.logger.warn(this, `Request with id ${action.responseId} failed.`, rejectAction.message, rejectAction.detail);
              } else {
                deferred.resolve(action);
              }
              return Promise.resolve();
            }
            this.logger.log(this, "No matching request for response", action);
          }
          const handlers = this.actionHandlerRegistry.get(action.kind);
          if (handlers.length === 0) {
            this.logger.warn(this, "Missing handler for action", action);
            const error = new Error(`Missing handler for action '${action.kind}'`);
            if ((0, actions_1.isRequestAction)(action)) {
              const deferred = this.requests.get(action.requestId);
              if (deferred !== void 0) {
                this.requests.delete(action.requestId);
                deferred.reject(error);
              }
            }
            return Promise.reject(error);
          }
          this.logger.log(this, "Handle", action);
          const promises = [];
          for (const handler of handlers) {
            const result = handler.handle(action);
            if ((0, actions_1.isAction)(result)) {
              promises.push(this.dispatch(result));
            } else if (result !== void 0) {
              promises.push(this.commandStack.execute(result));
              this.blockUntil = result.blockUntil;
            }
          }
          return Promise.all(promises);
        }
        handleBlocked(action, predicate) {
          if (predicate(action)) {
            this.blockUntil = void 0;
            const result = this.handleAction(action);
            const actions = this.postponedActions;
            this.postponedActions = [];
            for (const a of actions) {
              this.dispatch(a.action).then(a.resolve, a.reject);
            }
            return result;
          } else {
            this.logger.log(this, "Action is postponed due to block condition", action);
            return new Promise((resolve, reject) => {
              this.postponedActions.push({ action, resolve, reject });
            });
          }
        }
      };
      exports.ActionDispatcher = ActionDispatcher;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ActionHandlerRegistryProvider),
        __metadata("design:type", Function)
      ], ActionDispatcher.prototype, "actionHandlerRegistryProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ICommandStack),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "commandStack", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], ActionDispatcher.prototype, "syncer", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IDiagramLocker),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "diagramLocker", void 0);
      exports.ActionDispatcher = ActionDispatcher = __decorate([
        (0, inversify_1.injectable)()
      ], ActionDispatcher);
    }
  });

  // node_modules/sprotty/lib/utils/inversify.js
  var require_inversify2 = __commonJS({
    "node_modules/sprotty/lib/utils/inversify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isInjectable = void 0;
      function isInjectable(constr) {
        return Reflect.getMetadata("inversify:paramtypes", constr) !== void 0;
      }
      exports.isInjectable = isInjectable;
    }
  });

  // node_modules/sprotty/lib/base/actions/action-handler.js
  var require_action_handler = __commonJS({
    "node_modules/sprotty/lib/base/actions/action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onAction = exports.configureActionHandler = exports.ActionHandlerRegistry = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var inversify_2 = require_inversify2();
      var ActionHandlerRegistry2 = class ActionHandlerRegistry extends registry_1.MultiInstanceRegistry {
        constructor(registrations, initializers) {
          super();
          registrations.forEach((registration) => this.register(registration.actionKind, registration.factory()));
          initializers.forEach((initializer) => this.initializeActionHandler(initializer));
        }
        initializeActionHandler(initializer) {
          initializer.initialize(this);
        }
      };
      exports.ActionHandlerRegistry = ActionHandlerRegistry2;
      exports.ActionHandlerRegistry = ActionHandlerRegistry2 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ActionHandlerRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __param(1, (0, inversify_1.multiInject)(types_1.TYPES.IActionHandlerInitializer)),
        __param(1, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array, Array])
      ], ActionHandlerRegistry2);
      function configureActionHandler(context, kind, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Action handlers should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.ActionHandlerRegistration).toDynamicValue((ctx) => ({
          actionKind: kind,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureActionHandler = configureActionHandler;
      function onAction(context, kind, handle) {
        context.bind(types_1.TYPES.ActionHandlerRegistration).toConstantValue({
          actionKind: kind,
          factory: () => ({ handle })
        });
      }
      exports.onAction = onAction;
    }
  });

  // node_modules/sprotty/lib/base/actions/diagram-locker.js
  var require_diagram_locker = __commonJS({
    "node_modules/sprotty/lib/base/actions/diagram-locker.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultDiagramLocker = void 0;
      var inversify_1 = require_inversify();
      var DefaultDiagramLocker = class DefaultDiagramLocker {
        isAllowed(action) {
          return true;
        }
      };
      exports.DefaultDiagramLocker = DefaultDiagramLocker;
      exports.DefaultDiagramLocker = DefaultDiagramLocker = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultDiagramLocker);
    }
  });

  // node_modules/sprotty/lib/base/animations/easing.js
  var require_easing = __commonJS({
    "node_modules/sprotty/lib/base/animations/easing.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.easeInOut = void 0;
      function easeInOut(x) {
        if (x < 0.5)
          return x * x * 2;
        else
          return 1 - (1 - x) * (1 - x) * 2;
      }
      exports.easeInOut = easeInOut;
    }
  });

  // node_modules/sprotty/lib/base/animations/animation.js
  var require_animation = __commonJS({
    "node_modules/sprotty/lib/base/animations/animation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompoundAnimation = exports.Animation = void 0;
      var easing_1 = require_easing();
      var Animation = class {
        constructor(context, ease = easing_1.easeInOut) {
          this.context = context;
          this.ease = ease;
        }
        start() {
          return new Promise((resolve, reject) => {
            let start = void 0;
            let frames = 0;
            const lambda = (time) => {
              frames++;
              let dtime;
              if (start === void 0) {
                start = time;
                dtime = 0;
              } else {
                dtime = time - start;
              }
              const t = Math.min(1, dtime / this.context.duration);
              const current = this.tween(this.ease(t), this.context);
              this.context.modelChanged.update(current);
              if (t === 1) {
                this.context.logger.log(this, frames * 1e3 / this.context.duration + " fps");
                resolve(current);
              } else {
                this.context.syncer.onNextFrame(lambda);
              }
            };
            if (this.context.syncer.isAvailable()) {
              this.context.syncer.onNextFrame(lambda);
            } else {
              const finalModel = this.tween(1, this.context);
              resolve(finalModel);
            }
          });
        }
      };
      exports.Animation = Animation;
      var CompoundAnimation = class extends Animation {
        constructor(model, context, components = [], ease = easing_1.easeInOut) {
          super(context, ease);
          this.model = model;
          this.context = context;
          this.components = components;
          this.ease = ease;
        }
        include(animation) {
          this.components.push(animation);
          return this;
        }
        tween(t, context) {
          for (const a of this.components) {
            a.tween(t, context);
          }
          return this.model;
        }
      };
      exports.CompoundAnimation = CompoundAnimation;
    }
  });

  // node_modules/sprotty/lib/base/commands/command.js
  var require_command = __commonJS({
    "node_modules/sprotty/lib/base/commands/command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResetCommand = exports.SystemCommand = exports.PopupCommand = exports.HiddenCommand = exports.MergeableCommand = exports.Command = void 0;
      var inversify_1 = require_inversify();
      var Command3 = class Command {
      };
      exports.Command = Command3;
      exports.Command = Command3 = __decorate([
        (0, inversify_1.injectable)()
      ], Command3);
      var MergeableCommand = class MergeableCommand extends Command3 {
        /**
         * Tries to merge the given command with this.
         *
         * @param command
         * @param context
         */
        merge(command, context) {
          return false;
        }
      };
      exports.MergeableCommand = MergeableCommand;
      exports.MergeableCommand = MergeableCommand = __decorate([
        (0, inversify_1.injectable)()
      ], MergeableCommand);
      var HiddenCommand = class HiddenCommand extends Command3 {
        undo(context) {
          context.logger.error(this, "Cannot undo a hidden command");
          return context.root;
        }
        redo(context) {
          context.logger.error(this, "Cannot redo a hidden command");
          return context.root;
        }
      };
      exports.HiddenCommand = HiddenCommand;
      exports.HiddenCommand = HiddenCommand = __decorate([
        (0, inversify_1.injectable)()
      ], HiddenCommand);
      var PopupCommand = class PopupCommand extends Command3 {
      };
      exports.PopupCommand = PopupCommand;
      exports.PopupCommand = PopupCommand = __decorate([
        (0, inversify_1.injectable)()
      ], PopupCommand);
      var SystemCommand = class SystemCommand extends Command3 {
      };
      exports.SystemCommand = SystemCommand;
      exports.SystemCommand = SystemCommand = __decorate([
        (0, inversify_1.injectable)()
      ], SystemCommand);
      var ResetCommand = class ResetCommand extends Command3 {
      };
      exports.ResetCommand = ResetCommand;
      exports.ResetCommand = ResetCommand = __decorate([
        (0, inversify_1.injectable)()
      ], ResetCommand);
    }
  });

  // node_modules/sprotty/lib/base/commands/command-registration.js
  var require_command_registration = __commonJS({
    "node_modules/sprotty/lib/base/commands/command-registration.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureCommand = exports.CommandActionHandlerInitializer = exports.CommandActionHandler = void 0;
      var inversify_1 = require_inversify();
      var inversify_2 = require_inversify2();
      var types_1 = require_types();
      var CommandActionHandler = class {
        constructor(commandRegistration) {
          this.commandRegistration = commandRegistration;
        }
        handle(action) {
          return this.commandRegistration.factory(action);
        }
      };
      exports.CommandActionHandler = CommandActionHandler;
      var CommandActionHandlerInitializer = class CommandActionHandlerInitializer {
        constructor(registrations) {
          this.registrations = registrations;
        }
        initialize(registry) {
          this.registrations.forEach((registration) => registry.register(registration.kind, new CommandActionHandler(registration)));
        }
      };
      exports.CommandActionHandlerInitializer = CommandActionHandlerInitializer;
      exports.CommandActionHandlerInitializer = CommandActionHandlerInitializer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.CommandRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], CommandActionHandlerInitializer);
      function configureCommand4(context, constr) {
        if (!(0, inversify_2.isInjectable)(constr)) {
          throw new Error(`Commands should be @injectable: ${constr.name}`);
        }
        if (!context.isBound(constr)) {
          context.bind(constr).toSelf();
        }
        context.bind(types_1.TYPES.CommandRegistration).toDynamicValue((ctx) => ({
          kind: constr.KIND,
          factory: (action) => {
            const childContainer = new inversify_1.Container();
            childContainer.parent = ctx.container;
            childContainer.bind(types_1.TYPES.Action).toConstantValue(action);
            return childContainer.get(constr);
          }
        }));
      }
      exports.configureCommand = configureCommand4;
    }
  });

  // node_modules/sprotty/lib/base/commands/command-stack-options.js
  var require_command_stack_options = __commonJS({
    "node_modules/sprotty/lib/base/commands/command-stack-options.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.overrideCommandStackOptions = void 0;
      var object_1 = require_object();
      var types_1 = require_types();
      function overrideCommandStackOptions(container, options) {
        const defaultOptions = container.get(types_1.TYPES.CommandStackOptions);
        (0, object_1.safeAssign)(defaultOptions, options);
        return defaultOptions;
      }
      exports.overrideCommandStackOptions = overrideCommandStackOptions;
    }
  });

  // node_modules/sprotty/lib/base/commands/command-stack.js
  var require_command_stack = __commonJS({
    "node_modules/sprotty/lib/base/commands/command-stack.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommandStack = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var smodel_1 = require_smodel();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var command_1 = require_command();
      var CommandStack = class CommandStack {
        constructor() {
          this.undoStack = [];
          this.redoStack = [];
          this.offStack = [];
        }
        initialize() {
          this.currentPromise = Promise.resolve({
            main: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            },
            hidden: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            },
            popup: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            }
          });
        }
        get currentModel() {
          return this.currentPromise.then((state) => state.main.model);
        }
        executeAll(commands) {
          commands.forEach((command) => {
            this.logger.log(this, "Executing", command);
            this.handleCommand(command, command.execute, this.mergeOrPush);
          });
          return this.thenUpdate();
        }
        execute(command) {
          this.logger.log(this, "Executing", command);
          this.handleCommand(command, command.execute, this.mergeOrPush);
          return this.thenUpdate();
        }
        undo() {
          this.undoOffStackSystemCommands();
          this.undoPreceedingSystemCommands();
          const command = this.undoStack[this.undoStack.length - 1];
          if (command !== void 0 && !this.isBlockUndo(command)) {
            this.undoStack.pop();
            this.logger.log(this, "Undoing", command);
            this.handleCommand(command, command.undo, (c, context) => {
              this.redoStack.push(c);
            });
          }
          return this.thenUpdate();
        }
        redo() {
          this.undoOffStackSystemCommands();
          const command = this.redoStack.pop();
          if (command !== void 0) {
            this.logger.log(this, "Redoing", command);
            this.handleCommand(command, command.redo, (c, context) => {
              this.pushToUndoStack(c);
            });
          }
          this.redoFollowingSystemCommands();
          return this.thenUpdate();
        }
        /**
         * Chains the current promise with another Promise that performs the
         * given operation on the given command.
         *
         * @param beforeResolve a function that is called directly before
         *      resolving the Promise to return the new model. Usually puts the
         *      command on the appropriate stack.
         */
        handleCommand(command, operation, beforeResolve) {
          this.currentPromise = this.currentPromise.then((state) => new Promise((resolve) => {
            let target;
            if (command instanceof command_1.HiddenCommand)
              target = "hidden";
            else if (command instanceof command_1.PopupCommand)
              target = "popup";
            else
              target = "main";
            const context = this.createContext(state.main.model);
            let commandResult;
            try {
              commandResult = operation.call(command, context);
            } catch (error) {
              this.logger.error(this, "Failed to execute command:", error);
              commandResult = state[target].model;
            }
            const newState = copyState(state);
            if (commandResult instanceof Promise) {
              commandResult.then((newModel) => {
                if (target === "main")
                  beforeResolve.call(this, command, context);
                newState[target] = { model: newModel, modelChanged: true };
                resolve(newState);
              });
            } else if (commandResult instanceof smodel_1.SModelRootImpl) {
              if (target === "main")
                beforeResolve.call(this, command, context);
              newState[target] = { model: commandResult, modelChanged: true };
              resolve(newState);
            } else {
              if (target === "main")
                beforeResolve.call(this, command, context);
              newState[target] = {
                model: commandResult.model,
                modelChanged: state[target].modelChanged || commandResult.modelChanged,
                cause: commandResult.cause
              };
              resolve(newState);
            }
          }));
        }
        pushToUndoStack(command) {
          this.undoStack.push(command);
          if (this.options.undoHistoryLimit >= 0 && this.undoStack.length > this.options.undoHistoryLimit)
            this.undoStack.splice(0, this.undoStack.length - this.options.undoHistoryLimit);
        }
        /**
         * Notifies the Viewer to render the new model and/or the new hidden model
         * and returns a Promise for the new model.
         */
        thenUpdate() {
          this.currentPromise = this.currentPromise.then((state) => {
            const newState = copyState(state);
            if (state.hidden.modelChanged) {
              this.updateHidden(state.hidden.model, state.hidden.cause);
              newState.hidden.modelChanged = false;
              newState.hidden.cause = void 0;
            }
            if (state.main.modelChanged) {
              this.update(state.main.model, state.main.cause);
              newState.main.modelChanged = false;
              newState.main.cause = void 0;
            }
            if (state.popup.modelChanged) {
              this.updatePopup(state.popup.model, state.popup.cause);
              newState.popup.modelChanged = false;
              newState.popup.cause = void 0;
            }
            return newState;
          });
          return this.currentModel;
        }
        /**
         * Notify the `ModelViewer` that the model has changed.
         */
        update(model, cause) {
          if (this.modelViewer === void 0) {
            this.modelViewer = this.viewerProvider.modelViewer;
          }
          this.modelViewer.update(model, cause);
        }
        /**
         * Notify the `HiddenModelViewer` that the hidden model has changed.
         */
        updateHidden(model, cause) {
          if (this.hiddenModelViewer === void 0) {
            this.hiddenModelViewer = this.viewerProvider.hiddenModelViewer;
          }
          this.hiddenModelViewer.update(model, cause);
        }
        /**
         * Notify the `PopupModelViewer` that the popup model has changed.
         */
        updatePopup(model, cause) {
          if (this.popupModelViewer === void 0) {
            this.popupModelViewer = this.viewerProvider.popupModelViewer;
          }
          this.popupModelViewer.update(model, cause);
        }
        /**
         * Handling of commands after their execution.
         *
         * Hidden commands are not pushed to any stack.
         *
         * System commands are pushed to the <code>offStack</code> when the redo
         * stack is not empty, allowing to undo the before a redo to keep the chain
         * of commands consistent.
         *
         * Mergable commands are merged if possible.
         */
        mergeOrPush(command, context) {
          if (this.isBlockUndo(command)) {
            this.undoStack = [];
            this.redoStack = [];
            this.offStack = [];
            this.pushToUndoStack(command);
            return;
          }
          if (this.isPushToOffStack(command) && this.redoStack.length > 0) {
            if (this.offStack.length > 0) {
              const lastCommand = this.offStack[this.offStack.length - 1];
              if (lastCommand instanceof command_1.MergeableCommand && lastCommand.merge(command, context))
                return;
            }
            this.offStack.push(command);
            return;
          }
          if (this.isPushToUndoStack(command)) {
            this.offStack.forEach((c) => this.undoStack.push(c));
            this.offStack = [];
            this.redoStack = [];
            if (this.undoStack.length > 0) {
              const lastCommand = this.undoStack[this.undoStack.length - 1];
              if (lastCommand instanceof command_1.MergeableCommand && lastCommand.merge(command, context))
                return;
            }
            this.pushToUndoStack(command);
          }
        }
        /**
         * Reverts all system commands on the offStack.
         */
        undoOffStackSystemCommands() {
          let command = this.offStack.pop();
          while (command !== void 0) {
            this.logger.log(this, "Undoing off-stack", command);
            this.handleCommand(command, command.undo, () => {
            });
            command = this.offStack.pop();
          }
        }
        /**
         * System commands should be transparent to the user, so this method
         * is called from <code>undo()</code> to revert all system commands
         * at the top of the undoStack.
         */
        undoPreceedingSystemCommands() {
          let command = this.undoStack[this.undoStack.length - 1];
          while (command !== void 0 && this.isPushToOffStack(command)) {
            this.undoStack.pop();
            this.logger.log(this, "Undoing", command);
            this.handleCommand(command, command.undo, (c, context) => {
              this.redoStack.push(c);
            });
            command = this.undoStack[this.undoStack.length - 1];
          }
        }
        /**
         * System commands should be transparent to the user, so this method
         * is called from <code>redo()</code> to re-execute all system commands
         * at the top of the redoStack.
         */
        redoFollowingSystemCommands() {
          let command = this.redoStack[this.redoStack.length - 1];
          while (command !== void 0 && this.isPushToOffStack(command)) {
            this.redoStack.pop();
            this.logger.log(this, "Redoing ", command);
            this.handleCommand(command, command.redo, (c, context) => {
              this.pushToUndoStack(c);
            });
            command = this.redoStack[this.redoStack.length - 1];
          }
        }
        /**
         * Assembles the context object that is passed to the commands execution method.
         */
        createContext(currentModel) {
          return {
            root: currentModel,
            modelChanged: this,
            modelFactory: this.modelFactory,
            duration: this.options.defaultDuration,
            logger: this.logger,
            syncer: this.syncer
          };
        }
        isPushToOffStack(command) {
          return command instanceof command_1.SystemCommand;
        }
        isPushToUndoStack(command) {
          return !(command instanceof command_1.HiddenCommand);
        }
        isBlockUndo(command) {
          return command instanceof command_1.ResetCommand;
        }
      };
      exports.CommandStack = CommandStack;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IModelFactory),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "modelFactory", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IViewerProvider),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "viewerProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], CommandStack.prototype, "syncer", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.CommandStackOptions),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], CommandStack.prototype, "initialize", null);
      exports.CommandStack = CommandStack = __decorate([
        (0, inversify_1.injectable)()
      ], CommandStack);
      function copyState(state) {
        return {
          main: Object.assign({}, state.main),
          hidden: Object.assign({}, state.hidden),
          popup: Object.assign({}, state.popup)
        };
      }
    }
  });

  // node_modules/sprotty-protocol/lib/utils/model-utils.js
  var require_model_utils = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/model-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SModelIndex = exports.findElement = exports.getSubType = exports.getBasicType = exports.applyBounds = exports.cloneModel = void 0;
      function cloneModel(model) {
        return JSON.parse(JSON.stringify(model));
      }
      exports.cloneModel = cloneModel;
      function applyBounds(root, action) {
        const index = new SModelIndex();
        index.add(root);
        for (const b of action.bounds) {
          const element = index.getById(b.elementId);
          if (element) {
            const bae = element;
            if (b.newPosition) {
              bae.position = { x: b.newPosition.x, y: b.newPosition.y };
            }
            if (b.newSize) {
              bae.size = { width: b.newSize.width, height: b.newSize.height };
            }
          }
        }
        if (action.alignments) {
          for (const a of action.alignments) {
            const element = index.getById(a.elementId);
            if (element) {
              const alignable = element;
              alignable.alignment = { x: a.newAlignment.x, y: a.newAlignment.y };
            }
          }
        }
      }
      exports.applyBounds = applyBounds;
      function getBasicType(element) {
        if (!element.type) {
          return "";
        }
        const colonIndex = element.type.indexOf(":");
        return colonIndex >= 0 ? element.type.substring(0, colonIndex) : element.type;
      }
      exports.getBasicType = getBasicType;
      function getSubType(schema) {
        if (!schema.type) {
          return "";
        }
        const colonIndex = schema.type.indexOf(":");
        return colonIndex >= 0 ? schema.type.substring(colonIndex + 1) : schema.type;
      }
      exports.getSubType = getSubType;
      function findElement(parent, elementId) {
        if (parent.id === elementId)
          return parent;
        if (parent.children !== void 0) {
          for (const child of parent.children) {
            const result = findElement(child, elementId);
            if (result !== void 0)
              return result;
          }
        }
        return void 0;
      }
      exports.findElement = findElement;
      var SModelIndex = class {
        constructor() {
          this.id2element = /* @__PURE__ */ new Map();
          this.id2parent = /* @__PURE__ */ new Map();
        }
        add(element) {
          if (!element.id) {
            throw new Error("Model element has no ID.");
          } else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
          }
          this.id2element.set(element.id, element);
          if (Array.isArray(element.children)) {
            for (const child of element.children) {
              this.add(child);
              this.id2parent.set(child.id, element);
            }
          }
        }
        remove(element) {
          this.id2element.delete(element.id);
          if (Array.isArray(element.children)) {
            for (const child of element.children) {
              this.id2parent.delete(child.id);
              this.remove(child);
            }
          }
        }
        contains(element) {
          return this.id2element.has(element.id);
        }
        getById(id) {
          return this.id2element.get(id);
        }
        getParent(id) {
          return this.id2parent.get(id);
        }
        getRoot(element) {
          let current = element;
          while (current) {
            const parent = this.id2parent.get(current.id);
            if (parent === void 0) {
              return current;
            }
            current = parent;
          }
          throw new Error("Element has no root");
        }
      };
      exports.SModelIndex = SModelIndex;
    }
  });

  // node_modules/sprotty-protocol/lib/diagram-server.js
  var require_diagram_server = __commonJS({
    "node_modules/sprotty-protocol/lib/diagram-server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramServer = void 0;
      var actions_1 = require_actions();
      var async_1 = require_async2();
      var model_utils_1 = require_model_utils();
      var DiagramServer = class {
        constructor(dispatch, services) {
          this.state = {
            currentRoot: {
              type: "NONE",
              id: "ROOT"
            },
            revision: 0
          };
          this.requests = /* @__PURE__ */ new Map();
          this.dispatch = dispatch;
          this.diagramGenerator = services.DiagramGenerator;
          this.layoutEngine = services.ModelLayoutEngine;
          this.actionHandlerRegistry = services.ServerActionHandlerRegistry;
        }
        /**
         * Set the model and submit it to the client.
         */
        setModel(newRoot) {
          newRoot.revision = ++this.state.revision;
          this.state.currentRoot = newRoot;
          return this.submitModel(newRoot, false);
        }
        /**
         * Update the model to a new state and submit it to the client.
         */
        updateModel(newRoot) {
          newRoot.revision = ++this.state.revision;
          this.state.currentRoot = newRoot;
          return this.submitModel(newRoot, true);
        }
        /**
         * Whether the client needs to compute the layout of parts of the model. This affects the behavior
         * of `submitModel`.
         *
         * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
         * from the client. If the client does not specify whether it needs client layout, the default value
         * is `true`.
         */
        get needsClientLayout() {
          if (this.state.options && this.state.options.needsClientLayout !== void 0) {
            return !!this.state.options.needsClientLayout;
          }
          return true;
        }
        /**
         * Whether the server needs to compute the layout of parts of the model. This affects the behavior
         * of `submitModel`.
         *
         * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
         * from the client. If the client does not specify whether it needs server layout, the default value
         * is `false`.
         */
        get needsServerLayout() {
          if (this.state.options && this.state.options.needsServerLayout !== void 0) {
            return !!this.state.options.needsServerLayout;
          }
          return false;
        }
        /**
         * Called when an action is received from the client.
         */
        accept(action) {
          if ((0, actions_1.isResponseAction)(action)) {
            const id = action.responseId;
            const future = this.requests.get(id);
            if (future) {
              this.requests.delete(id);
              if (action.kind === actions_1.RejectAction.KIND) {
                const rejectAction = action;
                future.reject(new Error(rejectAction.message));
                console.warn(`Request with id ${action.responseId} failed: ${rejectAction.message}`, rejectAction.detail);
              } else {
                future.resolve(action);
              }
              return Promise.resolve();
            }
            console.info("No matching request for response:", action);
          }
          return this.handleAction(action);
        }
        /**
         * Send a request action to the client. The resulting promise is resolved when a matching
         * response is received and rejected when a `RejectAction` is received.
         */
        request(action) {
          if (!action.requestId) {
            action.requestId = "server_" + (0, actions_1.generateRequestId)();
          }
          const future = new async_1.Deferred();
          this.requests.set(action.requestId, future);
          this.dispatch(action).catch((err) => {
            this.requests.delete(action.requestId);
            future.reject(err);
          });
          return future.promise;
        }
        /**
         * Send a `RejectAction` to the client to notify that a request could not be fulfilled.
         */
        rejectRemoteRequest(action, error) {
          if (action && (0, actions_1.isRequestAction)(action)) {
            this.dispatch({
              kind: actions_1.RejectAction.KIND,
              responseId: action.requestId,
              message: error.message,
              detail: error.stack
            });
          }
        }
        handleAction(action) {
          var _a;
          const handlers = (_a = this.actionHandlerRegistry) === null || _a === void 0 ? void 0 : _a.getHandler(action.kind);
          if (handlers && handlers.length === 1) {
            return handlers[0](action, this.state, this);
          } else if (handlers && handlers.length > 1) {
            return Promise.all(handlers.map((h) => h(action, this.state, this)));
          }
          switch (action.kind) {
            case actions_1.RequestModelAction.KIND:
              return this.handleRequestModel(action);
            case actions_1.ComputedBoundsAction.KIND:
              return this.handleComputedBounds(action);
            case actions_1.LayoutAction.KIND:
              return this.handleLayout(action);
          }
          console.warn(`Unhandled action from client: ${action.kind}`);
          return Promise.resolve();
        }
        async handleRequestModel(action) {
          var _a;
          this.state.options = action.options;
          try {
            const newRoot = await this.diagramGenerator.generate({
              options: (_a = this.state.options) !== null && _a !== void 0 ? _a : {},
              state: this.state
            });
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
            await this.submitModel(this.state.currentRoot, false, action);
          } catch (err) {
            this.rejectRemoteRequest(action, err);
            console.error("Failed to generate diagram:", err);
          }
        }
        /**
         * Submit a model to the client after it has been updated in the server state.
         */
        async submitModel(newRoot, update, cause) {
          if (this.needsClientLayout) {
            if (!this.needsServerLayout) {
              this.dispatch({ kind: actions_1.RequestBoundsAction.KIND, newRoot });
            } else {
              const request = actions_1.RequestBoundsAction.create(newRoot);
              const response = await this.request(request);
              const currentRoot = this.state.currentRoot;
              if (response.revision === currentRoot.revision) {
                (0, model_utils_1.applyBounds)(currentRoot, response);
                await this.doSubmitModel(currentRoot, update, cause);
              } else {
                this.rejectRemoteRequest(cause, new Error(`Model revision does not match: ${response.revision}`));
              }
            }
          } else {
            await this.doSubmitModel(newRoot, update, cause);
          }
        }
        async doSubmitModel(newRoot, update, cause) {
          if (newRoot.revision !== this.state.revision) {
            return;
          }
          if (this.needsServerLayout && this.layoutEngine) {
            newRoot = await this.layoutEngine.layout(newRoot);
          }
          const modelType = newRoot.type;
          if (cause && cause.kind === actions_1.RequestModelAction.KIND) {
            const requestId = cause.requestId;
            const response = actions_1.SetModelAction.create(newRoot, requestId);
            await this.dispatch(response);
          } else if (update && modelType === this.state.lastSubmittedModelType) {
            await this.dispatch({ kind: actions_1.UpdateModelAction.KIND, newRoot, cause });
          } else {
            await this.dispatch({ kind: actions_1.SetModelAction.KIND, newRoot });
          }
          this.state.lastSubmittedModelType = modelType;
        }
        handleComputedBounds(action) {
          if (action.revision !== this.state.currentRoot.revision) {
            return Promise.reject();
          }
          (0, model_utils_1.applyBounds)(this.state.currentRoot, action);
          return Promise.resolve();
        }
        async handleLayout(action) {
          if (!this.layoutEngine) {
            return;
          }
          if (!this.needsServerLayout) {
            let newRoot = (0, model_utils_1.cloneModel)(this.state.currentRoot);
            newRoot = await this.layoutEngine.layout(newRoot);
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
          }
          await this.doSubmitModel(this.state.currentRoot, true, action);
        }
      };
      exports.DiagramServer = DiagramServer;
    }
  });

  // node_modules/sprotty-protocol/lib/diagram-services.js
  var require_diagram_services = __commonJS({
    "node_modules/sprotty-protocol/lib/diagram-services.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/sprotty-protocol/lib/model.js
  var require_model = __commonJS({
    "node_modules/sprotty-protocol/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isZoomable = exports.isScrollable = void 0;
      var object_1 = require_object();
      function isScrollable(element) {
        return (0, object_1.hasOwnProperty)(element, "scroll");
      }
      exports.isScrollable = isScrollable;
      function isZoomable(element) {
        return (0, object_1.hasOwnProperty)(element, "zoom");
      }
      exports.isZoomable = isZoomable;
    }
  });

  // node_modules/sprotty-protocol/lib/utils/json.js
  var require_json = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/json.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/sprotty-protocol/lib/index.js
  var require_lib = __commonJS({
    "node_modules/sprotty-protocol/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_actions(), exports);
      __exportStar(require_diagram_server(), exports);
      __exportStar(require_diagram_services(), exports);
      __exportStar(require_model(), exports);
      __exportStar(require_async2(), exports);
      __exportStar(require_geometry(), exports);
      __exportStar(require_json(), exports);
      __exportStar(require_model_utils(), exports);
      __exportStar(require_object(), exports);
    }
  });

  // node_modules/sprotty/lib/utils/browser.js
  var require_browser = __commonJS({
    "node_modules/sprotty/lib/utils/browser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSVGGraphicsElement = exports.hitsMouseEvent = exports.getWindowScroll = exports.isCrossSite = exports.isMac = exports.isCtrlOrCmd = void 0;
      var sprotty_protocol_1 = require_lib();
      function isCtrlOrCmd(event) {
        if (isMac())
          return event.metaKey;
        else
          return event.ctrlKey;
      }
      exports.isCtrlOrCmd = isCtrlOrCmd;
      function isMac() {
        return window.navigator.userAgent.indexOf("Mac") !== -1;
      }
      exports.isMac = isMac;
      function isCrossSite(url) {
        if (url && typeof window !== "undefined" && window.location) {
          let baseURL = "";
          if (window.location.protocol)
            baseURL += window.location.protocol + "//";
          if (window.location.host)
            baseURL += window.location.host;
          return baseURL.length > 0 && !url.startsWith(baseURL);
        }
        return false;
      }
      exports.isCrossSite = isCrossSite;
      function getWindowScroll() {
        if (typeof window === "undefined") {
          return sprotty_protocol_1.Point.ORIGIN;
        }
        return {
          x: window.pageXOffset,
          y: window.pageYOffset
        };
      }
      exports.getWindowScroll = getWindowScroll;
      function hitsMouseEvent(child, event) {
        const clientRect = child.getBoundingClientRect();
        return event.clientX >= clientRect.left && event.clientX <= clientRect.right && event.clientY >= clientRect.top && event.clientY <= clientRect.bottom;
      }
      exports.hitsMouseEvent = hitsMouseEvent;
      function isSVGGraphicsElement(node) {
        return typeof node.getBBox === "function";
      }
      exports.isSVGGraphicsElement = isSVGGraphicsElement;
    }
  });

  // node_modules/sprotty/lib/base/features/initialize-canvas.js
  var require_initialize_canvas = __commonJS({
    "node_modules/sprotty/lib/base/features/initialize-canvas.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InitializeCanvasBoundsCommand = exports.InitializeCanvasBoundsAction = exports.CanvasBoundsInitializer = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var browser_1 = require_browser();
      var CanvasBoundsInitializer = class CanvasBoundsInitializer {
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl && !geometry_1.Dimension.isValid(element.canvasBounds)) {
            this.rootAndVnode = [element, vnode];
          }
          return vnode;
        }
        postUpdate() {
          if (this.rootAndVnode !== void 0) {
            const domElement = this.rootAndVnode[1].elm;
            const oldBounds = this.rootAndVnode[0].canvasBounds;
            if (domElement !== void 0) {
              const newBounds = this.getBoundsInPage(domElement);
              if (!((0, geometry_1.almostEquals)(newBounds.x, oldBounds.x) && (0, geometry_1.almostEquals)(newBounds.y, oldBounds.y) && (0, geometry_1.almostEquals)(newBounds.width, oldBounds.width) && (0, geometry_1.almostEquals)(newBounds.height, oldBounds.width)))
                this.actionDispatcher.dispatch(InitializeCanvasBoundsAction.create(newBounds));
            }
            this.rootAndVnode = void 0;
          }
        }
        getBoundsInPage(element) {
          const bounds = element.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          return {
            x: bounds.left + scroll.x,
            y: bounds.top + scroll.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.CanvasBoundsInitializer = CanvasBoundsInitializer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], CanvasBoundsInitializer.prototype, "actionDispatcher", void 0);
      exports.CanvasBoundsInitializer = CanvasBoundsInitializer = __decorate([
        (0, inversify_1.injectable)()
      ], CanvasBoundsInitializer);
      var InitializeCanvasBoundsAction;
      (function(InitializeCanvasBoundsAction2) {
        InitializeCanvasBoundsAction2.KIND = "initializeCanvasBounds";
        function create(newCanvasBounds) {
          return {
            kind: InitializeCanvasBoundsAction2.KIND,
            newCanvasBounds
          };
        }
        InitializeCanvasBoundsAction2.create = create;
      })(InitializeCanvasBoundsAction || (exports.InitializeCanvasBoundsAction = InitializeCanvasBoundsAction = {}));
      var InitializeCanvasBoundsCommand = class InitializeCanvasBoundsCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.newCanvasBounds = this.action.newCanvasBounds;
          context.root.canvasBounds = this.newCanvasBounds;
          return context.root;
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.InitializeCanvasBoundsCommand = InitializeCanvasBoundsCommand;
      InitializeCanvasBoundsCommand.KIND = InitializeCanvasBoundsAction.KIND;
      exports.InitializeCanvasBoundsCommand = InitializeCanvasBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], InitializeCanvasBoundsCommand);
    }
  });

  // node_modules/sprotty/lib/base/features/set-model.js
  var require_set_model = __commonJS({
    "node_modules/sprotty/lib/base/features/set-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetModelCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var initialize_canvas_1 = require_initialize_canvas();
      var SetModelCommand = class SetModelCommand extends command_1.ResetCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.oldRoot = context.modelFactory.createRoot(context.root);
          this.newRoot = context.modelFactory.createRoot(this.action.newRoot);
          return this.newRoot;
        }
        undo(context) {
          return this.oldRoot;
        }
        redo(context) {
          return this.newRoot;
        }
        get blockUntil() {
          return (action) => action.kind === initialize_canvas_1.InitializeCanvasBoundsCommand.KIND;
        }
      };
      exports.SetModelCommand = SetModelCommand;
      SetModelCommand.KIND = actions_1.SetModelAction.KIND;
      exports.SetModelCommand = SetModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetModelCommand);
    }
  });

  // node_modules/sprotty/lib/base/model/smodel-utils.js
  var require_smodel_utils = __commonJS({
    "node_modules/sprotty/lib/base/model/smodel-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.transformToRootBounds = exports.containsSome = exports.translateBounds = exports.translatePoint = exports.findParentByFeature = exports.findParent = exports.registerModelElement = void 0;
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      function registerModelElement(context, type, constr, features) {
        context.bind(types_1.TYPES.SModelElementRegistration).toConstantValue({
          type,
          constr,
          features
        });
      }
      exports.registerModelElement = registerModelElement;
      function findParent2(element, predicate) {
        let current = element;
        while (current !== void 0) {
          if (predicate(current))
            return current;
          else if (current instanceof smodel_1.SChildElementImpl)
            current = current.parent;
          else
            current = void 0;
        }
        return current;
      }
      exports.findParent = findParent2;
      function findParentByFeature3(element, predicate) {
        let current = element;
        while (current !== void 0) {
          if (predicate(current))
            return current;
          else if (current instanceof smodel_1.SChildElementImpl)
            current = current.parent;
          else
            current = void 0;
        }
        return current;
      }
      exports.findParentByFeature = findParentByFeature3;
      function translatePoint(point, source, target) {
        if (source !== target) {
          while (source instanceof smodel_1.SChildElementImpl) {
            point = source.localToParent(point);
            source = source.parent;
            if (source === target)
              return point;
          }
          const targetTrace = [];
          while (target instanceof smodel_1.SChildElementImpl) {
            targetTrace.push(target);
            target = target.parent;
          }
          if (source !== target)
            throw new Error("Incompatible source and target: " + source.id + ", " + target.id);
          for (let i = targetTrace.length - 1; i >= 0; i--) {
            point = targetTrace[i].parentToLocal(point);
          }
        }
        return point;
      }
      exports.translatePoint = translatePoint;
      function translateBounds(bounds, source, target) {
        const upperLeft = translatePoint(bounds, source, target);
        const lowerRight = translatePoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, source, target);
        return {
          x: upperLeft.x,
          y: upperLeft.y,
          width: lowerRight.x - upperLeft.x,
          height: lowerRight.y - upperLeft.y
        };
      }
      exports.translateBounds = translateBounds;
      function containsSome(root, element) {
        const test = (el) => root.index.getById(el.id) !== void 0;
        const find = (elements) => elements.some((el) => test(el) || find(el.children));
        return find([element]);
      }
      exports.containsSome = containsSome;
      function transformToRootBounds(parent, bounds) {
        while (parent instanceof smodel_1.SChildElementImpl) {
          bounds = parent.localToParent(bounds);
          parent = parent.parent;
        }
        return bounds;
      }
      exports.transformToRootBounds = transformToRootBounds;
    }
  });

  // node_modules/sprotty/lib/base/ui-extensions/ui-extension-registry.js
  var require_ui_extension_registry = __commonJS({
    "node_modules/sprotty/lib/base/ui-extensions/ui-extension-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetUIExtensionVisibilityCommand = exports.SetUIExtensionVisibilityAction = exports.UIExtensionRegistry = void 0;
      var inversify_1 = require_inversify();
      var registry_1 = require_registry();
      var command_1 = require_command();
      var types_1 = require_types();
      var UIExtensionRegistry = class UIExtensionRegistry extends registry_1.InstanceRegistry {
        constructor(extensions = []) {
          super();
          extensions.forEach((extension) => this.register(extension.id(), extension));
        }
      };
      exports.UIExtensionRegistry = UIExtensionRegistry;
      exports.UIExtensionRegistry = UIExtensionRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IUIExtension)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], UIExtensionRegistry);
      var SetUIExtensionVisibilityAction;
      (function(SetUIExtensionVisibilityAction2) {
        SetUIExtensionVisibilityAction2.KIND = "setUIExtensionVisibility";
        function create(options) {
          var _a;
          return {
            kind: SetUIExtensionVisibilityAction2.KIND,
            extensionId: options.extensionId,
            visible: options.visible,
            contextElementsId: (_a = options.contextElementsId) !== null && _a !== void 0 ? _a : []
          };
        }
        SetUIExtensionVisibilityAction2.create = create;
      })(SetUIExtensionVisibilityAction || (exports.SetUIExtensionVisibilityAction = SetUIExtensionVisibilityAction = {}));
      var SetUIExtensionVisibilityCommand = class SetUIExtensionVisibilityCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const extension = this.registry.get(this.action.extensionId);
          if (extension) {
            this.action.visible ? extension.show(context.root, ...this.action.contextElementsId) : extension.hide();
          }
          return { model: context.root, modelChanged: false };
        }
        undo(context) {
          return { model: context.root, modelChanged: false };
        }
        redo(context) {
          return { model: context.root, modelChanged: false };
        }
      };
      exports.SetUIExtensionVisibilityCommand = SetUIExtensionVisibilityCommand;
      SetUIExtensionVisibilityCommand.KIND = SetUIExtensionVisibilityAction.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.UIExtensionRegistry),
        __metadata("design:type", UIExtensionRegistry)
      ], SetUIExtensionVisibilityCommand.prototype, "registry", void 0);
      exports.SetUIExtensionVisibilityCommand = SetUIExtensionVisibilityCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetUIExtensionVisibilityCommand);
    }
  });

  // node_modules/sprotty/lib/base/ui-extensions/ui-extension.js
  var require_ui_extension = __commonJS({
    "node_modules/sprotty/lib/base/ui-extensions/ui-extension.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractUIExtension = exports.isUIExtension = void 0;
      var inversify_1 = require_inversify();
      var sprotty_protocol_1 = require_lib();
      var types_1 = require_types();
      function isUIExtension(object) {
        return (0, sprotty_protocol_1.hasOwnProperty)(object, "id", "function") && (0, sprotty_protocol_1.hasOwnProperty)(object, "show", "function") && (0, sprotty_protocol_1.hasOwnProperty)(object, "hide", "function");
      }
      exports.isUIExtension = isUIExtension;
      var AbstractUIExtension = class AbstractUIExtension {
        show(root, ...contextElementIds) {
          this.activeElement = document.activeElement;
          if (!this.containerElement) {
            if (!this.initialize())
              return;
          }
          this.onBeforeShow(this.containerElement, root, ...contextElementIds);
          this.setContainerVisible(true);
        }
        hide() {
          this.setContainerVisible(false);
          this.restoreFocus();
          this.activeElement = null;
        }
        restoreFocus() {
          const focusedElement = this.activeElement;
          if (focusedElement) {
            focusedElement.focus();
          }
        }
        initialize() {
          const baseDiv = document.getElementById(this.options.baseDiv);
          if (!baseDiv) {
            this.logger.warn(this, `Could not obtain sprotty base container for initializing UI extension ${this.id}`, this);
            return false;
          }
          this.containerElement = this.getOrCreateContainer(baseDiv.id);
          this.initializeContents(this.containerElement);
          if (baseDiv) {
            baseDiv.insertBefore(this.containerElement, baseDiv.firstChild);
          }
          return true;
        }
        getOrCreateContainer(baseDivId) {
          let container = document.getElementById(this.id());
          if (container === null) {
            container = document.createElement("div");
            container.id = baseDivId + "_" + this.id();
            container.classList.add(this.containerClass());
          }
          return container;
        }
        setContainerVisible(visible) {
          if (this.containerElement) {
            if (visible) {
              this.containerElement.style.visibility = "visible";
              this.containerElement.style.opacity = "1";
            } else {
              this.containerElement.style.visibility = "hidden";
              this.containerElement.style.opacity = "0";
            }
          }
        }
        /**
         * Updates the `containerElement` under the given `context` before it becomes visible.
         *
         * Subclasses may override this method to, for instance, modifying the position of the
         * `containerElement`, add or remove elements, etc. depending on the specified `root`
         * or `contextElementIds`.
         */
        onBeforeShow(containerElement, root, ...contextElementIds) {
        }
      };
      exports.AbstractUIExtension = AbstractUIExtension;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], AbstractUIExtension.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], AbstractUIExtension.prototype, "logger", void 0);
      exports.AbstractUIExtension = AbstractUIExtension = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractUIExtension);
    }
  });

  // node_modules/sprotty/lib/base/views/vnode-utils.js
  var require_vnode_utils = __commonJS({
    "node_modules/sprotty/lib/base/views/vnode-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getAttrs = exports.on = exports.mergeStyle = exports.copyClassesFromElement = exports.copyClassesFromVNode = exports.setNamespace = exports.setClass = exports.setAttr = void 0;
      function setAttr2(vnode, name, value) {
        getAttrs(vnode)[name] = value;
      }
      exports.setAttr = setAttr2;
      function setClass2(vnode, name, value) {
        getClass(vnode)[name] = value;
      }
      exports.setClass = setClass2;
      function setNamespace(node, ns) {
        if (node.data === void 0)
          node.data = {};
        node.data.ns = ns;
        const children = node.children;
        if (children !== void 0) {
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (typeof child !== "string")
              setNamespace(child, ns);
          }
        }
      }
      exports.setNamespace = setNamespace;
      function copyClassesFromVNode(source, target) {
        const classList = getClass(source);
        Object.keys(classList).forEach((c) => setClass2(target, c, true));
      }
      exports.copyClassesFromVNode = copyClassesFromVNode;
      function copyClassesFromElement(element, target) {
        const classList = element.classList;
        for (let i = 0; i < classList.length; i++) {
          const item = classList.item(i);
          if (item)
            setClass2(target, item, true);
        }
      }
      exports.copyClassesFromElement = copyClassesFromElement;
      function mergeStyle(vnode, style) {
        getData(vnode).style = Object.assign(Object.assign({}, getData(vnode).style || {}), style);
      }
      exports.mergeStyle = mergeStyle;
      function on(vnode, event, listener) {
        const val = getOn(vnode);
        if (val[event]) {
          throw new Error("EventListener for " + event + " already registered on VNode");
        }
        val[event] = listener;
      }
      exports.on = on;
      function getAttrs(vnode) {
        const data = getData(vnode);
        if (!data.attrs)
          data.attrs = {};
        return data.attrs;
      }
      exports.getAttrs = getAttrs;
      function getData(vnode) {
        if (!vnode.data)
          vnode.data = {};
        return vnode.data;
      }
      function getClass(vnode) {
        const data = getData(vnode);
        if (!data.class)
          data.class = {};
        return data.class;
      }
      function getOn(vnode) {
        const data = getData(vnode);
        if (!data.on)
          data.on = {};
        return data.on;
      }
    }
  });

  // node_modules/sprotty/lib/base/views/key-tool.js
  var require_key_tool = __commonJS({
    "node_modules/sprotty/lib/base/views/key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyListener = exports.KeyTool = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var KeyTool = class KeyTool {
        constructor(keyListeners = []) {
          this.keyListeners = keyListeners;
        }
        register(keyListener) {
          this.keyListeners.push(keyListener);
        }
        deregister(keyListener) {
          const index = this.keyListeners.indexOf(keyListener);
          if (index >= 0)
            this.keyListeners.splice(index, 1);
        }
        handleEvent(methodName, model, event) {
          const actions = this.keyListeners.map((listener) => listener[methodName].apply(listener, [model, event])).reduce((a, b) => a.concat(b));
          if (actions.length > 0) {
            event.preventDefault();
            this.actionDispatcher.dispatchAll(actions);
          }
        }
        keyDown(element, event) {
          this.handleEvent("keyDown", element, event);
        }
        keyUp(element, event) {
          this.handleEvent("keyUp", element, event);
        }
        focus() {
        }
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl) {
            (0, vnode_utils_1.on)(vnode, "focus", this.focus.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "keydown", this.keyDown.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "keyup", this.keyUp.bind(this, element));
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.KeyTool = KeyTool;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], KeyTool.prototype, "actionDispatcher", void 0);
      exports.KeyTool = KeyTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.KeyListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], KeyTool);
      var KeyListener = class KeyListener {
        keyDown(element, event) {
          return [];
        }
        keyUp(element, event) {
          return [];
        }
      };
      exports.KeyListener = KeyListener;
      exports.KeyListener = KeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], KeyListener);
    }
  });

  // node_modules/sprotty/lib/base/views/dom-helper.js
  var require_dom_helper = __commonJS({
    "node_modules/sprotty/lib/base/views/dom-helper.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DOMHelper = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var DOMHelper = class DOMHelper {
        getPrefix() {
          const prefix = this.viewerOptions !== void 0 && this.viewerOptions.baseDiv !== void 0 ? this.viewerOptions.baseDiv + "_" : "";
          return prefix;
        }
        createUniqueDOMElementId(element) {
          return this.getPrefix() + element.id;
        }
        findSModelIdByDOMElement(element) {
          return element.id.replace(this.getPrefix(), "");
        }
      };
      exports.DOMHelper = DOMHelper;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], DOMHelper.prototype, "viewerOptions", void 0);
      exports.DOMHelper = DOMHelper = __decorate([
        (0, inversify_1.injectable)()
      ], DOMHelper);
    }
  });

  // node_modules/sprotty/lib/base/views/mouse-tool.js
  var require_mouse_tool = __commonJS({
    "node_modules/sprotty/lib/base/views/mouse-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MousePositionTracker = exports.MouseListener = exports.PopupMouseTool = exports.MouseTool = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var dom_helper_1 = require_dom_helper();
      var vnode_utils_1 = require_vnode_utils();
      var MouseTool = class MouseTool {
        constructor(mouseListeners = []) {
          this.mouseListeners = mouseListeners;
        }
        register(mouseListener) {
          this.mouseListeners.push(mouseListener);
        }
        deregister(mouseListener) {
          const index = this.mouseListeners.indexOf(mouseListener);
          if (index >= 0)
            this.mouseListeners.splice(index, 1);
        }
        getTargetElement(model, event) {
          let target = event.target;
          const index = model.index;
          while (target) {
            if (target.id) {
              const element = index.getById(this.domHelper.findSModelIdByDOMElement(target));
              if (element !== void 0)
                return element;
            }
            target = target.parentNode;
          }
          return void 0;
        }
        handleEvent(methodName, model, event) {
          this.focusOnMouseEvent(methodName, model);
          const element = this.getTargetElement(model, event);
          if (!element)
            return;
          const actions = this.mouseListeners.map((listener) => listener[methodName](element, event)).reduce((a, b) => a.concat(b));
          if (actions.length > 0) {
            event.preventDefault();
            for (const actionOrPromise of actions) {
              if ((0, actions_1.isAction)(actionOrPromise)) {
                this.actionDispatcher.dispatch(actionOrPromise);
              } else {
                actionOrPromise.then((action) => {
                  this.actionDispatcher.dispatch(action);
                });
              }
            }
          }
        }
        focusOnMouseEvent(methodName, model) {
          if (document && methodName === "mouseDown") {
            const domElement = document.getElementById(this.domHelper.createUniqueDOMElementId(model));
            if (domElement !== null && typeof domElement.focus === "function")
              domElement.focus();
          }
        }
        mouseOver(model, event) {
          this.handleEvent("mouseOver", model, event);
        }
        mouseOut(model, event) {
          this.handleEvent("mouseOut", model, event);
        }
        mouseEnter(model, event) {
          this.handleEvent("mouseEnter", model, event);
        }
        mouseLeave(model, event) {
          this.handleEvent("mouseLeave", model, event);
        }
        mouseDown(model, event) {
          this.handleEvent("mouseDown", model, event);
        }
        mouseMove(model, event) {
          this.handleEvent("mouseMove", model, event);
        }
        mouseUp(model, event) {
          this.handleEvent("mouseUp", model, event);
        }
        wheel(model, event) {
          this.handleEvent("wheel", model, event);
        }
        contextMenu(model, event) {
          event.preventDefault();
          this.handleEvent("contextMenu", model, event);
        }
        doubleClick(model, event) {
          this.handleEvent("doubleClick", model, event);
        }
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl) {
            (0, vnode_utils_1.on)(vnode, "mouseover", this.mouseOver.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseout", this.mouseOut.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseenter", this.mouseEnter.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseleave", this.mouseLeave.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mousedown", this.mouseDown.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseup", this.mouseUp.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mousemove", this.mouseMove.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "wheel", this.wheel.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "contextmenu", this.contextMenu.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "dblclick", this.doubleClick.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "dragover", (event) => this.handleEvent("dragOver", element, event));
            (0, vnode_utils_1.on)(vnode, "drop", (event) => this.handleEvent("drop", element, event));
          }
          vnode = this.mouseListeners.reduce((n, listener) => listener.decorate(n, element), vnode);
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.MouseTool = MouseTool;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], MouseTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], MouseTool.prototype, "domHelper", void 0);
      exports.MouseTool = MouseTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.MouseListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], MouseTool);
      var PopupMouseTool = class PopupMouseTool extends MouseTool {
        constructor(mouseListeners = []) {
          super(mouseListeners);
          this.mouseListeners = mouseListeners;
        }
      };
      exports.PopupMouseTool = PopupMouseTool;
      exports.PopupMouseTool = PopupMouseTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.PopupMouseListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], PopupMouseTool);
      var MouseListener2 = class MouseListener {
        mouseOver(target, event) {
          return [];
        }
        mouseOut(target, event) {
          return [];
        }
        mouseEnter(target, event) {
          return [];
        }
        mouseLeave(target, event) {
          return [];
        }
        mouseDown(target, event) {
          return [];
        }
        mouseMove(target, event) {
          return [];
        }
        mouseUp(target, event) {
          return [];
        }
        wheel(target, event) {
          return [];
        }
        doubleClick(target, event) {
          return [];
        }
        contextMenu(target, event) {
          return [];
        }
        dragOver(target, event) {
          return [];
        }
        drop(target, event) {
          return [];
        }
        decorate(vnode, element) {
          return vnode;
        }
      };
      exports.MouseListener = MouseListener2;
      exports.MouseListener = MouseListener2 = __decorate([
        (0, inversify_1.injectable)()
      ], MouseListener2);
      var MousePositionTracker = class MousePositionTracker extends MouseListener2 {
        mouseMove(target, event) {
          this.lastPosition = target.root.parentToLocal({ x: event.offsetX, y: event.offsetY });
          return [];
        }
        /**
         * Returns the last tracked mouse cursor position relative to the diagram root or `undefined`
         * if no mouse cursor position was ever tracked yet.
         */
        get lastPositionOnDiagram() {
          return this.lastPosition;
        }
      };
      exports.MousePositionTracker = MousePositionTracker;
      exports.MousePositionTracker = MousePositionTracker = __decorate([
        (0, inversify_1.injectable)()
      ], MousePositionTracker);
    }
  });

  // node_modules/snabbdom/build/snabbdom.cjs.js
  var require_snabbdom_cjs = __commonJS({
    "node_modules/snabbdom/build/snabbdom.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function createElement(tagName2, options) {
        return document.createElement(tagName2, options);
      }
      function createElementNS(namespaceURI, qualifiedName, options) {
        return document.createElementNS(namespaceURI, qualifiedName, options);
      }
      function createDocumentFragment() {
        return parseFragment(document.createDocumentFragment());
      }
      function createTextNode(text) {
        return document.createTextNode(text);
      }
      function createComment(text) {
        return document.createComment(text);
      }
      function insertBefore(parentNode2, newNode, referenceNode) {
        if (isDocumentFragment$1(parentNode2)) {
          let node = parentNode2;
          while (node && isDocumentFragment$1(node)) {
            const fragment2 = parseFragment(node);
            node = fragment2.parent;
          }
          parentNode2 = node !== null && node !== void 0 ? node : parentNode2;
        }
        if (isDocumentFragment$1(newNode)) {
          newNode = parseFragment(newNode, parentNode2);
        }
        if (referenceNode && isDocumentFragment$1(referenceNode)) {
          referenceNode = parseFragment(referenceNode).firstChildNode;
        }
        parentNode2.insertBefore(newNode, referenceNode);
      }
      function removeChild(node, child) {
        node.removeChild(child);
      }
      function appendChild(node, child) {
        if (isDocumentFragment$1(child)) {
          child = parseFragment(child, node);
        }
        node.appendChild(child);
      }
      function parentNode(node) {
        if (isDocumentFragment$1(node)) {
          while (node && isDocumentFragment$1(node)) {
            const fragment2 = parseFragment(node);
            node = fragment2.parent;
          }
          return node !== null && node !== void 0 ? node : null;
        }
        return node.parentNode;
      }
      function nextSibling(node) {
        var _a;
        if (isDocumentFragment$1(node)) {
          const fragment2 = parseFragment(node);
          const parent = parentNode(fragment2);
          if (parent && fragment2.lastChildNode) {
            const children = Array.from(parent.childNodes);
            const index = children.indexOf(fragment2.lastChildNode);
            return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;
          }
          return null;
        }
        return node.nextSibling;
      }
      function tagName(elm) {
        return elm.tagName;
      }
      function setTextContent(node, text) {
        node.textContent = text;
      }
      function getTextContent(node) {
        return node.textContent;
      }
      function isElement$1(node) {
        return node.nodeType === 1;
      }
      function isText(node) {
        return node.nodeType === 3;
      }
      function isComment(node) {
        return node.nodeType === 8;
      }
      function isDocumentFragment$1(node) {
        return node.nodeType === 11;
      }
      function parseFragment(fragmentNode, parentNode2) {
        var _a, _b, _c;
        const fragment2 = fragmentNode;
        (_a = fragment2.parent) !== null && _a !== void 0 ? _a : fragment2.parent = parentNode2 !== null && parentNode2 !== void 0 ? parentNode2 : null;
        (_b = fragment2.firstChildNode) !== null && _b !== void 0 ? _b : fragment2.firstChildNode = fragmentNode.firstChild;
        (_c = fragment2.lastChildNode) !== null && _c !== void 0 ? _c : fragment2.lastChildNode = fragmentNode.lastChild;
        return fragment2;
      }
      var htmlDomApi = {
        createElement,
        createElementNS,
        createTextNode,
        createDocumentFragment,
        createComment,
        insertBefore,
        removeChild,
        appendChild,
        parentNode,
        nextSibling,
        tagName,
        setTextContent,
        getTextContent,
        isElement: isElement$1,
        isText,
        isComment,
        isDocumentFragment: isDocumentFragment$1
      };
      function vnode(sel, data, children, text, elm) {
        const key = data === void 0 ? void 0 : data.key;
        return { sel, data, children, text, elm, key };
      }
      var array = Array.isArray;
      function primitive(s) {
        return typeof s === "string" || typeof s === "number" || s instanceof String || s instanceof Number;
      }
      function isUndef(s) {
        return s === void 0;
      }
      function isDef(s) {
        return s !== void 0;
      }
      var emptyNode = vnode("", {}, [], void 0, void 0);
      function sameVnode(vnode1, vnode2) {
        var _a, _b;
        const isSameKey = vnode1.key === vnode2.key;
        const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);
        const isSameSel = vnode1.sel === vnode2.sel;
        const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel ? typeof vnode1.text === typeof vnode2.text : true;
        return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;
      }
      function documentFragmentIsNotSupported() {
        throw new Error("The document fragment is not supported on this platform.");
      }
      function isElement(api, vnode2) {
        return api.isElement(vnode2);
      }
      function isDocumentFragment(api, vnode2) {
        return api.isDocumentFragment(vnode2);
      }
      function createKeyToOldIdx(children, beginIdx, endIdx) {
        var _a;
        const map = {};
        for (let i = beginIdx; i <= endIdx; ++i) {
          const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;
          if (key !== void 0) {
            map[key] = i;
          }
        }
        return map;
      }
      var hooks = [
        "create",
        "update",
        "remove",
        "destroy",
        "pre",
        "post"
      ];
      function init$1(modules, domApi, options) {
        const cbs = {
          create: [],
          update: [],
          remove: [],
          destroy: [],
          pre: [],
          post: []
        };
        const api = domApi !== void 0 ? domApi : htmlDomApi;
        for (const hook of hooks) {
          for (const module2 of modules) {
            const currentHook = module2[hook];
            if (currentHook !== void 0) {
              cbs[hook].push(currentHook);
            }
          }
        }
        function emptyNodeAt(elm) {
          const id = elm.id ? "#" + elm.id : "";
          const classes = elm.getAttribute("class");
          const c = classes ? "." + classes.split(" ").join(".") : "";
          return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], void 0, elm);
        }
        function emptyDocumentFragmentAt(frag) {
          return vnode(void 0, {}, [], void 0, frag);
        }
        function createRmCb(childElm, listeners) {
          return function rmCb() {
            if (--listeners === 0) {
              const parent = api.parentNode(childElm);
              api.removeChild(parent, childElm);
            }
          };
        }
        function createElm(vnode2, insertedVnodeQueue) {
          var _a, _b, _c, _d;
          let i;
          let data = vnode2.data;
          if (data !== void 0) {
            const init2 = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;
            if (isDef(init2)) {
              init2(vnode2);
              data = vnode2.data;
            }
          }
          const children = vnode2.children;
          const sel = vnode2.sel;
          if (sel === "!") {
            if (isUndef(vnode2.text)) {
              vnode2.text = "";
            }
            vnode2.elm = api.createComment(vnode2.text);
          } else if (sel !== void 0) {
            const hashIdx = sel.indexOf("#");
            const dotIdx = sel.indexOf(".", hashIdx);
            const hash = hashIdx > 0 ? hashIdx : sel.length;
            const dot = dotIdx > 0 ? dotIdx : sel.length;
            const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            const elm = vnode2.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag, data) : api.createElement(tag, data);
            if (hash < dot)
              elm.setAttribute("id", sel.slice(hash + 1, dot));
            if (dotIdx > 0)
              elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
            for (i = 0; i < cbs.create.length; ++i)
              cbs.create[i](emptyNode, vnode2);
            if (array(children)) {
              for (i = 0; i < children.length; ++i) {
                const ch = children[i];
                if (ch != null) {
                  api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                }
              }
            } else if (primitive(vnode2.text)) {
              api.appendChild(elm, api.createTextNode(vnode2.text));
            }
            const hook = vnode2.data.hook;
            if (isDef(hook)) {
              (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode2);
              if (hook.insert) {
                insertedVnodeQueue.push(vnode2);
              }
            }
          } else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode2.children) {
            vnode2.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();
            for (i = 0; i < cbs.create.length; ++i)
              cbs.create[i](emptyNode, vnode2);
            for (i = 0; i < vnode2.children.length; ++i) {
              const ch = vnode2.children[i];
              if (ch != null) {
                api.appendChild(vnode2.elm, createElm(ch, insertedVnodeQueue));
              }
            }
          } else {
            vnode2.elm = api.createTextNode(vnode2.text);
          }
          return vnode2.elm;
        }
        function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
          for (; startIdx <= endIdx; ++startIdx) {
            const ch = vnodes[startIdx];
            if (ch != null) {
              api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
          }
        }
        function invokeDestroyHook(vnode2) {
          var _a, _b;
          const data = vnode2.data;
          if (data !== void 0) {
            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode2);
            for (let i = 0; i < cbs.destroy.length; ++i)
              cbs.destroy[i](vnode2);
            if (vnode2.children !== void 0) {
              for (let j = 0; j < vnode2.children.length; ++j) {
                const child = vnode2.children[j];
                if (child != null && typeof child !== "string") {
                  invokeDestroyHook(child);
                }
              }
            }
          }
        }
        function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
          var _a, _b;
          for (; startIdx <= endIdx; ++startIdx) {
            let listeners;
            let rm;
            const ch = vnodes[startIdx];
            if (ch != null) {
              if (isDef(ch.sel)) {
                invokeDestroyHook(ch);
                listeners = cbs.remove.length + 1;
                rm = createRmCb(ch.elm, listeners);
                for (let i = 0; i < cbs.remove.length; ++i)
                  cbs.remove[i](ch, rm);
                const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;
                if (isDef(removeHook)) {
                  removeHook(ch, rm);
                } else {
                  rm();
                }
              } else if (ch.children) {
                invokeDestroyHook(ch);
                removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);
              } else {
                api.removeChild(parentElm, ch.elm);
              }
            }
          }
        }
        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
          let oldStartIdx = 0;
          let newStartIdx = 0;
          let oldEndIdx = oldCh.length - 1;
          let oldStartVnode = oldCh[0];
          let oldEndVnode = oldCh[oldEndIdx];
          let newEndIdx = newCh.length - 1;
          let newStartVnode = newCh[0];
          let newEndVnode = newCh[newEndIdx];
          let oldKeyToIdx;
          let idxInOld;
          let elmToMove;
          let before;
          while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
              oldStartVnode = oldCh[++oldStartIdx];
            } else if (oldEndVnode == null) {
              oldEndVnode = oldCh[--oldEndIdx];
            } else if (newStartVnode == null) {
              newStartVnode = newCh[++newStartIdx];
            } else if (newEndVnode == null) {
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newStartVnode)) {
              patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
              oldStartVnode = oldCh[++oldStartIdx];
              newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
              patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
              oldEndVnode = oldCh[--oldEndIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
              patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
              api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
              oldStartVnode = oldCh[++oldStartIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
              patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
              api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
              oldEndVnode = oldCh[--oldEndIdx];
              newStartVnode = newCh[++newStartIdx];
            } else {
              if (oldKeyToIdx === void 0) {
                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
              }
              idxInOld = oldKeyToIdx[newStartVnode.key];
              if (isUndef(idxInOld)) {
                api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
              } else {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.sel !== newStartVnode.sel) {
                  api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                } else {
                  patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                  oldCh[idxInOld] = void 0;
                  api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                }
              }
              newStartVnode = newCh[++newStartIdx];
            }
          }
          if (newStartIdx <= newEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
          }
          if (oldStartIdx <= oldEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
          }
        }
        function patchVnode(oldVnode, vnode2, insertedVnodeQueue) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          const hook = (_a = vnode2.data) === null || _a === void 0 ? void 0 : _a.hook;
          (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode2);
          const elm = vnode2.elm = oldVnode.elm;
          if (oldVnode === vnode2)
            return;
          if (vnode2.data !== void 0 || isDef(vnode2.text) && vnode2.text !== oldVnode.text) {
            (_c = vnode2.data) !== null && _c !== void 0 ? _c : vnode2.data = {};
            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : oldVnode.data = {};
            for (let i = 0; i < cbs.update.length; ++i)
              cbs.update[i](oldVnode, vnode2);
            (_g = (_f = (_e = vnode2.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode2);
          }
          const oldCh = oldVnode.children;
          const ch = vnode2.children;
          if (isUndef(vnode2.text)) {
            if (isDef(oldCh) && isDef(ch)) {
              if (oldCh !== ch)
                updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            } else if (isDef(ch)) {
              if (isDef(oldVnode.text))
                api.setTextContent(elm, "");
              addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) {
              removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            } else if (isDef(oldVnode.text)) {
              api.setTextContent(elm, "");
            }
          } else if (oldVnode.text !== vnode2.text) {
            if (isDef(oldCh)) {
              removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            api.setTextContent(elm, vnode2.text);
          }
          (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode2);
        }
        return function patch(oldVnode, vnode2) {
          let i, elm, parent;
          const insertedVnodeQueue = [];
          for (i = 0; i < cbs.pre.length; ++i)
            cbs.pre[i]();
          if (isElement(api, oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
          } else if (isDocumentFragment(api, oldVnode)) {
            oldVnode = emptyDocumentFragmentAt(oldVnode);
          }
          if (sameVnode(oldVnode, vnode2)) {
            patchVnode(oldVnode, vnode2, insertedVnodeQueue);
          } else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode2, insertedVnodeQueue);
            if (parent !== null) {
              api.insertBefore(parent, vnode2.elm, api.nextSibling(elm));
              removeVnodes(parent, [oldVnode], 0, 0);
            }
          }
          for (i = 0; i < insertedVnodeQueue.length; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
          }
          for (i = 0; i < cbs.post.length; ++i)
            cbs.post[i]();
          return vnode2;
        };
      }
      function addNS(data, children, sel) {
        data.ns = "http://www.w3.org/2000/svg";
        if (sel !== "foreignObject" && children !== void 0) {
          for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            if (typeof child === "string")
              continue;
            const childData = child.data;
            if (childData !== void 0) {
              addNS(childData, child.children, child.sel);
            }
          }
        }
      }
      function h(sel, b, c) {
        let data = {};
        let children;
        let text;
        let i;
        if (c !== void 0) {
          if (b !== null) {
            data = b;
          }
          if (array(c)) {
            children = c;
          } else if (primitive(c)) {
            text = c.toString();
          } else if (c && c.sel) {
            children = [c];
          }
        } else if (b !== void 0 && b !== null) {
          if (array(b)) {
            children = b;
          } else if (primitive(b)) {
            text = b.toString();
          } else if (b && b.sel) {
            children = [b];
          } else {
            data = b;
          }
        }
        if (children !== void 0) {
          for (i = 0; i < children.length; ++i) {
            if (primitive(children[i]))
              children[i] = vnode(void 0, void 0, void 0, children[i], void 0);
          }
        }
        if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
          addNS(data, children, sel);
        }
        return vnode(sel, data, children, text, void 0);
      }
      function fragment(children) {
        let c;
        let text;
        if (array(children)) {
          c = children;
        } else if (primitive(c)) {
          text = children;
        } else if (c && c.sel) {
          c = [children];
        }
        if (c !== void 0) {
          for (let i = 0; i < c.length; ++i) {
            if (primitive(c[i]))
              c[i] = vnode(void 0, void 0, void 0, c[i], void 0);
          }
        }
        return vnode(void 0, {}, c, text, void 0);
      }
      function copyToThunk(vnode2, thunk2) {
        var _a;
        const ns = (_a = thunk2.data) === null || _a === void 0 ? void 0 : _a.ns;
        vnode2.data.fn = thunk2.data.fn;
        vnode2.data.args = thunk2.data.args;
        thunk2.data = vnode2.data;
        thunk2.children = vnode2.children;
        thunk2.text = vnode2.text;
        thunk2.elm = vnode2.elm;
        if (ns)
          addNS(thunk2.data, thunk2.children, thunk2.sel);
      }
      function init(thunk2) {
        const cur = thunk2.data;
        const vnode2 = cur.fn(...cur.args);
        copyToThunk(vnode2, thunk2);
      }
      function prepatch(oldVnode, thunk2) {
        let i;
        const old = oldVnode.data;
        const cur = thunk2.data;
        const oldArgs = old.args;
        const args = cur.args;
        if (old.fn !== cur.fn || oldArgs.length !== args.length) {
          copyToThunk(cur.fn(...args), thunk2);
          return;
        }
        for (i = 0; i < args.length; ++i) {
          if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn(...args), thunk2);
            return;
          }
        }
        copyToThunk(oldVnode, thunk2);
      }
      var thunk = function thunk2(sel, key, fn, args) {
        if (args === void 0) {
          args = fn;
          fn = key;
          key = void 0;
        }
        return h(sel, {
          key,
          hook: { init, prepatch },
          fn,
          args
        });
      };
      function pre(vnode2, newVnode) {
        const attachData = vnode2.data.attachData;
        newVnode.data.attachData.placeholder = attachData.placeholder;
        newVnode.data.attachData.real = attachData.real;
        vnode2.elm = vnode2.data.attachData.real;
      }
      function post(_, vnode2) {
        vnode2.elm = vnode2.data.attachData.placeholder;
      }
      function destroy(vnode2) {
        if (vnode2.elm !== void 0) {
          vnode2.elm.parentNode.removeChild(vnode2.elm);
        }
        vnode2.elm = vnode2.data.attachData.real;
      }
      function create(_, vnode2) {
        const real = vnode2.elm;
        const attachData = vnode2.data.attachData;
        const placeholder = document.createElement("span");
        vnode2.elm = placeholder;
        attachData.target.appendChild(real);
        attachData.real = real;
        attachData.placeholder = placeholder;
      }
      function attachTo(target, vnode2) {
        if (vnode2.data === void 0)
          vnode2.data = {};
        if (vnode2.data.hook === void 0)
          vnode2.data.hook = {};
        const data = vnode2.data;
        const hook = vnode2.data.hook;
        data.attachData = { target, placeholder: void 0, real: void 0 };
        hook.create = create;
        hook.prepatch = pre;
        hook.postpatch = post;
        hook.destroy = destroy;
        return vnode2;
      }
      function toVNode(node, domApi) {
        const api = domApi !== void 0 ? domApi : htmlDomApi;
        let text;
        if (api.isElement(node)) {
          const id = node.id ? "#" + node.id : "";
          const cn = node.getAttribute("class");
          const c = cn ? "." + cn.split(" ").join(".") : "";
          const sel = api.tagName(node).toLowerCase() + id + c;
          const attrs = {};
          const dataset = {};
          const data = {};
          const children = [];
          let name;
          let i, n;
          const elmAttrs = node.attributes;
          const elmChildren = node.childNodes;
          for (i = 0, n = elmAttrs.length; i < n; i++) {
            name = elmAttrs[i].nodeName;
            if (name[0] === "d" && name[1] === "a" && name[2] === "t" && name[3] === "a" && name[4] === "-") {
              dataset[name.slice(5)] = elmAttrs[i].nodeValue || "";
            } else if (name !== "id" && name !== "class") {
              attrs[name] = elmAttrs[i].nodeValue;
            }
          }
          for (i = 0, n = elmChildren.length; i < n; i++) {
            children.push(toVNode(elmChildren[i], domApi));
          }
          if (Object.keys(attrs).length > 0)
            data.attrs = attrs;
          if (Object.keys(dataset).length > 0)
            data.dataset = dataset;
          if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
            addNS(data, children, sel);
          }
          return vnode(sel, data, children, void 0, node);
        } else if (api.isText(node)) {
          text = api.getTextContent(node);
          return vnode(void 0, void 0, void 0, text, node);
        } else if (api.isComment(node)) {
          text = api.getTextContent(node);
          return vnode("!", {}, [], text, node);
        } else {
          return vnode("", {}, [], void 0, node);
        }
      }
      var xlinkNS = "http://www.w3.org/1999/xlink";
      var xmlNS = "http://www.w3.org/XML/1998/namespace";
      var colonChar = 58;
      var xChar = 120;
      function updateAttrs(oldVnode, vnode2) {
        let key;
        const elm = vnode2.elm;
        let oldAttrs = oldVnode.data.attrs;
        let attrs = vnode2.data.attrs;
        if (!oldAttrs && !attrs)
          return;
        if (oldAttrs === attrs)
          return;
        oldAttrs = oldAttrs || {};
        attrs = attrs || {};
        for (key in attrs) {
          const cur = attrs[key];
          const old = oldAttrs[key];
          if (old !== cur) {
            if (cur === true) {
              elm.setAttribute(key, "");
            } else if (cur === false) {
              elm.removeAttribute(key);
            } else {
              if (key.charCodeAt(0) !== xChar) {
                elm.setAttribute(key, cur);
              } else if (key.charCodeAt(3) === colonChar) {
                elm.setAttributeNS(xmlNS, key, cur);
              } else if (key.charCodeAt(5) === colonChar) {
                elm.setAttributeNS(xlinkNS, key, cur);
              } else {
                elm.setAttribute(key, cur);
              }
            }
          }
        }
        for (key in oldAttrs) {
          if (!(key in attrs)) {
            elm.removeAttribute(key);
          }
        }
      }
      var attributesModule = {
        create: updateAttrs,
        update: updateAttrs
      };
      function updateClass(oldVnode, vnode2) {
        let cur;
        let name;
        const elm = vnode2.elm;
        let oldClass = oldVnode.data.class;
        let klass = vnode2.data.class;
        if (!oldClass && !klass)
          return;
        if (oldClass === klass)
          return;
        oldClass = oldClass || {};
        klass = klass || {};
        for (name in oldClass) {
          if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {
            elm.classList.remove(name);
          }
        }
        for (name in klass) {
          cur = klass[name];
          if (cur !== oldClass[name]) {
            elm.classList[cur ? "add" : "remove"](name);
          }
        }
      }
      var classModule = { create: updateClass, update: updateClass };
      var CAPS_REGEX = /[A-Z]/g;
      function updateDataset(oldVnode, vnode2) {
        const elm = vnode2.elm;
        let oldDataset = oldVnode.data.dataset;
        let dataset = vnode2.data.dataset;
        let key;
        if (!oldDataset && !dataset)
          return;
        if (oldDataset === dataset)
          return;
        oldDataset = oldDataset || {};
        dataset = dataset || {};
        const d = elm.dataset;
        for (key in oldDataset) {
          if (!dataset[key]) {
            if (d) {
              if (key in d) {
                delete d[key];
              }
            } else {
              elm.removeAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase());
            }
          }
        }
        for (key in dataset) {
          if (oldDataset[key] !== dataset[key]) {
            if (d) {
              d[key] = dataset[key];
            } else {
              elm.setAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase(), dataset[key]);
            }
          }
        }
      }
      var datasetModule = {
        create: updateDataset,
        update: updateDataset
      };
      function invokeHandler(handler, vnode2, event) {
        if (typeof handler === "function") {
          handler.call(vnode2, event, vnode2);
        } else if (typeof handler === "object") {
          for (let i = 0; i < handler.length; i++) {
            invokeHandler(handler[i], vnode2, event);
          }
        }
      }
      function handleEvent(event, vnode2) {
        const name = event.type;
        const on = vnode2.data.on;
        if (on && on[name]) {
          invokeHandler(on[name], vnode2, event);
        }
      }
      function createListener() {
        return function handler(event) {
          handleEvent(event, handler.vnode);
        };
      }
      function updateEventListeners(oldVnode, vnode2) {
        const oldOn = oldVnode.data.on;
        const oldListener = oldVnode.listener;
        const oldElm = oldVnode.elm;
        const on = vnode2 && vnode2.data.on;
        const elm = vnode2 && vnode2.elm;
        let name;
        if (oldOn === on) {
          return;
        }
        if (oldOn && oldListener) {
          if (!on) {
            for (name in oldOn) {
              oldElm.removeEventListener(name, oldListener, false);
            }
          } else {
            for (name in oldOn) {
              if (!on[name]) {
                oldElm.removeEventListener(name, oldListener, false);
              }
            }
          }
        }
        if (on) {
          const listener = vnode2.listener = oldVnode.listener || createListener();
          listener.vnode = vnode2;
          if (!oldOn) {
            for (name in on) {
              elm.addEventListener(name, listener, false);
            }
          } else {
            for (name in on) {
              if (!oldOn[name]) {
                elm.addEventListener(name, listener, false);
              }
            }
          }
        }
      }
      var eventListenersModule = {
        create: updateEventListeners,
        update: updateEventListeners,
        destroy: updateEventListeners
      };
      function updateProps(oldVnode, vnode2) {
        let key;
        let cur;
        let old;
        const elm = vnode2.elm;
        let oldProps = oldVnode.data.props;
        let props = vnode2.data.props;
        if (!oldProps && !props)
          return;
        if (oldProps === props)
          return;
        oldProps = oldProps || {};
        props = props || {};
        for (key in props) {
          cur = props[key];
          old = oldProps[key];
          if (old !== cur && (key !== "value" || elm[key] !== cur)) {
            elm[key] = cur;
          }
        }
      }
      var propsModule = { create: updateProps, update: updateProps };
      var raf = typeof window !== "undefined" && window.requestAnimationFrame.bind(window) || setTimeout;
      var nextFrame = function(fn) {
        raf(function() {
          raf(fn);
        });
      };
      var reflowForced = false;
      function setNextFrame(obj, prop, val) {
        nextFrame(function() {
          obj[prop] = val;
        });
      }
      function updateStyle(oldVnode, vnode2) {
        let cur;
        let name;
        const elm = vnode2.elm;
        let oldStyle = oldVnode.data.style;
        let style = vnode2.data.style;
        if (!oldStyle && !style)
          return;
        if (oldStyle === style)
          return;
        oldStyle = oldStyle || {};
        style = style || {};
        const oldHasDel = "delayed" in oldStyle;
        for (name in oldStyle) {
          if (!style[name]) {
            if (name[0] === "-" && name[1] === "-") {
              elm.style.removeProperty(name);
            } else {
              elm.style[name] = "";
            }
          }
        }
        for (name in style) {
          cur = style[name];
          if (name === "delayed" && style.delayed) {
            for (const name2 in style.delayed) {
              cur = style.delayed[name2];
              if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                setNextFrame(elm.style, name2, cur);
              }
            }
          } else if (name !== "remove" && cur !== oldStyle[name]) {
            if (name[0] === "-" && name[1] === "-") {
              elm.style.setProperty(name, cur);
            } else {
              elm.style[name] = cur;
            }
          }
        }
      }
      function applyDestroyStyle(vnode2) {
        let style;
        let name;
        const elm = vnode2.elm;
        const s = vnode2.data.style;
        if (!s || !(style = s.destroy))
          return;
        for (name in style) {
          elm.style[name] = style[name];
        }
      }
      function applyRemoveStyle(vnode2, rm) {
        const s = vnode2.data.style;
        if (!s || !s.remove) {
          rm();
          return;
        }
        if (!reflowForced) {
          vnode2.elm.offsetLeft;
          reflowForced = true;
        }
        let name;
        const elm = vnode2.elm;
        let i = 0;
        const style = s.remove;
        let amount = 0;
        const applied = [];
        for (name in style) {
          applied.push(name);
          elm.style[name] = style[name];
        }
        const compStyle = getComputedStyle(elm);
        const props = compStyle["transition-property"].split(", ");
        for (; i < props.length; ++i) {
          if (applied.indexOf(props[i]) !== -1)
            amount++;
        }
        elm.addEventListener("transitionend", function(ev) {
          if (ev.target === elm)
            --amount;
          if (amount === 0)
            rm();
        });
      }
      function forceReflow() {
        reflowForced = false;
      }
      var styleModule = {
        pre: forceReflow,
        create: updateStyle,
        update: updateStyle,
        destroy: applyDestroyStyle,
        remove: applyRemoveStyle
      };
      function Fragment(data, ...children) {
        const flatChildren = flattenAndFilter(children, []);
        if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
          return vnode(void 0, void 0, void 0, flatChildren[0].text, void 0);
        } else {
          return vnode(void 0, data !== null && data !== void 0 ? data : {}, flatChildren, void 0, void 0);
        }
      }
      function flattenAndFilter(children, flattened) {
        for (const child of children) {
          if (child !== void 0 && child !== null && child !== false && child !== "") {
            if (Array.isArray(child)) {
              flattenAndFilter(child, flattened);
            } else if (typeof child === "string" || typeof child === "number" || typeof child === "boolean") {
              flattened.push(vnode(void 0, void 0, void 0, String(child), void 0));
            } else {
              flattened.push(child);
            }
          }
        }
        return flattened;
      }
      function jsx(tag, data, ...children) {
        const flatChildren = flattenAndFilter(children, []);
        if (typeof tag === "function") {
          return tag(data, flatChildren);
        } else {
          if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
            return h(tag, data, flatChildren[0].text);
          } else {
            return h(tag, data, flatChildren);
          }
        }
      }
      (function(jsx2) {
      })(jsx || (jsx = {}));
      exports.Fragment = Fragment;
      exports.array = array;
      exports.attachTo = attachTo;
      exports.attributesModule = attributesModule;
      exports.classModule = classModule;
      exports.datasetModule = datasetModule;
      exports.eventListenersModule = eventListenersModule;
      exports.fragment = fragment;
      exports.h = h;
      exports.htmlDomApi = htmlDomApi;
      exports.init = init$1;
      exports.jsx = jsx;
      exports.primitive = primitive;
      exports.propsModule = propsModule;
      exports.styleModule = styleModule;
      exports.thunk = thunk;
      exports.toVNode = toVNode;
      exports.vnode = vnode;
    }
  });

  // node_modules/sprotty/lib/base/views/thunk-view.js
  var require_thunk_view = __commonJS({
    "node_modules/sprotty/lib/base/views/thunk-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isThunk = exports.ThunkView = void 0;
      var snabbdom_1 = require_snabbdom_cjs();
      var inversify_1 = require_inversify();
      var ThunkView = class ThunkView {
        render(model, context) {
          return (0, snabbdom_1.h)(this.selector(model), {
            key: model.id,
            hook: {
              init: this.init.bind(this),
              prepatch: this.prepatch.bind(this)
            },
            fn: () => this.renderAndDecorate(model, context),
            args: this.watchedArgs(model),
            thunk: true
          });
        }
        renderAndDecorate(model, context) {
          const vnode = this.doRender(model, context);
          context.decorate(vnode, model);
          return vnode;
        }
        copyToThunk(vnode, thunk) {
          thunk.elm = vnode.elm;
          vnode.data.fn = thunk.data.fn;
          vnode.data.args = thunk.data.args;
          thunk.data = vnode.data;
          thunk.children = vnode.children;
          thunk.text = vnode.text;
          thunk.elm = vnode.elm;
        }
        init(thunk) {
          const cur = thunk.data;
          const vnode = cur.fn.apply(void 0, cur.args);
          this.copyToThunk(vnode, thunk);
        }
        prepatch(oldVnode, thunk) {
          const old = oldVnode.data, cur = thunk.data;
          if (!this.equals(old.args, cur.args))
            this.copyToThunk(cur.fn.apply(void 0, cur.args), thunk);
          else
            this.copyToThunk(oldVnode, thunk);
        }
        equals(oldArg, newArg) {
          if (Array.isArray(oldArg) && Array.isArray(newArg)) {
            if (oldArg.length !== newArg.length)
              return false;
            for (let i = 0; i < newArg.length; ++i) {
              if (!this.equals(oldArg[i], newArg[i]))
                return false;
            }
          } else if (typeof oldArg === "object" && typeof newArg === "object") {
            if (Object.keys(oldArg).length !== Object.keys(newArg).length)
              return false;
            for (const key in oldArg) {
              if (key !== "parent" && key !== "root" && (!(key in newArg) || !this.equals(oldArg[key], newArg[key])))
                return false;
            }
          } else if (oldArg !== newArg) {
            return false;
          }
          return true;
        }
      };
      exports.ThunkView = ThunkView;
      exports.ThunkView = ThunkView = __decorate([
        (0, inversify_1.injectable)()
      ], ThunkView);
      function isThunk(vnode) {
        return "thunk" in vnode;
      }
      exports.isThunk = isThunk;
    }
  });

  // node_modules/sprotty/lib/lib/jsx.js
  var require_jsx = __commonJS({
    "node_modules/sprotty/lib/lib/jsx.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JSX = exports.svg = exports.html = void 0;
      var snabbdom_1 = require_snabbdom_cjs();
      var modulesNS = ["hook", "on", "style", "class", "props", "attrs", "dataset"];
      var SVGNS = "http://www.w3.org/2000/svg";
      function normalizeAttrs(source, defNS, namespace) {
        const data = {};
        if (namespace) {
          data.ns = namespace;
        }
        if (source === null) {
          return data;
        }
        modulesNS.forEach((mod) => {
          if (source[mod]) {
            data[mod] = source[mod];
          }
        });
        Object.keys(source).forEach((key) => {
          if (key === "key" || key === "classNames" || key === "selector")
            return;
          const idx = key.indexOf("-");
          if (idx > 0)
            addAttr(key.slice(0, idx), key.slice(idx + 1), source[key]);
          else if (!data[key])
            addAttr(defNS, key, source[key]);
        });
        return data;
        function addAttr(modname, key, val) {
          const mod = data[modname] || (data[modname] = {});
          mod[key] = val;
        }
      }
      function JSX(namespace, defNS = "props") {
        return (tag, attrs, ...children) => (0, snabbdom_1.jsx)(tag, normalizeAttrs(attrs, defNS, namespace), children);
      }
      exports.JSX = JSX;
      var html = JSX();
      exports.html = html;
      var svg3 = JSX(SVGNS, "attrs");
      exports.svg = svg3;
    }
  });

  // node_modules/sprotty/lib/base/views/view.js
  var require_view = __commonJS({
    "node_modules/sprotty/lib/base/views/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MissingView = exports.EmptyView = exports.configureView = exports.configureModelElement = exports.ViewRegistry = exports.findArgValue = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var inversify_2 = require_inversify2();
      var smodel_factory_1 = require_smodel_factory();
      var smodel_utils_1 = require_smodel_utils();
      var sprotty_protocol_1 = require_lib();
      function findArgValue(arg, key) {
        while (arg !== void 0 && !(key in arg) && arg.parentArgs) {
          arg = arg.parentArgs;
        }
        return arg ? arg[key] : void 0;
      }
      exports.findArgValue = findArgValue;
      var ViewRegistry = class ViewRegistry extends registry_1.InstanceRegistry {
        constructor(registrations) {
          super();
          this.registerDefaults();
          registrations.forEach((registration) => this.register(registration.type, registration.factory()));
        }
        registerDefaults() {
          this.register(smodel_factory_1.EMPTY_ROOT.type, new EmptyView());
        }
        missing(key) {
          return new MissingView();
        }
      };
      exports.ViewRegistry = ViewRegistry;
      exports.ViewRegistry = ViewRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ViewRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ViewRegistry);
      function configureModelElement2(context, type, modelConstr, viewConstr, features) {
        (0, smodel_utils_1.registerModelElement)(context, type, modelConstr, features);
        configureView2(context, type, viewConstr);
      }
      exports.configureModelElement = configureModelElement2;
      function configureView2(context, type, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Views should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.ViewRegistration).toDynamicValue((ctx) => ({
          type,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureView = configureView2;
      var EmptyView = class EmptyView {
        render(model, context) {
          return (0, jsx_1.svg)("svg", { "class-sprotty-empty": true });
        }
      };
      exports.EmptyView = EmptyView;
      exports.EmptyView = EmptyView = __decorate([
        (0, inversify_1.injectable)()
      ], EmptyView);
      var MissingView = class MissingView {
        render(model, context) {
          const position = model.position || sprotty_protocol_1.Point.ORIGIN;
          return (0, jsx_1.svg)(
            "text",
            { "class-sprotty-missing": true, x: position.x, y: position.y },
            "?",
            model.id,
            "?"
          );
        }
      };
      exports.MissingView = MissingView;
      exports.MissingView = MissingView = __decorate([
        (0, inversify_1.injectable)()
      ], MissingView);
    }
  });

  // node_modules/sprotty/lib/base/views/viewer-cache.js
  var require_viewer_cache = __commonJS({
    "node_modules/sprotty/lib/base/views/viewer-cache.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewerCache = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var ViewerCache = class ViewerCache {
        update(model, cause) {
          if (cause !== void 0) {
            this.delegate.update(model, cause);
            this.cachedModel = void 0;
          } else {
            const isCacheEmpty = this.cachedModel === void 0;
            this.cachedModel = model;
            if (isCacheEmpty) {
              this.scheduleUpdate();
            }
          }
        }
        scheduleUpdate() {
          this.syncer.onEndOfNextFrame(() => {
            if (this.cachedModel) {
              this.delegate.update(this.cachedModel);
              this.cachedModel = void 0;
            }
          });
        }
      };
      exports.ViewerCache = ViewerCache;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IViewer),
        __metadata("design:type", Object)
      ], ViewerCache.prototype, "delegate", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], ViewerCache.prototype, "syncer", void 0);
      exports.ViewerCache = ViewerCache = __decorate([
        (0, inversify_1.injectable)()
      ], ViewerCache);
    }
  });

  // node_modules/sprotty/lib/base/views/viewer-options.js
  var require_viewer_options = __commonJS({
    "node_modules/sprotty/lib/base/views/viewer-options.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.overrideViewerOptions = exports.configureViewerOptions = exports.defaultViewerOptions = void 0;
      var object_1 = require_object();
      var types_1 = require_types();
      var defaultViewerOptions = () => ({
        baseDiv: "sprotty",
        baseClass: "sprotty",
        hiddenDiv: "sprotty-hidden",
        hiddenClass: "sprotty-hidden",
        popupDiv: "sprotty-popup",
        popupClass: "sprotty-popup",
        popupClosedClass: "sprotty-popup-closed",
        needsClientLayout: true,
        needsServerLayout: false,
        popupOpenDelay: 1e3,
        popupCloseDelay: 300,
        zoomLimits: { min: 0.01, max: 10 },
        horizontalScrollLimits: { min: -1e5, max: 1e5 },
        verticalScrollLimits: { min: -1e5, max: 1e5 }
      });
      exports.defaultViewerOptions = defaultViewerOptions;
      function configureViewerOptions2(context, options) {
        const opt = Object.assign(Object.assign({}, (0, exports.defaultViewerOptions)()), options);
        if (context.isBound(types_1.TYPES.ViewerOptions))
          context.rebind(types_1.TYPES.ViewerOptions).toConstantValue(opt);
        else
          context.bind(types_1.TYPES.ViewerOptions).toConstantValue(opt);
      }
      exports.configureViewerOptions = configureViewerOptions2;
      function overrideViewerOptions(container, options) {
        const opt = container.get(types_1.TYPES.ViewerOptions);
        (0, object_1.safeAssign)(opt, options);
        return opt;
      }
      exports.overrideViewerOptions = overrideViewerOptions;
    }
  });

  // node_modules/sprotty/lib/base/views/viewer.js
  var require_viewer = __commonJS({
    "node_modules/sprotty/lib/base/views/viewer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PopupModelViewer = exports.HiddenModelViewer = exports.ModelViewer = exports.PatcherProvider = exports.ModelRenderer = void 0;
      var inversify_1 = require_inversify();
      var snabbdom_1 = require_snabbdom_cjs();
      var jsx_1 = require_jsx();
      var browser_1 = require_browser();
      var initialize_canvas_1 = require_initialize_canvas();
      var smodel_factory_1 = require_smodel_factory();
      var types_1 = require_types();
      var thunk_view_1 = require_thunk_view();
      var vnode_utils_1 = require_vnode_utils();
      var ModelRenderer = class {
        constructor(viewRegistry, targetKind, postprocessors, args = {}) {
          this.viewRegistry = viewRegistry;
          this.targetKind = targetKind;
          this.postprocessors = postprocessors;
          this.args = args;
        }
        decorate(vnode, element) {
          if ((0, thunk_view_1.isThunk)(vnode)) {
            return vnode;
          }
          return this.postprocessors.reduce((n, processor) => processor.decorate(n, element), vnode);
        }
        renderElement(element) {
          const view = this.viewRegistry.get(element.type);
          const vnode = view.render(element, this, this.args);
          if (vnode) {
            return this.decorate(vnode, element);
          } else {
            return void 0;
          }
        }
        renderChildren(element, args) {
          const context = args ? new ModelRenderer(this.viewRegistry, this.targetKind, this.postprocessors, Object.assign(Object.assign({}, args), { parentArgs: this.args })) : this;
          return element.children.map((child) => context.renderElement(child)).filter((vnode) => vnode !== void 0);
        }
        postUpdate(cause) {
          this.postprocessors.forEach((processor) => processor.postUpdate(cause));
        }
      };
      exports.ModelRenderer = ModelRenderer;
      var PatcherProvider = class PatcherProvider {
        constructor() {
          this.patcher = (0, snabbdom_1.init)(this.createModules());
        }
        createModules() {
          return [
            snabbdom_1.propsModule,
            snabbdom_1.attributesModule,
            snabbdom_1.classModule,
            snabbdom_1.styleModule,
            snabbdom_1.eventListenersModule
          ];
        }
      };
      exports.PatcherProvider = PatcherProvider;
      exports.PatcherProvider = PatcherProvider = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [])
      ], PatcherProvider);
      var ModelViewer = class ModelViewer {
        constructor(modelRendererFactory, patcherProvider, postprocessors) {
          this.renderer = modelRendererFactory("main", postprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(model, cause) {
          this.logger.log(this, "rendering", model);
          const newVDOM = (0, jsx_1.html)("div", { id: this.options.baseDiv }, this.renderer.renderElement(model));
          if (this.lastVDOM !== void 0) {
            const hadFocus = this.hasFocus();
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastVDOM, newVDOM);
            this.lastVDOM = this.patcher.call(this, this.lastVDOM, newVDOM);
            this.restoreFocus(hadFocus);
          } else if (typeof document !== "undefined") {
            const placeholder = document.getElementById(this.options.baseDiv);
            if (placeholder !== null) {
              if (typeof window !== "undefined") {
                window.addEventListener("resize", () => {
                  this.onWindowResize(newVDOM);
                });
              }
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
              (0, vnode_utils_1.setClass)(newVDOM, this.options.baseClass, true);
              this.lastVDOM = this.patcher.call(this, placeholder, newVDOM);
            } else {
              this.logger.error(this, "element not in DOM:", this.options.baseDiv);
            }
          }
          this.renderer.postUpdate(cause);
        }
        hasFocus() {
          if (typeof document !== "undefined" && document.activeElement && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            const lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === "object") {
              const lastElement = lastRootVNode.elm;
              return document.activeElement === lastElement;
            }
          }
          return false;
        }
        restoreFocus(focus) {
          if (focus && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            const lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === "object") {
              const lastElement = lastRootVNode.elm;
              if (lastElement && typeof lastElement.focus === "function")
                lastElement.focus();
            }
          }
        }
        onWindowResize(vdom) {
          const baseDiv = document.getElementById(this.options.baseDiv);
          if (baseDiv !== null) {
            const newBounds = this.getBoundsInPage(baseDiv);
            this.actiondispatcher.dispatch(initialize_canvas_1.InitializeCanvasBoundsAction.create(newBounds));
          }
        }
        getBoundsInPage(element) {
          const bounds = element.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          return {
            x: bounds.left + scroll.x,
            y: bounds.top + scroll.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.ModelViewer = ModelViewer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ModelViewer.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], ModelViewer.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelViewer.prototype, "actiondispatcher", void 0);
      exports.ModelViewer = ModelViewer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.IVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], ModelViewer);
      var HiddenModelViewer = class HiddenModelViewer {
        constructor(modelRendererFactory, patcherProvider, hiddenPostprocessors) {
          this.hiddenRenderer = modelRendererFactory("hidden", hiddenPostprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(hiddenModel, cause) {
          this.logger.log(this, "rendering hidden");
          let newVDOM;
          if (hiddenModel.type === smodel_factory_1.EMPTY_ROOT.type) {
            newVDOM = (0, jsx_1.html)("div", { id: this.options.hiddenDiv });
          } else {
            const hiddenVNode = this.hiddenRenderer.renderElement(hiddenModel);
            if (hiddenVNode) {
              (0, vnode_utils_1.setAttr)(hiddenVNode, "opacity", 0);
            }
            newVDOM = (0, jsx_1.html)("div", { id: this.options.hiddenDiv }, hiddenVNode);
          }
          if (this.lastHiddenVDOM !== void 0) {
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastHiddenVDOM, newVDOM);
            this.lastHiddenVDOM = this.patcher.call(this, this.lastHiddenVDOM, newVDOM);
          } else {
            let placeholder = document.getElementById(this.options.hiddenDiv);
            if (placeholder === null) {
              placeholder = document.createElement("div");
              document.body.appendChild(placeholder);
            } else {
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
            }
            (0, vnode_utils_1.setClass)(newVDOM, this.options.baseClass, true);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.hiddenClass, true);
            this.lastHiddenVDOM = this.patcher.call(this, placeholder, newVDOM);
          }
          this.hiddenRenderer.postUpdate(cause);
        }
      };
      exports.HiddenModelViewer = HiddenModelViewer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], HiddenModelViewer.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], HiddenModelViewer.prototype, "logger", void 0);
      exports.HiddenModelViewer = HiddenModelViewer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.HiddenVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], HiddenModelViewer);
      var PopupModelViewer = class PopupModelViewer {
        constructor(modelRendererFactory, patcherProvider, popupPostprocessors) {
          this.modelRendererFactory = modelRendererFactory;
          this.popupRenderer = this.modelRendererFactory("popup", popupPostprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(model, cause) {
          this.logger.log(this, "rendering popup", model);
          const popupClosed = model.type === smodel_factory_1.EMPTY_ROOT.type;
          let newVDOM;
          if (popupClosed) {
            newVDOM = (0, jsx_1.html)("div", { id: this.options.popupDiv });
          } else {
            const position = model.canvasBounds;
            const inlineStyle = {
              top: position.y + "px",
              left: position.x + "px"
            };
            newVDOM = (0, jsx_1.html)("div", { id: this.options.popupDiv, style: inlineStyle }, this.popupRenderer.renderElement(model));
          }
          if (this.lastPopupVDOM !== void 0) {
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastPopupVDOM, newVDOM);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, this.lastPopupVDOM, newVDOM);
          } else if (typeof document !== "undefined") {
            let placeholder = document.getElementById(this.options.popupDiv);
            if (placeholder === null) {
              placeholder = document.createElement("div");
              document.body.appendChild(placeholder);
            } else {
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
            }
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClass, true);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, placeholder, newVDOM);
          }
          this.popupRenderer.postUpdate(cause);
        }
      };
      exports.PopupModelViewer = PopupModelViewer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], PopupModelViewer.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], PopupModelViewer.prototype, "logger", void 0);
      exports.PopupModelViewer = PopupModelViewer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.PopupVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], PopupModelViewer);
    }
  });

  // node_modules/sprotty/lib/base/views/vnode-postprocessor.js
  var require_vnode_postprocessor = __commonJS({
    "node_modules/sprotty/lib/base/views/vnode-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusFixPostprocessor = void 0;
      var inversify_1 = require_inversify();
      var vnode_utils_1 = require_vnode_utils();
      var FocusFixPostprocessor = class FocusFixPostprocessor {
        decorate(vnode, element) {
          if (vnode.sel && vnode.sel.startsWith("svg"))
            (0, vnode_utils_1.setAttr)(vnode, "tabindex", 0);
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.FocusFixPostprocessor = FocusFixPostprocessor;
      exports.FocusFixPostprocessor = FocusFixPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], FocusFixPostprocessor);
    }
  });

  // node_modules/sprotty/lib/utils/logging.js
  var require_logging = __commonJS({
    "node_modules/sprotty/lib/utils/logging.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConsoleLogger = exports.NullLogger = exports.LogLevel = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var LogLevel2;
      (function(LogLevel3) {
        LogLevel3[LogLevel3["none"] = 0] = "none";
        LogLevel3[LogLevel3["error"] = 1] = "error";
        LogLevel3[LogLevel3["warn"] = 2] = "warn";
        LogLevel3[LogLevel3["info"] = 3] = "info";
        LogLevel3[LogLevel3["log"] = 4] = "log";
      })(LogLevel2 || (exports.LogLevel = LogLevel2 = {}));
      var NullLogger = class NullLogger {
        constructor() {
          this.logLevel = LogLevel2.none;
        }
        error(thisArg, message, ...params) {
        }
        warn(thisArg, message, ...params) {
        }
        info(thisArg, message, ...params) {
        }
        log(thisArg, message, ...params) {
        }
      };
      exports.NullLogger = NullLogger;
      exports.NullLogger = NullLogger = __decorate([
        (0, inversify_1.injectable)()
      ], NullLogger);
      var ConsoleLogger2 = class ConsoleLogger {
        constructor() {
          this.logLevel = LogLevel2.log;
          this.viewOptions = { baseDiv: "" };
        }
        error(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.error)
            try {
              console.error.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        warn(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.warn)
            try {
              console.warn.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        info(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.info)
            try {
              console.info.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        log(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.log)
            try {
              console.log.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        consoleArguments(thisArg, message, params) {
          let caller;
          if (typeof thisArg === "object")
            caller = thisArg.constructor.name;
          else
            caller = thisArg;
          const date = /* @__PURE__ */ new Date();
          return [date.toLocaleTimeString() + " " + this.viewOptions.baseDiv + " " + caller + ": " + message, ...params];
        }
      };
      exports.ConsoleLogger = ConsoleLogger2;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LogLevel),
        __metadata("design:type", Number)
      ], ConsoleLogger2.prototype, "logLevel", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ConsoleLogger2.prototype, "viewOptions", void 0);
      exports.ConsoleLogger = ConsoleLogger2 = __decorate([
        (0, inversify_1.injectable)()
      ], ConsoleLogger2);
    }
  });

  // node_modules/sprotty/lib/base/views/id-postprocessor.js
  var require_id_postprocessor = __commonJS({
    "node_modules/sprotty/lib/base/views/id-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IdPostprocessor = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var dom_helper_1 = require_dom_helper();
      var vnode_utils_1 = require_vnode_utils();
      var IdPostprocessor = class IdPostprocessor {
        decorate(vnode, element) {
          const attrs = (0, vnode_utils_1.getAttrs)(vnode);
          if (attrs.id !== void 0)
            this.logger.warn(vnode, "Overriding id of vnode (" + attrs.id + "). Make sure not to set it manually in view.");
          attrs.id = this.domHelper.createUniqueDOMElementId(element);
          if (!vnode.key)
            vnode.key = element.id;
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.IdPostprocessor = IdPostprocessor;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], IdPostprocessor.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], IdPostprocessor.prototype, "domHelper", void 0);
      exports.IdPostprocessor = IdPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], IdPostprocessor);
    }
  });

  // node_modules/sprotty/lib/base/views/css-class-postprocessor.js
  var require_css_class_postprocessor = __commonJS({
    "node_modules/sprotty/lib/base/views/css-class-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CssClassPostprocessor = void 0;
      var model_utils_1 = require_model_utils();
      var vnode_utils_1 = require_vnode_utils();
      var inversify_1 = require_inversify();
      var CssClassPostprocessor = class CssClassPostprocessor {
        decorate(vnode, element) {
          if (element.cssClasses) {
            for (const cssClass of element.cssClasses)
              (0, vnode_utils_1.setClass)(vnode, cssClass, true);
          }
          const subType = (0, model_utils_1.getSubType)(element);
          if (subType && subType !== element.type) {
            (0, vnode_utils_1.setClass)(vnode, subType, true);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.CssClassPostprocessor = CssClassPostprocessor;
      exports.CssClassPostprocessor = CssClassPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], CssClassPostprocessor);
    }
  });

  // node_modules/sprotty/lib/base/di.config.js
  var require_di_config = __commonJS({
    "node_modules/sprotty/lib/base/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var initialize_canvas_1 = require_initialize_canvas();
      var logging_1 = require_logging();
      var action_dispatcher_1 = require_action_dispatcher();
      var action_handler_1 = require_action_handler();
      var command_stack_1 = require_command_stack();
      var smodel_factory_1 = require_smodel_factory();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var viewer_1 = require_viewer();
      var viewer_options_1 = require_viewer_options();
      var mouse_tool_1 = require_mouse_tool();
      var key_tool_1 = require_key_tool();
      var vnode_postprocessor_1 = require_vnode_postprocessor();
      var view_1 = require_view();
      var viewer_cache_1 = require_viewer_cache();
      var dom_helper_1 = require_dom_helper();
      var id_postprocessor_1 = require_id_postprocessor();
      var command_registration_1 = require_command_registration();
      var css_class_postprocessor_1 = require_css_class_postprocessor();
      var set_model_1 = require_set_model();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var diagram_locker_1 = require_diagram_locker();
      var defaultContainerModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(types_1.TYPES.ILogger).to(logging_1.NullLogger).inSingletonScope();
        bind(types_1.TYPES.LogLevel).toConstantValue(logging_1.LogLevel.warn);
        bind(types_1.TYPES.SModelRegistry).to(smodel_factory_1.SModelRegistry).inSingletonScope();
        bind(action_handler_1.ActionHandlerRegistry).toSelf().inSingletonScope();
        bind(types_1.TYPES.ActionHandlerRegistryProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(action_handler_1.ActionHandlerRegistry));
            });
          };
        });
        bind(types_1.TYPES.ViewRegistry).to(view_1.ViewRegistry).inSingletonScope();
        bind(types_1.TYPES.IModelFactory).to(smodel_factory_1.SModelFactory).inSingletonScope();
        bind(types_1.TYPES.IActionDispatcher).to(action_dispatcher_1.ActionDispatcher).inSingletonScope();
        bind(types_1.TYPES.IActionDispatcherProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(types_1.TYPES.IActionDispatcher));
            });
          };
        });
        bind(types_1.TYPES.IDiagramLocker).to(diagram_locker_1.DefaultDiagramLocker).inSingletonScope();
        bind(types_1.TYPES.IActionHandlerInitializer).to(command_registration_1.CommandActionHandlerInitializer);
        bind(types_1.TYPES.ICommandStack).to(command_stack_1.CommandStack).inSingletonScope();
        bind(types_1.TYPES.ICommandStackProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(types_1.TYPES.ICommandStack));
            });
          };
        });
        bind(types_1.TYPES.CommandStackOptions).toConstantValue({
          defaultDuration: 250,
          undoHistoryLimit: 50
        });
        bind(viewer_1.ModelViewer).toSelf().inSingletonScope();
        bind(viewer_1.HiddenModelViewer).toSelf().inSingletonScope();
        bind(viewer_1.PopupModelViewer).toSelf().inSingletonScope();
        bind(types_1.TYPES.ModelViewer).toDynamicValue((ctx) => {
          const container = ctx.container.createChild();
          container.bind(types_1.TYPES.IViewer).toService(viewer_1.ModelViewer);
          container.bind(viewer_cache_1.ViewerCache).toSelf();
          return container.get(viewer_cache_1.ViewerCache);
        }).inSingletonScope();
        bind(types_1.TYPES.PopupModelViewer).toDynamicValue((ctx) => {
          const container = ctx.container.createChild();
          container.bind(types_1.TYPES.IViewer).toService(viewer_1.PopupModelViewer);
          container.bind(viewer_cache_1.ViewerCache).toSelf();
          return container.get(viewer_cache_1.ViewerCache);
        }).inSingletonScope();
        bind(types_1.TYPES.HiddenModelViewer).toService(viewer_1.HiddenModelViewer);
        bind(types_1.TYPES.IViewerProvider).toDynamicValue((ctx) => {
          return {
            get modelViewer() {
              return ctx.container.get(types_1.TYPES.ModelViewer);
            },
            get hiddenModelViewer() {
              return ctx.container.get(types_1.TYPES.HiddenModelViewer);
            },
            get popupModelViewer() {
              return ctx.container.get(types_1.TYPES.PopupModelViewer);
            }
          };
        });
        bind(types_1.TYPES.ViewerOptions).toConstantValue((0, viewer_options_1.defaultViewerOptions)());
        bind(types_1.TYPES.PatcherProvider).to(viewer_1.PatcherProvider).inSingletonScope();
        bind(types_1.TYPES.DOMHelper).to(dom_helper_1.DOMHelper).inSingletonScope();
        bind(types_1.TYPES.ModelRendererFactory).toFactory((ctx) => {
          return (targetKind, processors, args = {}) => {
            const viewRegistry = ctx.container.get(types_1.TYPES.ViewRegistry);
            return new viewer_1.ModelRenderer(viewRegistry, targetKind, processors, args);
          };
        });
        bind(id_postprocessor_1.IdPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(css_class_postprocessor_1.CssClassPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(css_class_postprocessor_1.CssClassPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(css_class_postprocessor_1.CssClassPostprocessor);
        bind(mouse_tool_1.MouseTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(mouse_tool_1.MouseTool);
        bind(key_tool_1.KeyTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(key_tool_1.KeyTool);
        bind(vnode_postprocessor_1.FocusFixPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(vnode_postprocessor_1.FocusFixPostprocessor);
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(mouse_tool_1.PopupMouseTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(mouse_tool_1.PopupMouseTool);
        bind(types_1.TYPES.AnimationFrameSyncer).to(animation_frame_syncer_1.AnimationFrameSyncer).inSingletonScope();
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, initialize_canvas_1.InitializeCanvasBoundsCommand);
        bind(initialize_canvas_1.CanvasBoundsInitializer).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(initialize_canvas_1.CanvasBoundsInitializer);
        (0, command_registration_1.configureCommand)(context, set_model_1.SetModelCommand);
        bind(types_1.TYPES.UIExtensionRegistry).to(ui_extension_registry_1.UIExtensionRegistry).inSingletonScope();
        (0, command_registration_1.configureCommand)(context, ui_extension_registry_1.SetUIExtensionVisibilityCommand);
        bind(mouse_tool_1.MousePositionTracker).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(mouse_tool_1.MousePositionTracker);
      });
      exports.default = defaultContainerModule;
    }
  });

  // node_modules/sprotty/lib/features/bounds/model.js
  var require_model2 = __commonJS({
    "node_modules/sprotty/lib/features/bounds/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SShapeElementImpl = exports.findChildrenAtPosition = exports.getAbsoluteClientBounds = exports.getAbsoluteBounds = exports.isAlignable = exports.isSizeable = exports.isLayoutableChild = exports.isLayoutContainer = exports.isBoundsAware = exports.alignFeature = exports.layoutableChildFeature = exports.layoutContainerFeature = exports.boundsFeature = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var browser_1 = require_browser();
      exports.boundsFeature = Symbol("boundsFeature");
      exports.layoutContainerFeature = Symbol("layoutContainerFeature");
      exports.layoutableChildFeature = Symbol("layoutableChildFeature");
      exports.alignFeature = Symbol("alignFeature");
      function isBoundsAware3(element) {
        return "bounds" in element;
      }
      exports.isBoundsAware = isBoundsAware3;
      function isLayoutContainer(element) {
        return isBoundsAware3(element) && element.hasFeature(exports.layoutContainerFeature) && "layout" in element;
      }
      exports.isLayoutContainer = isLayoutContainer;
      function isLayoutableChild(element) {
        return isBoundsAware3(element) && element.hasFeature(exports.layoutableChildFeature);
      }
      exports.isLayoutableChild = isLayoutableChild;
      function isSizeable(element) {
        return element.hasFeature(exports.boundsFeature) && isBoundsAware3(element);
      }
      exports.isSizeable = isSizeable;
      function isAlignable(element) {
        return element.hasFeature(exports.alignFeature) && "alignment" in element;
      }
      exports.isAlignable = isAlignable;
      function getAbsoluteBounds(element) {
        const boundsAware = (0, smodel_utils_1.findParentByFeature)(element, isBoundsAware3);
        if (boundsAware !== void 0) {
          let bounds = boundsAware.bounds;
          let current = boundsAware;
          while (current instanceof smodel_1.SChildElementImpl) {
            const parent = current.parent;
            bounds = parent.localToParent(bounds);
            current = parent;
          }
          return bounds;
        } else if (element instanceof smodel_1.SModelRootImpl) {
          const canvasBounds = element.canvasBounds;
          return { x: 0, y: 0, width: canvasBounds.width, height: canvasBounds.height };
        } else {
          return geometry_1.Bounds.EMPTY;
        }
      }
      exports.getAbsoluteBounds = getAbsoluteBounds;
      function getAbsoluteClientBounds(element, domHelper, viewerOptions) {
        let x = 0;
        let y = 0;
        let width = 0;
        let height = 0;
        const svgElementId = domHelper.createUniqueDOMElementId(element);
        const svgElement = document.getElementById(svgElementId);
        if (svgElement) {
          const rect = svgElement.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          x = rect.left + scroll.x;
          y = rect.top + scroll.y;
          width = rect.width;
          height = rect.height;
        }
        let container = document.getElementById(viewerOptions.baseDiv);
        if (container) {
          while (container.offsetParent instanceof HTMLElement && (container = container.offsetParent)) {
            x -= container.offsetLeft;
            y -= container.offsetTop;
          }
        }
        return { x, y, width, height };
      }
      exports.getAbsoluteClientBounds = getAbsoluteClientBounds;
      function findChildrenAtPosition2(parent, point) {
        const matches = [];
        doFindChildrenAtPosition(parent, point, matches);
        return matches;
      }
      exports.findChildrenAtPosition = findChildrenAtPosition2;
      function doFindChildrenAtPosition(parent, point, matches) {
        parent.children.forEach((child) => {
          if (isBoundsAware3(child) && geometry_1.Bounds.includes(child.bounds, point))
            matches.push(child);
          if (child instanceof smodel_1.SParentElementImpl) {
            const newPoint = child.parentToLocal(point);
            doFindChildrenAtPosition(child, newPoint, matches);
          }
        });
      }
      var SShapeElementImpl = class extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
        localToParent(point) {
          const result = {
            x: point.x + this.position.x,
            y: point.y + this.position.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
        parentToLocal(point) {
          const result = {
            x: point.x - this.position.x,
            y: point.y - this.position.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
      };
      exports.SShapeElementImpl = SShapeElementImpl;
    }
  });

  // node_modules/sprotty/lib/features/bounds/bounds-manipulation.js
  var require_bounds_manipulation = __commonJS({
    "node_modules/sprotty/lib/features/bounds/bounds-manipulation.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RequestBoundsCommand = exports.SetBoundsCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_1 = require_model2();
      var SetBoundsCommand = class SetBoundsCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
          this.bounds = [];
        }
        execute(context) {
          this.action.bounds.forEach((b) => {
            const element = context.root.index.getById(b.elementId);
            if (element && (0, model_1.isBoundsAware)(element)) {
              this.bounds.push({
                element,
                oldBounds: element.bounds,
                newPosition: b.newPosition,
                newSize: b.newSize
              });
            }
          });
          return this.redo(context);
        }
        undo(context) {
          this.bounds.forEach((b) => b.element.bounds = b.oldBounds);
          return context.root;
        }
        redo(context) {
          this.bounds.forEach((b) => {
            if (b.newPosition)
              b.element.bounds = Object.assign(Object.assign({}, b.newPosition), b.newSize);
            else
              b.element.bounds = Object.assign({ x: b.element.bounds.x, y: b.element.bounds.y }, b.newSize);
          });
          return context.root;
        }
      };
      exports.SetBoundsCommand = SetBoundsCommand;
      SetBoundsCommand.KIND = actions_1.SetBoundsAction.KIND;
      exports.SetBoundsCommand = SetBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetBoundsCommand);
      var RequestBoundsCommand = class RequestBoundsCommand extends command_1.HiddenCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          return {
            model: context.modelFactory.createRoot(this.action.newRoot),
            modelChanged: true,
            cause: this.action
          };
        }
        get blockUntil() {
          return (action) => action.kind === actions_1.ComputedBoundsAction.KIND;
        }
      };
      exports.RequestBoundsCommand = RequestBoundsCommand;
      RequestBoundsCommand.KIND = actions_1.RequestBoundsAction.KIND;
      exports.RequestBoundsCommand = RequestBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], RequestBoundsCommand);
    }
  });

  // node_modules/sprotty/lib/features/bounds/layout.js
  var require_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureLayout = exports.StatefulLayouter = exports.Layouter = exports.LayoutRegistry = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var model_1 = require_model2();
      var inversify_2 = require_inversify2();
      var LayoutRegistry = class LayoutRegistry extends registry_1.InstanceRegistry {
        constructor(layouts = []) {
          super();
          layouts.forEach((layout) => {
            if (this.hasKey(layout.layoutKind)) {
              this.logger.warn("Layout kind is already defined: ", layout.layoutKind);
            } else {
              this.register(layout.layoutKind, layout.factory());
            }
          });
        }
      };
      exports.LayoutRegistry = LayoutRegistry;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], LayoutRegistry.prototype, "logger", void 0);
      exports.LayoutRegistry = LayoutRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.LayoutRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], LayoutRegistry);
      var Layouter = class Layouter {
        layout(element2boundsData) {
          new StatefulLayouter(element2boundsData, this.layoutRegistry, this.logger).layout();
        }
      };
      exports.Layouter = Layouter;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LayoutRegistry),
        __metadata("design:type", LayoutRegistry)
      ], Layouter.prototype, "layoutRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], Layouter.prototype, "logger", void 0);
      exports.Layouter = Layouter = __decorate([
        (0, inversify_1.injectable)()
      ], Layouter);
      var StatefulLayouter = class {
        constructor(element2boundsData, layoutRegistry, log) {
          this.element2boundsData = element2boundsData;
          this.layoutRegistry = layoutRegistry;
          this.log = log;
          this.toBeLayouted = [];
          element2boundsData.forEach((data, element) => {
            if ((0, model_1.isLayoutContainer)(element))
              this.toBeLayouted.push(element);
          });
        }
        getBoundsData(element) {
          let boundsData = this.element2boundsData.get(element);
          let bounds = element.bounds;
          if ((0, model_1.isLayoutContainer)(element) && this.toBeLayouted.indexOf(element) >= 0) {
            bounds = this.doLayout(element);
          }
          if (!boundsData) {
            boundsData = {
              bounds,
              boundsChanged: false,
              alignmentChanged: false
            };
            this.element2boundsData.set(element, boundsData);
          }
          return boundsData;
        }
        layout() {
          while (this.toBeLayouted.length > 0) {
            const element = this.toBeLayouted[0];
            this.doLayout(element);
          }
        }
        doLayout(element) {
          const index = this.toBeLayouted.indexOf(element);
          if (index >= 0)
            this.toBeLayouted.splice(index, 1);
          const layout = this.layoutRegistry.get(element.layout);
          if (layout)
            layout.layout(element, this);
          const boundsData = this.element2boundsData.get(element);
          if (boundsData !== void 0 && boundsData.bounds !== void 0) {
            return boundsData.bounds;
          } else {
            this.log.error(element, "Layout failed");
            return geometry_1.Bounds.EMPTY;
          }
        }
      };
      exports.StatefulLayouter = StatefulLayouter;
      function configureLayout(context, kind, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Layouts be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.LayoutRegistration).toDynamicValue((ctx) => ({
          layoutKind: kind,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureLayout = configureLayout;
    }
  });

  // node_modules/sprotty/lib/features/bounds/hidden-bounds-updater.js
  var require_hidden_bounds_updater = __commonJS({
    "node_modules/sprotty/lib/features/bounds/hidden-bounds-updater.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATTR_BBOX_ELEMENT = exports.HiddenBoundsUpdater = exports.BoundsData = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var browser_1 = require_browser();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var layout_1 = require_layout();
      var model_1 = require_model2();
      var BoundsData = class {
      };
      exports.BoundsData = BoundsData;
      var HiddenBoundsUpdater = class HiddenBoundsUpdater {
        constructor() {
          this.element2boundsData = /* @__PURE__ */ new Map();
        }
        decorate(vnode, element) {
          if ((0, model_1.isSizeable)(element) || (0, model_1.isLayoutContainer)(element)) {
            this.element2boundsData.set(element, {
              vnode,
              bounds: element.bounds,
              boundsChanged: false,
              alignmentChanged: false
            });
          }
          if (element instanceof smodel_1.SModelRootImpl) {
            this.root = element;
          }
          return vnode;
        }
        postUpdate(cause) {
          if (cause === void 0 || cause.kind !== actions_1.RequestBoundsAction.KIND) {
            return;
          }
          const request = cause;
          this.getBoundsFromDOM();
          this.layouter.layout(this.element2boundsData);
          const resizes = [];
          const alignments = [];
          this.element2boundsData.forEach((boundsData, element) => {
            if (boundsData.boundsChanged && boundsData.bounds !== void 0) {
              const resize = {
                elementId: element.id,
                newSize: {
                  width: boundsData.bounds.width,
                  height: boundsData.bounds.height
                }
              };
              if (element instanceof smodel_1.SChildElementImpl && (0, model_1.isLayoutContainer)(element.parent)) {
                resize.newPosition = {
                  x: boundsData.bounds.x,
                  y: boundsData.bounds.y
                };
              }
              resizes.push(resize);
            }
            if (boundsData.alignmentChanged && boundsData.alignment !== void 0) {
              alignments.push({
                elementId: element.id,
                newAlignment: boundsData.alignment
              });
            }
          });
          const revision = this.root !== void 0 ? this.root.revision : void 0;
          this.actionDispatcher.dispatch(actions_1.ComputedBoundsAction.create(resizes, { revision, alignments, requestId: request.requestId }));
          this.element2boundsData.clear();
        }
        getBoundsFromDOM() {
          this.element2boundsData.forEach((boundsData, element) => {
            if (boundsData.bounds && (0, model_1.isSizeable)(element)) {
              const vnode = boundsData.vnode;
              if (vnode && vnode.elm) {
                const boundingBox = this.getBounds(vnode.elm, element);
                if ((0, model_1.isAlignable)(element) && !((0, geometry_1.almostEquals)(boundingBox.x, 0) && (0, geometry_1.almostEquals)(boundingBox.y, 0))) {
                  boundsData.alignment = {
                    x: -boundingBox.x,
                    y: -boundingBox.y
                  };
                  boundsData.alignmentChanged = true;
                }
                const newBounds = {
                  x: element.bounds.x,
                  y: element.bounds.y,
                  width: boundingBox.width,
                  height: boundingBox.height
                };
                if (!((0, geometry_1.almostEquals)(newBounds.x, element.bounds.x) && (0, geometry_1.almostEquals)(newBounds.y, element.bounds.y) && (0, geometry_1.almostEquals)(newBounds.width, element.bounds.width) && (0, geometry_1.almostEquals)(newBounds.height, element.bounds.height))) {
                  boundsData.bounds = newBounds;
                  boundsData.boundsChanged = true;
                }
              }
            }
          });
        }
        /**
         * Compute the bounds of the given DOM element. Override this method to customize how
         * the bounding box of a rendered view is determined.
         *
         * In case your Sprotty model element contains children that are rendered outside of
         * their parent, you can add the `ATTR_BBOX_ELEMENT` attribute to the SVG element
         * that shall be used to compute the bounding box.
         */
        getBounds(elm, element) {
          if (!(0, browser_1.isSVGGraphicsElement)(elm)) {
            this.logger.error(this, "Not an SVG element:", elm);
            return geometry_1.Bounds.EMPTY;
          }
          if (elm.tagName === "g") {
            for (const child of Array.from(elm.children)) {
              if (child.getAttribute(exports.ATTR_BBOX_ELEMENT) !== null) {
                return this.getBounds(child, element);
              }
            }
          }
          const bounds = elm.getBBox();
          return {
            x: bounds.x,
            y: bounds.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.HiddenBoundsUpdater = HiddenBoundsUpdater;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], HiddenBoundsUpdater.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], HiddenBoundsUpdater.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.Layouter),
        __metadata("design:type", layout_1.Layouter)
      ], HiddenBoundsUpdater.prototype, "layouter", void 0);
      exports.HiddenBoundsUpdater = HiddenBoundsUpdater = __decorate([
        (0, inversify_1.injectable)()
      ], HiddenBoundsUpdater);
      exports.ATTR_BBOX_ELEMENT = "bboxElement";
    }
  });

  // node_modules/sprotty/lib/features/bounds/abstract-layout.js
  var require_abstract_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/abstract-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractLayout = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var inversify_1 = require_inversify();
      var AbstractLayout = class AbstractLayout {
        layout(container, layouter) {
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const maxWidth = options.paddingFactor * (options.resizeContainer ? childrenSize.width : Math.max(0, this.getFixedContainerBounds(container, options, layouter).width) - options.paddingLeft - options.paddingRight);
          const maxHeight = options.paddingFactor * (options.resizeContainer ? childrenSize.height : Math.max(0, this.getFixedContainerBounds(container, options, layouter).height) - options.paddingTop - options.paddingBottom);
          if (maxWidth > 0 && maxHeight > 0) {
            const offset = this.layoutChildren(container, layouter, options, maxWidth, maxHeight);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, maxWidth, maxHeight);
            boundsData.boundsChanged = true;
          }
        }
        getFinalContainerBounds(container, lastOffset, options, maxWidth, maxHeight) {
          return {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(options.minWidth, maxWidth + options.paddingLeft + options.paddingRight),
            height: Math.max(options.minHeight, maxHeight + options.paddingTop + options.paddingBottom)
          };
        }
        getFixedContainerBounds(container, layoutOptions, layouter) {
          let currentContainer = container;
          while (true) {
            if ((0, model_1.isBoundsAware)(currentContainer)) {
              const bounds = currentContainer.bounds;
              if ((0, model_1.isLayoutContainer)(currentContainer) && layoutOptions.resizeContainer)
                layouter.log.error(currentContainer, "Resizable container found while detecting fixed bounds");
              if (geometry_1.Dimension.isValid(bounds))
                return bounds;
            }
            if (currentContainer instanceof smodel_1.SChildElementImpl) {
              currentContainer = currentContainer.parent;
            } else {
              layouter.log.error(currentContainer, "Cannot detect fixed bounds");
              return geometry_1.Bounds.EMPTY;
            }
          }
        }
        layoutChildren(container, layouter, containerOptions, maxWidth, maxHeight) {
          let currentOffset = {
            x: containerOptions.paddingLeft + 0.5 * (maxWidth - maxWidth / containerOptions.paddingFactor),
            y: containerOptions.paddingTop + 0.5 * (maxHeight - maxHeight / containerOptions.paddingFactor)
          };
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const boundsData = layouter.getBoundsData(child);
              const bounds = boundsData.bounds;
              const childOptions = this.getChildLayoutOptions(child, containerOptions);
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                currentOffset = this.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight);
              }
            }
          });
          return currentOffset;
        }
        getDx(hAlign, bounds, maxWidth) {
          switch (hAlign) {
            case "left":
              return 0;
            case "center":
              return 0.5 * (maxWidth - bounds.width);
            case "right":
              return maxWidth - bounds.width;
          }
        }
        getDy(vAlign, bounds, maxHeight) {
          switch (vAlign) {
            case "top":
              return 0;
            case "center":
              return 0.5 * (maxHeight - bounds.height);
            case "bottom":
              return maxHeight - bounds.height;
          }
        }
        getChildLayoutOptions(child, containerOptions) {
          const layoutOptions = child.layoutOptions;
          if (layoutOptions === void 0)
            return containerOptions;
          else
            return this.spread(containerOptions, layoutOptions);
        }
        getLayoutOptions(element) {
          let current = element;
          const allOptions = [];
          while (current !== void 0) {
            const layoutOptions = current.layoutOptions;
            if (layoutOptions !== void 0)
              allOptions.push(layoutOptions);
            if (current instanceof smodel_1.SChildElementImpl)
              current = current.parent;
            else
              break;
          }
          return allOptions.reverse().reduce((a, b) => {
            return this.spread(a, b);
          }, this.getDefaultLayoutOptions());
        }
      };
      exports.AbstractLayout = AbstractLayout;
      exports.AbstractLayout = AbstractLayout = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractLayout);
    }
  });

  // node_modules/sprotty/lib/features/bounds/vbox-layout.js
  var require_vbox_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/vbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VBoxLayouter = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var VBoxLayouter = class VBoxLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = -1;
          let maxHeight = 0;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                maxHeight += bounds.height;
                if (isFirst)
                  isFirst = false;
                else
                  maxHeight += containerOptions.vGap;
                maxWidth = Math.max(maxWidth, bounds.width);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dx = this.getDx(childOptions.hAlign, bounds, maxWidth);
          boundsData.bounds = {
            x: containerOptions.paddingLeft + child.bounds.x - bounds.x + dx,
            y: currentOffset.y + child.bounds.y - bounds.y,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return {
            x: currentOffset.x,
            y: currentOffset.y + bounds.height + containerOptions.vGap
          };
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            vGap: 1,
            hAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a, b) {
          return Object.assign(Object.assign({}, a), b);
        }
      };
      exports.VBoxLayouter = VBoxLayouter;
      VBoxLayouter.KIND = "vbox";
      exports.VBoxLayouter = VBoxLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], VBoxLayouter);
    }
  });

  // node_modules/sprotty/lib/features/bounds/hbox-layout.js
  var require_hbox_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/hbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HBoxLayouter = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var HBoxLayouter = class HBoxLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = 0;
          let maxHeight = -1;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                if (isFirst)
                  isFirst = false;
                else
                  maxWidth += containerOptions.hGap;
                maxWidth += bounds.width;
                maxHeight = Math.max(maxHeight, bounds.height);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dy = this.getDy(childOptions.vAlign, bounds, maxHeight);
          boundsData.bounds = {
            x: currentOffset.x + child.bounds.x - bounds.x,
            y: containerOptions.paddingTop + child.bounds.y - bounds.y + dy,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return {
            x: currentOffset.x + bounds.width + containerOptions.hGap,
            y: currentOffset.y
          };
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            hGap: 1,
            vAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a, b) {
          return Object.assign(Object.assign({}, a), b);
        }
      };
      exports.HBoxLayouter = HBoxLayouter;
      HBoxLayouter.KIND = "hbox";
      exports.HBoxLayouter = HBoxLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], HBoxLayouter);
    }
  });

  // node_modules/sprotty/lib/features/bounds/stack-layout.js
  var require_stack_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/stack-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StackLayouter = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var StackLayouter = class StackLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, options, layouter) {
          let maxWidth = -1;
          let maxHeight = -1;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                maxWidth = Math.max(maxWidth, bounds.width);
                maxHeight = Math.max(maxHeight, bounds.height);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dx = this.getDx(childOptions.hAlign, bounds, maxWidth);
          const dy = this.getDy(childOptions.vAlign, bounds, maxHeight);
          boundsData.bounds = {
            x: containerOptions.paddingLeft + child.bounds.x - bounds.x + dx,
            y: containerOptions.paddingTop + child.bounds.y - bounds.y + dy,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return currentOffset;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            hAlign: "center",
            vAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a, b) {
          return Object.assign(Object.assign({}, a), b);
        }
      };
      exports.StackLayouter = StackLayouter;
      StackLayouter.KIND = "stack";
      exports.StackLayouter = StackLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], StackLayouter);
    }
  });

  // node_modules/sprotty/lib/features/bounds/views.js
  var require_views = __commonJS({
    "node_modules/sprotty/lib/features/bounds/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShapeView = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var model_1 = require_model2();
      var ShapeView2 = class ShapeView {
        /**
         * Check whether the given model element is in the current viewport. Use this method
         * in your `render` implementation to skip rendering in case the element is not visible.
         * This can greatly enhance performance for large models.
         */
        isVisible(model, context) {
          if (context.targetKind === "hidden") {
            return true;
          }
          if (!geometry_1.Dimension.isValid(model.bounds)) {
            return true;
          }
          const ab = (0, model_1.getAbsoluteBounds)(model);
          const canvasBounds = model.root.canvasBounds;
          return ab.x <= canvasBounds.width && ab.x + ab.width >= 0 && ab.y <= canvasBounds.height && ab.y + ab.height >= 0;
        }
      };
      exports.ShapeView = ShapeView2;
      exports.ShapeView = ShapeView2 = __decorate([
        (0, inversify_1.injectable)()
      ], ShapeView2);
    }
  });

  // node_modules/sprotty/lib/features/button/button-handler.js
  var require_button_handler = __commonJS({
    "node_modules/sprotty/lib/features/button/button-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureButtonHandler = exports.ButtonHandlerRegistry = void 0;
      var inversify_1 = require_inversify();
      var registry_1 = require_registry();
      var types_1 = require_types();
      var inversify_2 = require_inversify2();
      var ButtonHandlerRegistry2 = class ButtonHandlerRegistry extends registry_1.InstanceRegistry {
        constructor(buttonHandlerRegistrations) {
          super();
          buttonHandlerRegistrations.forEach((factory) => this.register(factory.TYPE, factory.factory()));
        }
      };
      exports.ButtonHandlerRegistry = ButtonHandlerRegistry2;
      exports.ButtonHandlerRegistry = ButtonHandlerRegistry2 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IButtonHandlerRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ButtonHandlerRegistry2);
      function configureButtonHandler(context, type, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Button handlers should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.IButtonHandlerRegistration).toDynamicValue((ctx) => ({
          TYPE: type,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureButtonHandler = configureButtonHandler;
    }
  });

  // node_modules/sprotty/lib/features/fade/model.js
  var require_model3 = __commonJS({
    "node_modules/sprotty/lib/features/fade/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isFadeable = exports.fadeFeature = void 0;
      exports.fadeFeature = Symbol("fadeFeature");
      function isFadeable(element) {
        return element.hasFeature(exports.fadeFeature) && element["opacity"] !== void 0;
      }
      exports.isFadeable = isFadeable;
    }
  });

  // node_modules/sprotty/lib/features/button/model.js
  var require_model4 = __commonJS({
    "node_modules/sprotty/lib/features/button/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SButtonImpl = void 0;
      var model_1 = require_model2();
      var model_2 = require_model3();
      var SButtonImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.enabled = true;
        }
      };
      exports.SButtonImpl = SButtonImpl;
      SButtonImpl.DEFAULT_FEATURES = [model_1.boundsFeature, model_1.layoutableChildFeature, model_2.fadeFeature];
    }
  });

  // node_modules/sprotty/lib/features/nameable/model.js
  var require_model5 = __commonJS({
    "node_modules/sprotty/lib/features/nameable/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.name = exports.isNameable = exports.nameFeature = void 0;
      exports.nameFeature = Symbol("nameableFeature");
      function isNameable(element) {
        return element.hasFeature(exports.nameFeature);
      }
      exports.isNameable = isNameable;
      function name(element) {
        if (isNameable(element)) {
          return element.name;
        } else {
          return void 0;
        }
      }
      exports.name = name;
    }
  });

  // node_modules/sprotty/lib/features/command-palette/action-providers.js
  var require_action_providers = __commonJS({
    "node_modules/sprotty/lib/features/command-palette/action-providers.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RevealNamedElementActionProvider = exports.CommandPaletteActionProviderRegistry = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var action_1 = require_action();
      var types_1 = require_types();
      var iterable_1 = require_iterable();
      var model_1 = require_model5();
      var CommandPaletteActionProviderRegistry = class CommandPaletteActionProviderRegistry {
        constructor(actionProviders = []) {
          this.actionProviders = actionProviders;
        }
        getActions(root, text, lastMousePosition, index) {
          const actionLists = this.actionProviders.map((provider) => provider.getActions(root, text, lastMousePosition, index));
          return Promise.all(actionLists).then((p) => p.reduce((acc, promise) => promise !== void 0 ? acc.concat(promise) : acc));
        }
      };
      exports.CommandPaletteActionProviderRegistry = CommandPaletteActionProviderRegistry;
      exports.CommandPaletteActionProviderRegistry = CommandPaletteActionProviderRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ICommandPaletteActionProvider)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], CommandPaletteActionProviderRegistry);
      var RevealNamedElementActionProvider = class RevealNamedElementActionProvider {
        constructor(logger) {
          this.logger = logger;
        }
        getActions(root, text, lastMousePosition, index) {
          if (index !== void 0 && index % 2 === 0)
            return Promise.resolve(this.createSelectActions(root));
          else
            return Promise.resolve([new action_1.LabeledAction("Select all", [actions_1.SelectAllAction.create()])]);
        }
        createSelectActions(modelRoot) {
          const nameables = (0, iterable_1.toArray)(modelRoot.index.all().filter((element) => (0, model_1.isNameable)(element)));
          return nameables.map((nameable) => new action_1.LabeledAction(`Reveal ${(0, model_1.name)(nameable)}`, [actions_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), actions_1.CenterAction.create([nameable.id])], "eye"));
        }
      };
      exports.RevealNamedElementActionProvider = RevealNamedElementActionProvider;
      exports.RevealNamedElementActionProvider = RevealNamedElementActionProvider = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ILogger)),
        __metadata("design:paramtypes", [Object])
      ], RevealNamedElementActionProvider);
    }
  });

  // node_modules/sprotty/lib/utils/codicon.js
  var require_codicon = __commonJS({
    "node_modules/sprotty/lib/utils/codicon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.codiconCSSClasses = exports.codiconCSSString = exports.ANIMATION_SPIN = exports.ACTION_ITEM = void 0;
      exports.ACTION_ITEM = "action-item";
      exports.ANIMATION_SPIN = "animation-spin";
      function codiconCSSString(codiconId, actionItem = false, animationSpin = false, additionalCSS = []) {
        return codiconCSSClasses(codiconId, actionItem, animationSpin, additionalCSS).join(" ");
      }
      exports.codiconCSSString = codiconCSSString;
      function codiconCSSClasses(codiconId, actionItem = false, animationSpin = false, additionalCSS = []) {
        const cssClassArray = ["codicon", `codicon-${codiconId}`];
        if (actionItem) {
          cssClassArray.push(exports.ACTION_ITEM);
        }
        if (animationSpin) {
          cssClassArray.push(exports.ANIMATION_SPIN);
        }
        if (additionalCSS.length > 0) {
          cssClassArray.push(...additionalCSS);
        }
        return cssClassArray;
      }
      exports.codiconCSSClasses = codiconCSSClasses;
    }
  });

  // node_modules/sprotty/lib/utils/keyboard.js
  var require_keyboard = __commonJS({
    "node_modules/sprotty/lib/utils/keyboard.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getActualCode = exports.matchesKeystroke = void 0;
      var browser_1 = require_browser();
      function matchesKeystroke(event, code, ...modifiers) {
        if (getActualCode(event) !== code)
          return false;
        if ((0, browser_1.isMac)()) {
          if (event.ctrlKey !== modifiers.findIndex((m) => m === "ctrl") >= 0)
            return false;
          if (event.metaKey !== modifiers.findIndex((m) => m === "meta" || m === "ctrlCmd") >= 0)
            return false;
        } else {
          if (event.ctrlKey !== modifiers.findIndex((m) => m === "ctrl" || m === "ctrlCmd") >= 0)
            return false;
          if (event.metaKey !== modifiers.findIndex((m) => m === "meta") >= 0)
            return false;
        }
        if (event.altKey !== modifiers.findIndex((m) => m === "alt") >= 0)
          return false;
        if (event.shiftKey !== modifiers.findIndex((m) => m === "shift") >= 0)
          return false;
        return true;
      }
      exports.matchesKeystroke = matchesKeystroke;
      function getActualCode(event) {
        if (event.keyCode) {
          const result = STRING_CODE[event.keyCode];
          if (result !== void 0)
            return result;
        }
        return event.code;
      }
      exports.getActualCode = getActualCode;
      var STRING_CODE = new Array(256);
      (() => {
        function addKeyCode(stringCode, numericCode) {
          if (STRING_CODE[numericCode] === void 0)
            STRING_CODE[numericCode] = stringCode;
        }
        addKeyCode("Pause", 3);
        addKeyCode("Backspace", 8);
        addKeyCode("Tab", 9);
        addKeyCode("Enter", 13);
        addKeyCode("ShiftLeft", 16);
        addKeyCode("ShiftRight", 16);
        addKeyCode("ControlLeft", 17);
        addKeyCode("ControlRight", 17);
        addKeyCode("AltLeft", 18);
        addKeyCode("AltRight", 18);
        addKeyCode("CapsLock", 20);
        addKeyCode("Escape", 27);
        addKeyCode("Space", 32);
        addKeyCode("PageUp", 33);
        addKeyCode("PageDown", 34);
        addKeyCode("End", 35);
        addKeyCode("Home", 36);
        addKeyCode("ArrowLeft", 37);
        addKeyCode("ArrowUp", 38);
        addKeyCode("ArrowRight", 39);
        addKeyCode("ArrowDown", 40);
        addKeyCode("Insert", 45);
        addKeyCode("Delete", 46);
        addKeyCode("Digit1", 49);
        addKeyCode("Digit2", 50);
        addKeyCode("Digit3", 51);
        addKeyCode("Digit4", 52);
        addKeyCode("Digit5", 53);
        addKeyCode("Digit6", 54);
        addKeyCode("Digit7", 55);
        addKeyCode("Digit8", 56);
        addKeyCode("Digit9", 57);
        addKeyCode("Digit0", 48);
        addKeyCode("KeyA", 65);
        addKeyCode("KeyB", 66);
        addKeyCode("KeyC", 67);
        addKeyCode("KeyD", 68);
        addKeyCode("KeyE", 69);
        addKeyCode("KeyF", 70);
        addKeyCode("KeyG", 71);
        addKeyCode("KeyH", 72);
        addKeyCode("KeyI", 73);
        addKeyCode("KeyJ", 74);
        addKeyCode("KeyK", 75);
        addKeyCode("KeyL", 76);
        addKeyCode("KeyM", 77);
        addKeyCode("KeyN", 78);
        addKeyCode("KeyO", 79);
        addKeyCode("KeyP", 80);
        addKeyCode("KeyQ", 81);
        addKeyCode("KeyR", 82);
        addKeyCode("KeyS", 83);
        addKeyCode("KeyT", 84);
        addKeyCode("KeyU", 85);
        addKeyCode("KeyV", 86);
        addKeyCode("KeyW", 87);
        addKeyCode("KeyX", 88);
        addKeyCode("KeyY", 89);
        addKeyCode("KeyZ", 90);
        addKeyCode("OSLeft", 91);
        addKeyCode("MetaLeft", 91);
        addKeyCode("OSRight", 92);
        addKeyCode("MetaRight", 92);
        addKeyCode("ContextMenu", 93);
        addKeyCode("Numpad0", 96);
        addKeyCode("Numpad1", 97);
        addKeyCode("Numpad2", 98);
        addKeyCode("Numpad3", 99);
        addKeyCode("Numpad4", 100);
        addKeyCode("Numpad5", 101);
        addKeyCode("Numpad6", 102);
        addKeyCode("Numpad7", 103);
        addKeyCode("Numpad8", 104);
        addKeyCode("Numpad9", 105);
        addKeyCode("NumpadMultiply", 106);
        addKeyCode("NumpadAdd", 107);
        addKeyCode("NumpadSeparator", 108);
        addKeyCode("NumpadSubtract", 109);
        addKeyCode("NumpadDecimal", 110);
        addKeyCode("NumpadDivide", 111);
        addKeyCode("F1", 112);
        addKeyCode("F2", 113);
        addKeyCode("F3", 114);
        addKeyCode("F4", 115);
        addKeyCode("F5", 116);
        addKeyCode("F6", 117);
        addKeyCode("F7", 118);
        addKeyCode("F8", 119);
        addKeyCode("F9", 120);
        addKeyCode("F10", 121);
        addKeyCode("F11", 122);
        addKeyCode("F12", 123);
        addKeyCode("F13", 124);
        addKeyCode("F14", 125);
        addKeyCode("F15", 126);
        addKeyCode("F16", 127);
        addKeyCode("F17", 128);
        addKeyCode("F18", 129);
        addKeyCode("F19", 130);
        addKeyCode("F20", 131);
        addKeyCode("F21", 132);
        addKeyCode("F22", 133);
        addKeyCode("F23", 134);
        addKeyCode("F24", 135);
        addKeyCode("NumLock", 144);
        addKeyCode("ScrollLock", 145);
        addKeyCode("Semicolon", 186);
        addKeyCode("Equal", 187);
        addKeyCode("Comma", 188);
        addKeyCode("Minus", 189);
        addKeyCode("Period", 190);
        addKeyCode("Slash", 191);
        addKeyCode("Backquote", 192);
        addKeyCode("IntlRo", 193);
        addKeyCode("BracketLeft", 219);
        addKeyCode("Backslash", 220);
        addKeyCode("BracketRight", 221);
        addKeyCode("Quote", 222);
        addKeyCode("IntlYen", 255);
      })();
    }
  });

  // node_modules/sprotty/lib/features/select/model.js
  var require_model6 = __commonJS({
    "node_modules/sprotty/lib/features/select/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSelected = exports.isSelectable = exports.selectFeature = void 0;
      exports.selectFeature = Symbol("selectFeature");
      function isSelectable(element) {
        return element.hasFeature(exports.selectFeature);
      }
      exports.isSelectable = isSelectable;
      function isSelected(element) {
        return element !== void 0 && isSelectable(element) && element.selected;
      }
      exports.isSelected = isSelected;
    }
  });

  // node_modules/autocompleter/autocomplete.js
  var require_autocomplete = __commonJS({
    "node_modules/autocompleter/autocomplete.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.autocomplete = factory());
      })(exports, function() {
        "use strict";
        function autocomplete(settings) {
          var doc = document;
          var container = settings.container || doc.createElement("div");
          var preventSubmit = settings.preventSubmit || 0;
          container.id = container.id || "autocomplete-" + uid();
          var containerStyle = container.style;
          var debounceWaitMs = settings.debounceWaitMs || 0;
          var disableAutoSelect = settings.disableAutoSelect || false;
          var customContainerParent = container.parentElement;
          var items = [];
          var inputValue = "";
          var minLen = 2;
          var showOnFocus = settings.showOnFocus;
          var selected;
          var fetchCounter = 0;
          var debounceTimer;
          var destroyed = false;
          var suppressAutocomplete = false;
          if (settings.minLength !== void 0) {
            minLen = settings.minLength;
          }
          if (!settings.input) {
            throw new Error("input undefined");
          }
          var input = settings.input;
          container.className = "autocomplete " + (settings.className || "");
          container.setAttribute("role", "listbox");
          input.setAttribute("role", "combobox");
          input.setAttribute("aria-expanded", "false");
          input.setAttribute("aria-autocomplete", "list");
          input.setAttribute("aria-controls", container.id);
          input.setAttribute("aria-owns", container.id);
          input.setAttribute("aria-activedescendant", "");
          input.setAttribute("aria-haspopup", "listbox");
          containerStyle.position = "absolute";
          function uid() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
          }
          function detach() {
            var parent = container.parentNode;
            if (parent) {
              parent.removeChild(container);
            }
          }
          function clearDebounceTimer() {
            if (debounceTimer) {
              window.clearTimeout(debounceTimer);
            }
          }
          function attach() {
            if (!container.parentNode) {
              (customContainerParent || doc.body).appendChild(container);
            }
          }
          function containerDisplayed() {
            return !!container.parentNode;
          }
          function clear() {
            fetchCounter++;
            items = [];
            inputValue = "";
            selected = void 0;
            input.setAttribute("aria-activedescendant", "");
            input.setAttribute("aria-expanded", "false");
            detach();
          }
          function updatePosition() {
            if (!containerDisplayed()) {
              return;
            }
            input.setAttribute("aria-expanded", "true");
            containerStyle.height = "auto";
            containerStyle.width = input.offsetWidth + "px";
            var maxHeight = 0;
            var inputRect;
            function calc() {
              var docEl = doc.documentElement;
              var clientTop = docEl.clientTop || doc.body.clientTop || 0;
              var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
              var scrollTop = window.pageYOffset || docEl.scrollTop;
              var scrollLeft = window.pageXOffset || docEl.scrollLeft;
              inputRect = input.getBoundingClientRect();
              var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
              var left = inputRect.left + scrollLeft - clientLeft;
              containerStyle.top = top + "px";
              containerStyle.left = left + "px";
              maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);
              if (maxHeight < 0) {
                maxHeight = 0;
              }
              containerStyle.top = top + "px";
              containerStyle.bottom = "";
              containerStyle.left = left + "px";
              containerStyle.maxHeight = maxHeight + "px";
            }
            calc();
            calc();
            if (settings.customize && inputRect) {
              settings.customize(input, inputRect, container, maxHeight);
            }
          }
          function update() {
            container.innerHTML = "";
            input.setAttribute("aria-activedescendant", "");
            var render = function(item, _, __) {
              var itemElement = doc.createElement("div");
              itemElement.textContent = item.label || "";
              return itemElement;
            };
            if (settings.render) {
              render = settings.render;
            }
            var renderGroup = function(groupName, _) {
              var groupDiv = doc.createElement("div");
              groupDiv.textContent = groupName;
              return groupDiv;
            };
            if (settings.renderGroup) {
              renderGroup = settings.renderGroup;
            }
            var fragment = doc.createDocumentFragment();
            var prevGroup = uid();
            items.forEach(function(item, index) {
              if (item.group && item.group !== prevGroup) {
                prevGroup = item.group;
                var groupDiv = renderGroup(item.group, inputValue);
                if (groupDiv) {
                  groupDiv.className += " group";
                  fragment.appendChild(groupDiv);
                }
              }
              var div = render(item, inputValue, index);
              if (div) {
                div.id = container.id + "_" + index;
                div.setAttribute("role", "option");
                div.addEventListener("click", function(ev) {
                  suppressAutocomplete = true;
                  try {
                    settings.onSelect(item, input);
                  } finally {
                    suppressAutocomplete = false;
                  }
                  clear();
                  ev.preventDefault();
                  ev.stopPropagation();
                });
                if (item === selected) {
                  div.className += " selected";
                  div.setAttribute("aria-selected", "true");
                  input.setAttribute("aria-activedescendant", div.id);
                }
                fragment.appendChild(div);
              }
            });
            container.appendChild(fragment);
            if (items.length < 1) {
              if (settings.emptyMsg) {
                var empty = doc.createElement("div");
                empty.id = container.id + "_" + uid();
                empty.className = "empty";
                empty.textContent = settings.emptyMsg;
                container.appendChild(empty);
                input.setAttribute("aria-activedescendant", empty.id);
              } else {
                clear();
                return;
              }
            }
            attach();
            updatePosition();
            updateScroll();
          }
          function updateIfDisplayed() {
            if (containerDisplayed()) {
              update();
            }
          }
          function resizeEventHandler() {
            updateIfDisplayed();
          }
          function scrollEventHandler(e) {
            if (e.target !== container) {
              updateIfDisplayed();
            } else {
              e.preventDefault();
            }
          }
          function inputEventHandler() {
            if (!suppressAutocomplete) {
              fetch(
                0
                /* Keyboard */
              );
            }
          }
          function updateScroll() {
            var elements = container.getElementsByClassName("selected");
            if (elements.length > 0) {
              var element = elements[0];
              var previous = element.previousElementSibling;
              if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
                element = previous;
              }
              if (element.offsetTop < container.scrollTop) {
                container.scrollTop = element.offsetTop;
              } else {
                var selectBottom = element.offsetTop + element.offsetHeight;
                var containerBottom = container.scrollTop + container.offsetHeight;
                if (selectBottom > containerBottom) {
                  container.scrollTop += selectBottom - containerBottom;
                }
              }
            }
          }
          function selectPreviousSuggestion() {
            var index = items.indexOf(selected);
            selected = index === -1 ? void 0 : items[(index + items.length - 1) % items.length];
            updateSelectedSuggestion(index);
          }
          function selectNextSuggestion() {
            var index = items.indexOf(selected);
            selected = items.length < 1 ? void 0 : index === -1 ? items[0] : items[(index + 1) % items.length];
            updateSelectedSuggestion(index);
          }
          function updateSelectedSuggestion(index) {
            if (items.length > 0) {
              unselectSuggestion(index);
              selectSuggestion(items.indexOf(selected));
              updateScroll();
            }
          }
          function selectSuggestion(index) {
            var element = doc.getElementById(container.id + "_" + index);
            if (element) {
              element.classList.add("selected");
              element.setAttribute("aria-selected", "true");
              input.setAttribute("aria-activedescendant", element.id);
            }
          }
          function unselectSuggestion(index) {
            var element = doc.getElementById(container.id + "_" + index);
            if (element) {
              element.classList.remove("selected");
              element.removeAttribute("aria-selected");
              input.removeAttribute("aria-activedescendant");
            }
          }
          function handleArrowAndEscapeKeys(ev, key) {
            var containerIsDisplayed = containerDisplayed();
            if (key === "Escape") {
              clear();
            } else {
              if (!containerIsDisplayed || items.length < 1) {
                return;
              }
              key === "ArrowUp" ? selectPreviousSuggestion() : selectNextSuggestion();
            }
            ev.preventDefault();
            if (containerIsDisplayed) {
              ev.stopPropagation();
            }
          }
          function handleEnterKey(ev) {
            if (selected) {
              if (preventSubmit === 2) {
                ev.preventDefault();
              }
              suppressAutocomplete = true;
              try {
                settings.onSelect(selected, input);
              } finally {
                suppressAutocomplete = false;
              }
              clear();
            }
            if (preventSubmit === 1) {
              ev.preventDefault();
            }
          }
          function keydownEventHandler(ev) {
            var key = ev.key;
            switch (key) {
              case "ArrowUp":
              case "ArrowDown":
              case "Escape":
                handleArrowAndEscapeKeys(ev, key);
                break;
              case "Enter":
                handleEnterKey(ev);
                break;
            }
          }
          function focusEventHandler() {
            if (showOnFocus) {
              fetch(
                1
                /* Focus */
              );
            }
          }
          function fetch(trigger) {
            if (input.value.length >= minLen || trigger === 1) {
              clearDebounceTimer();
              debounceTimer = window.setTimeout(function() {
                return startFetch(input.value, trigger, input.selectionStart || 0);
              }, trigger === 0 || trigger === 2 ? debounceWaitMs : 0);
            } else {
              clear();
            }
          }
          function startFetch(inputText, trigger, cursorPos) {
            if (destroyed)
              return;
            var savedFetchCounter = ++fetchCounter;
            settings.fetch(inputText, function(elements) {
              if (fetchCounter === savedFetchCounter && elements) {
                items = elements;
                inputValue = inputText;
                selected = items.length < 1 || disableAutoSelect ? void 0 : items[0];
                update();
              }
            }, trigger, cursorPos);
          }
          function keyupEventHandler(e) {
            if (settings.keyup) {
              settings.keyup({
                event: e,
                fetch: function() {
                  return fetch(
                    0
                    /* Keyboard */
                  );
                }
              });
              return;
            }
            if (!containerDisplayed() && e.key === "ArrowDown") {
              fetch(
                0
                /* Keyboard */
              );
            }
          }
          function clickEventHandler(e) {
            settings.click && settings.click({
              event: e,
              fetch: function() {
                return fetch(
                  2
                  /* Mouse */
                );
              }
            });
          }
          function blurEventHandler() {
            setTimeout(function() {
              if (doc.activeElement !== input) {
                clear();
              }
            }, 200);
          }
          function manualFetch() {
            startFetch(input.value, 3, input.selectionStart || 0);
          }
          container.addEventListener("mousedown", function(evt) {
            evt.stopPropagation();
            evt.preventDefault();
          });
          container.addEventListener("focus", function() {
            return input.focus();
          });
          detach();
          function destroy() {
            input.removeEventListener("focus", focusEventHandler);
            input.removeEventListener("keyup", keyupEventHandler);
            input.removeEventListener("click", clickEventHandler);
            input.removeEventListener("keydown", keydownEventHandler);
            input.removeEventListener("input", inputEventHandler);
            input.removeEventListener("blur", blurEventHandler);
            window.removeEventListener("resize", resizeEventHandler);
            doc.removeEventListener("scroll", scrollEventHandler, true);
            input.removeAttribute("role");
            input.removeAttribute("aria-expanded");
            input.removeAttribute("aria-autocomplete");
            input.removeAttribute("aria-controls");
            input.removeAttribute("aria-activedescendant");
            input.removeAttribute("aria-owns");
            input.removeAttribute("aria-haspopup");
            clearDebounceTimer();
            clear();
            destroyed = true;
          }
          input.addEventListener("keyup", keyupEventHandler);
          input.addEventListener("click", clickEventHandler);
          input.addEventListener("keydown", keydownEventHandler);
          input.addEventListener("input", inputEventHandler);
          input.addEventListener("blur", blurEventHandler);
          input.addEventListener("focus", focusEventHandler);
          window.addEventListener("resize", resizeEventHandler);
          doc.addEventListener("scroll", scrollEventHandler, true);
          return {
            destroy,
            fetch: manualFetch
          };
        }
        return autocomplete;
      });
    }
  });

  // node_modules/sprotty/lib/features/command-palette/command-palette.js
  var require_command_palette = __commonJS({
    "node_modules/sprotty/lib/features/command-palette/command-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var CommandPalette_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommandPaletteKeyListener = exports.CommandPalette = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var action_1 = require_action();
      var types_1 = require_types();
      var ui_extension_1 = require_ui_extension();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var dom_helper_1 = require_dom_helper();
      var key_tool_1 = require_key_tool();
      var codicon_1 = require_codicon();
      var iterable_1 = require_iterable();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model2();
      var model_2 = require_model6();
      var action_providers_1 = require_action_providers();
      var mouse_tool_1 = require_mouse_tool();
      var autocompleter_1 = __importDefault(require_autocomplete());
      var CommandPalette = CommandPalette_1 = class CommandPalette extends ui_extension_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.loadingIndicatorClasses = (0, codicon_1.codiconCSSClasses)("loading", false, true, ["loading"]);
          this.xOffset = 20;
          this.yOffset = 20;
          this.defaultWidth = 400;
          this.debounceWaitMs = 100;
          this.noCommandsMsg = "No commands available";
          this.paletteIndex = 0;
        }
        id() {
          return CommandPalette_1.ID;
        }
        containerClass() {
          return "command-palette";
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.paletteIndex = 0;
          this.contextActions = void 0;
          this.inputElement.value = "";
          this.autoCompleteResult = (0, autocompleter_1.default)(this.autocompleteSettings(root));
          this.inputElement.focus();
        }
        initializeContents(containerElement) {
          containerElement.style.position = "absolute";
          this.inputElement = document.createElement("input");
          this.inputElement.style.width = "100%";
          this.inputElement.addEventListener("keydown", (event) => this.hideIfEscapeEvent(event));
          this.inputElement.addEventListener("keydown", (event) => this.cylceIfInvokePaletteKey(event));
          this.inputElement.onblur = () => window.setTimeout(() => this.hide(), 200);
          containerElement.appendChild(this.inputElement);
        }
        hideIfEscapeEvent(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            this.hide();
          }
        }
        cylceIfInvokePaletteKey(event) {
          if (CommandPalette_1.isInvokePaletteKey(event)) {
            this.cycle();
          }
        }
        cycle() {
          this.contextActions = void 0;
          this.paletteIndex++;
        }
        onBeforeShow(containerElement, root, ...selectedElementIds) {
          let x = this.xOffset;
          let y = this.yOffset;
          const selectedElements = (0, iterable_1.toArray)(root.index.all().filter((e) => (0, model_2.isSelectable)(e) && e.selected));
          if (selectedElements.length === 1) {
            const bounds = (0, model_1.getAbsoluteClientBounds)(selectedElements[0], this.domHelper, this.viewerOptions);
            x += bounds.x + bounds.width;
            y += bounds.y;
          } else {
            const bounds = (0, model_1.getAbsoluteClientBounds)(root, this.domHelper, this.viewerOptions);
            x += bounds.x;
            y += bounds.y;
          }
          containerElement.style.left = `${x}px`;
          containerElement.style.top = `${y}px`;
          containerElement.style.width = `${this.defaultWidth}px`;
        }
        autocompleteSettings(root) {
          return {
            input: this.inputElement,
            emptyMsg: this.noCommandsMsg,
            className: "command-palette-suggestions",
            debounceWaitMs: this.debounceWaitMs,
            showOnFocus: true,
            minLength: -1,
            fetch: (text, update) => this.updateAutoCompleteActions(update, text, root),
            onSelect: (item) => this.onSelect(item),
            render: (item, currentValue) => this.renderLabeledActionSuggestion(item, currentValue),
            customize: (input, inputRect, container, maxHeight) => {
              this.customizeSuggestionContainer(container, inputRect, maxHeight);
            }
          };
        }
        onSelect(item) {
          this.executeAction(item);
          this.hide();
        }
        updateAutoCompleteActions(update, text, root) {
          this.onLoading();
          if (this.contextActions) {
            update(this.filterActions(text, this.contextActions));
            this.onLoaded("success");
          } else {
            this.actionProviderRegistry.getActions(root, text, this.mousePositionTracker.lastPositionOnDiagram, this.paletteIndex).then((actions) => {
              this.contextActions = actions;
              update(this.filterActions(text, actions));
              this.onLoaded("success");
            }).catch((reason) => {
              this.logger.error(this, "Failed to obtain actions from command palette action providers", reason);
              this.onLoaded("error");
            });
          }
        }
        onLoading() {
          if (this.loadingIndicator && this.containerElement.contains(this.loadingIndicator)) {
            return;
          }
          this.loadingIndicator = document.createElement("span");
          this.loadingIndicator.classList.add(...this.loadingIndicatorClasses);
          this.containerElement.appendChild(this.loadingIndicator);
        }
        onLoaded(success) {
          if (this.containerElement.contains(this.loadingIndicator)) {
            this.containerElement.removeChild(this.loadingIndicator);
          }
        }
        renderLabeledActionSuggestion(item, value) {
          const itemElement = document.createElement("div");
          const wordMatcher = espaceForRegExp(value).split(" ").join("|");
          const regex = new RegExp(wordMatcher, "gi");
          if (item.icon) {
            this.renderIcon(itemElement, item.icon);
          }
          if (value.length > 0) {
            itemElement.innerHTML += item.label.replace(regex, (match) => "<em>" + match + "</em>").replace(/ /g, "&nbsp;");
          } else {
            itemElement.innerHTML += item.label.replace(/ /g, "&nbsp;");
          }
          return itemElement;
        }
        renderIcon(itemElement, iconId) {
          itemElement.innerHTML += `<span class="icon ${this.getCodicon(iconId)}"></span>`;
        }
        getFontAwesomeIcon(iconId) {
          return `fa fa-${iconId}`;
        }
        getCodicon(iconId) {
          return (0, codicon_1.codiconCSSString)(iconId);
        }
        filterActions(filterText, actions) {
          return (0, iterable_1.toArray)(actions.filter((action) => {
            const label = action.label.toLowerCase();
            const searchWords = filterText.split(" ");
            return searchWords.every((word) => label.indexOf(word.toLowerCase()) !== -1);
          }));
        }
        customizeSuggestionContainer(container, inputRect, maxHeight) {
          container.style.position = "fixed";
          if (this.containerElement) {
            this.containerElement.appendChild(container);
          }
        }
        hide() {
          super.hide();
          if (this.autoCompleteResult) {
            this.autoCompleteResult.destroy();
          }
        }
        executeAction(input) {
          this.actionDispatcherProvider().then((actionDispatcher) => actionDispatcher.dispatchAll(toActionArray(input))).catch((reason) => this.logger.error(this, "No action dispatcher available to execute command palette action", reason));
        }
      };
      exports.CommandPalette = CommandPalette;
      CommandPalette.ID = "command-palette";
      CommandPalette.isInvokePaletteKey = (event) => (0, keyboard_1.matchesKeystroke)(event, "Space", "ctrl");
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcherProvider),
        __metadata("design:type", Function)
      ], CommandPalette.prototype, "actionDispatcherProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ICommandPaletteActionProviderRegistry),
        __metadata("design:type", action_providers_1.CommandPaletteActionProviderRegistry)
      ], CommandPalette.prototype, "actionProviderRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], CommandPalette.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], CommandPalette.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.inject)(mouse_tool_1.MousePositionTracker),
        __metadata("design:type", mouse_tool_1.MousePositionTracker)
      ], CommandPalette.prototype, "mousePositionTracker", void 0);
      exports.CommandPalette = CommandPalette = CommandPalette_1 = __decorate([
        (0, inversify_1.injectable)()
      ], CommandPalette);
      function toActionArray(input) {
        if ((0, action_1.isLabeledAction)(input)) {
          return input.actions;
        } else if ((0, actions_1.isAction)(input)) {
          return [input];
        }
        return [];
      }
      function espaceForRegExp(value) {
        return value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      }
      var CommandPaletteKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            return [ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: CommandPalette.ID, visible: false, contextElementsId: [] })];
          } else if (CommandPalette.isInvokePaletteKey(event)) {
            const selectedElements = (0, iterable_1.toArray)(element.index.all().filter((e) => (0, model_2.isSelectable)(e) && e.selected).map((e) => e.id));
            return [ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: CommandPalette.ID, visible: true, contextElementsId: selectedElements })];
          }
          return [];
        }
      };
      exports.CommandPaletteKeyListener = CommandPaletteKeyListener;
    }
  });

  // node_modules/sprotty/lib/features/context-menu/context-menu-service.js
  var require_context_menu_service = __commonJS({
    "node_modules/sprotty/lib/features/context-menu/context-menu-service.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toAnchor = void 0;
      function toAnchor(anchor) {
        return anchor instanceof HTMLElement ? { x: anchor.offsetLeft, y: anchor.offsetTop } : anchor;
      }
      exports.toAnchor = toAnchor;
    }
  });

  // node_modules/sprotty/lib/features/edit/delete.js
  var require_delete = __commonJS({
    "node_modules/sprotty/lib/features/edit/delete.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteElementCommand = exports.ResolvedDelete = exports.isDeletable = exports.deletableFeature = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      exports.deletableFeature = Symbol("deletableFeature");
      function isDeletable(element) {
        return element instanceof smodel_1.SChildElementImpl && element.hasFeature(exports.deletableFeature);
      }
      exports.isDeletable = isDeletable;
      var ResolvedDelete = class {
      };
      exports.ResolvedDelete = ResolvedDelete;
      var DeleteElementCommand = class DeleteElementCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.resolvedDeletes = [];
        }
        execute(context) {
          const index = context.root.index;
          for (const id of this.action.elementIds) {
            const element = index.getById(id);
            if (element && isDeletable(element)) {
              this.resolvedDeletes.push({ child: element, parent: element.parent });
              element.parent.remove(element);
            }
          }
          return context.root;
        }
        undo(context) {
          for (const resolvedDelete of this.resolvedDeletes)
            resolvedDelete.parent.add(resolvedDelete.child);
          return context.root;
        }
        redo(context) {
          for (const resolvedDelete of this.resolvedDeletes)
            resolvedDelete.parent.remove(resolvedDelete.child);
          return context.root;
        }
      };
      exports.DeleteElementCommand = DeleteElementCommand;
      DeleteElementCommand.KIND = actions_1.DeleteElementAction.KIND;
      exports.DeleteElementCommand = DeleteElementCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DeleteElementCommand);
    }
  });

  // node_modules/sprotty/lib/features/context-menu/menu-providers.js
  var require_menu_providers = __commonJS({
    "node_modules/sprotty/lib/features/context-menu/menu-providers.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteContextMenuItemProvider = exports.ContextMenuProviderRegistry = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var delete_1 = require_delete();
      var model_1 = require_model6();
      var sprotty_protocol_1 = require_lib();
      var ContextMenuProviderRegistry = class ContextMenuProviderRegistry {
        constructor(menuProviders = []) {
          this.menuProviders = menuProviders;
        }
        getItems(root, lastMousePosition) {
          const menues = this.menuProviders.map((provider) => provider.getItems(root, lastMousePosition));
          return Promise.all(menues).then(this.flattenAndRestructure);
        }
        flattenAndRestructure(p) {
          let menuItems = p.reduce((acc, promise) => promise !== void 0 ? acc.concat(promise) : acc, []);
          const menuItemsWithParentId = menuItems.filter((menuItem) => menuItem.parentId);
          for (const menuItem of menuItemsWithParentId) {
            if (menuItem.parentId) {
              const fragments = menuItem.parentId.split(".");
              let matchingParent = void 0;
              let nextParents = menuItems;
              for (const fragment of fragments) {
                matchingParent = nextParents.find((item) => fragment === item.id);
                if (matchingParent && matchingParent.children)
                  nextParents = matchingParent.children;
              }
              if (matchingParent) {
                if (matchingParent.children) {
                  matchingParent.children.push(menuItem);
                } else {
                  matchingParent.children = [menuItem];
                }
                menuItems = menuItems.filter((item) => item !== menuItem);
              }
            }
          }
          return menuItems;
        }
      };
      exports.ContextMenuProviderRegistry = ContextMenuProviderRegistry;
      exports.ContextMenuProviderRegistry = ContextMenuProviderRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IContextMenuItemProvider)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ContextMenuProviderRegistry);
      var DeleteContextMenuItemProvider = class DeleteContextMenuItemProvider {
        getItems(root, lastMousePosition) {
          const selectedElements = Array.from(root.index.all().filter(model_1.isSelected).filter(delete_1.isDeletable));
          return Promise.resolve([
            {
              id: "delete",
              label: "Delete",
              sortString: "d",
              group: "edit",
              actions: [sprotty_protocol_1.DeleteElementAction.create(selectedElements.map((e) => e.id))],
              isEnabled: () => selectedElements.length > 0
            }
          ]);
        }
      };
      exports.DeleteContextMenuItemProvider = DeleteContextMenuItemProvider;
      exports.DeleteContextMenuItemProvider = DeleteContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteContextMenuItemProvider);
    }
  });

  // node_modules/sprotty/lib/features/context-menu/mouse-listener.js
  var require_mouse_listener = __commonJS({
    "node_modules/sprotty/lib/features/context-menu/mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContextMenuMouseListener = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var model_1 = require_model6();
      var menu_providers_1 = require_menu_providers();
      var ContextMenuMouseListener = class ContextMenuMouseListener extends mouse_tool_1.MouseListener {
        constructor(contextMenuService, menuProvider) {
          super();
          this.contextMenuService = contextMenuService;
          this.menuProvider = menuProvider;
        }
        contextMenu(target, event) {
          this.showContextMenu(target, event);
          return [];
        }
        async showContextMenu(target, event) {
          let menuService;
          try {
            menuService = await this.contextMenuService();
          } catch (rejected) {
            return;
          }
          let isTargetSelected = false;
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_1.isSelectable);
          if (selectableTarget) {
            isTargetSelected = selectableTarget.selected;
            selectableTarget.selected = true;
          }
          const root = target.root;
          const mousePosition = { x: event.x, y: event.y };
          if (target.id === root.id || (0, model_1.isSelected)(selectableTarget)) {
            const menuItems = await this.menuProvider.getItems(root, mousePosition);
            const restoreSelection = () => {
              if (selectableTarget)
                selectableTarget.selected = isTargetSelected;
            };
            menuService.show(menuItems, mousePosition, restoreSelection);
          } else {
            if ((0, model_1.isSelectable)(target)) {
              const options = { selectedElementsIDs: [target.id], deselectedElementsIDs: Array.from(root.index.all().filter(model_1.isSelected), (val) => {
                return val.id;
              }) };
              await this.actionDispatcher.dispatch(actions_1.SelectAction.create(options));
            }
            const items = await this.menuProvider.getItems(root, mousePosition);
            menuService.show(items, mousePosition);
          }
        }
      };
      exports.ContextMenuMouseListener = ContextMenuMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ContextMenuMouseListener.prototype, "actionDispatcher", void 0);
      exports.ContextMenuMouseListener = ContextMenuMouseListener = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.IContextMenuServiceProvider)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.IContextMenuProviderRegistry)),
        __metadata("design:paramtypes", [Function, menu_providers_1.ContextMenuProviderRegistry])
      ], ContextMenuMouseListener);
    }
  });

  // node_modules/sprotty/lib/features/hover/model.js
  var require_model7 = __commonJS({
    "node_modules/sprotty/lib/features/hover/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasPopupFeature = exports.popupFeature = exports.isHoverable = exports.hoverFeedbackFeature = void 0;
      exports.hoverFeedbackFeature = Symbol("hoverFeedbackFeature");
      function isHoverable(element) {
        return element.hasFeature(exports.hoverFeedbackFeature);
      }
      exports.isHoverable = isHoverable;
      exports.popupFeature = Symbol("popupFeature");
      function hasPopupFeature(element) {
        return element.hasFeature(exports.popupFeature);
      }
      exports.hasPopupFeature = hasPopupFeature;
    }
  });

  // node_modules/sprotty/lib/features/move/model.js
  var require_model8 = __commonJS({
    "node_modules/sprotty/lib/features/move/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isMoveable = exports.isLocateable = exports.moveFeature = void 0;
      exports.moveFeature = Symbol("moveFeature");
      function isLocateable(element) {
        return element["position"] !== void 0;
      }
      exports.isLocateable = isLocateable;
      function isMoveable(element) {
        return element.hasFeature(exports.moveFeature) && isLocateable(element);
      }
      exports.isMoveable = isMoveable;
    }
  });

  // node_modules/sprotty/lib/features/routing/model.js
  var require_model9 = __commonJS({
    "node_modules/sprotty/lib/features/routing/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.edgeInProgressTargetHandleID = exports.edgeInProgressID = exports.SDanglingAnchorImpl = exports.SRoutingHandleImpl = exports.SConnectableElementImpl = exports.getRouteBounds = exports.getAbsoluteRouteBounds = exports.isConnectable = exports.connectableFeature = exports.SRoutableElementImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var delete_1 = require_delete();
      var model_2 = require_model6();
      var model_3 = require_model7();
      var model_4 = require_model8();
      var SRoutableElementImpl = class extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.routingPoints = [];
        }
        get source() {
          return this.index.getById(this.sourceId);
        }
        get target() {
          return this.index.getById(this.targetId);
        }
        get bounds() {
          return this.routingPoints.reduce((bounds, routingPoint) => geometry_1.Bounds.combine(bounds, {
            x: routingPoint.x,
            y: routingPoint.y,
            width: 0,
            height: 0
          }), geometry_1.Bounds.EMPTY);
        }
      };
      exports.SRoutableElementImpl = SRoutableElementImpl;
      exports.connectableFeature = Symbol("connectableFeature");
      function isConnectable3(element) {
        return element.hasFeature(exports.connectableFeature) && element.canConnect;
      }
      exports.isConnectable = isConnectable3;
      function getAbsoluteRouteBounds(model, route = model.routingPoints) {
        let bounds = getRouteBounds(route);
        let current = model;
        while (current instanceof smodel_1.SChildElementImpl) {
          const parent = current.parent;
          bounds = parent.localToParent(bounds);
          current = parent;
        }
        return bounds;
      }
      exports.getAbsoluteRouteBounds = getAbsoluteRouteBounds;
      function getRouteBounds(route) {
        const bounds = { x: NaN, y: NaN, width: 0, height: 0 };
        for (const point of route) {
          if (isNaN(bounds.x)) {
            bounds.x = point.x;
            bounds.y = point.y;
          } else {
            if (point.x < bounds.x) {
              bounds.width += bounds.x - point.x;
              bounds.x = point.x;
            } else if (point.x > bounds.x + bounds.width) {
              bounds.width = point.x - bounds.x;
            }
            if (point.y < bounds.y) {
              bounds.height += bounds.y - point.y;
              bounds.y = point.y;
            } else if (point.y > bounds.y + bounds.height) {
              bounds.height = point.y - bounds.y;
            }
          }
        }
        return bounds;
      }
      exports.getRouteBounds = getRouteBounds;
      var SConnectableElementImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.strokeWidth = 0;
        }
        get anchorKind() {
          return void 0;
        }
        /**
         * The incoming edges of this connectable element. They are resolved by the index, which must
         * be an `SGraphIndex` for efficient lookup.
         */
        get incomingEdges() {
          const allEdges = this.index.all().filter((e) => e instanceof SRoutableElementImpl);
          return allEdges.filter((e) => e.targetId === this.id);
        }
        /**
         * The outgoing edges of this connectable element. They are resolved by the index, which must
         * be an `SGraphIndex` for efficient lookup.
         */
        get outgoingEdges() {
          const allEdges = this.index.all().filter((e) => e instanceof SRoutableElementImpl);
          return allEdges.filter((e) => e.sourceId === this.id);
        }
        canConnect(routable, role) {
          return true;
        }
      };
      exports.SConnectableElementImpl = SConnectableElementImpl;
      var SRoutingHandleImpl2 = class extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.editMode = false;
          this.hoverFeedback = false;
          this.selected = false;
        }
        /**
         * SRoutingHandles are created using the constructor, so we hard-wire the
         * default features
         */
        hasFeature(feature) {
          return SRoutingHandleImpl2.DEFAULT_FEATURES.indexOf(feature) !== -1;
        }
      };
      exports.SRoutingHandleImpl = SRoutingHandleImpl2;
      SRoutingHandleImpl2.DEFAULT_FEATURES = [model_2.selectFeature, model_4.moveFeature, model_3.hoverFeedbackFeature];
      var SDanglingAnchorImpl = class extends SConnectableElementImpl {
        constructor() {
          super();
          this.type = "dangling-anchor";
          this.size = { width: 0, height: 0 };
        }
      };
      exports.SDanglingAnchorImpl = SDanglingAnchorImpl;
      SDanglingAnchorImpl.DEFAULT_FEATURES = [delete_1.deletableFeature];
      exports.edgeInProgressID = "edge-in-progress";
      exports.edgeInProgressTargetHandleID = exports.edgeInProgressID + "-target-anchor";
    }
  });

  // node_modules/sprotty/lib/features/edge-layout/model.js
  var require_model10 = __commonJS({
    "node_modules/sprotty/lib/features/edge-layout/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DEFAULT_EDGE_PLACEMENT = exports.EdgePlacement = exports.isEdgeLayoutable = exports.edgeLayoutFeature = void 0;
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model9();
      exports.edgeLayoutFeature = Symbol("edgeLayout");
      function isEdgeLayoutable(element) {
        return element instanceof smodel_1.SChildElementImpl && element.parent instanceof model_2.SRoutableElementImpl && checkEdgeLayoutable(element) && (0, model_1.isBoundsAware)(element) && element.hasFeature(exports.edgeLayoutFeature);
      }
      exports.isEdgeLayoutable = isEdgeLayoutable;
      function checkEdgeLayoutable(element) {
        return "edgePlacement" in element;
      }
      var EdgePlacement = class extends Object {
      };
      exports.EdgePlacement = EdgePlacement;
      exports.DEFAULT_EDGE_PLACEMENT = {
        rotate: true,
        side: "top",
        position: 0.5,
        offset: 7
      };
    }
  });

  // node_modules/sprotty/lib/features/edit/model.js
  var require_model11 = __commonJS({
    "node_modules/sprotty/lib/features/edit/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isWithEditableLabel = exports.withEditLabelFeature = exports.isEditableLabel = exports.editLabelFeature = exports.canEditRouting = exports.editFeature = void 0;
      var model_1 = require_model9();
      exports.editFeature = Symbol("editFeature");
      function canEditRouting(element) {
        return element instanceof model_1.SRoutableElementImpl && element.hasFeature(exports.editFeature);
      }
      exports.canEditRouting = canEditRouting;
      exports.editLabelFeature = Symbol("editLabelFeature");
      function isEditableLabel(element) {
        return "text" in element && element.hasFeature(exports.editLabelFeature);
      }
      exports.isEditableLabel = isEditableLabel;
      exports.withEditLabelFeature = Symbol("withEditLabelFeature");
      function isWithEditableLabel(element) {
        return "editableLabel" in element && element.hasFeature(exports.withEditLabelFeature);
      }
      exports.isWithEditableLabel = isWithEditableLabel;
    }
  });

  // node_modules/sprotty/lib/utils/geometry.js
  var require_geometry2 = __commonJS({
    "node_modules/sprotty/lib/utils/geometry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.limit = exports.intersection = exports.PointToPointLine = exports.Diamond = void 0;
      var sprotty_protocol_1 = require_lib();
      var Diamond = class {
        constructor(bounds) {
          this.bounds = bounds;
        }
        get topPoint() {
          return {
            x: this.bounds.x + this.bounds.width / 2,
            y: this.bounds.y
          };
        }
        get rightPoint() {
          return {
            x: this.bounds.x + this.bounds.width,
            y: this.bounds.y + this.bounds.height / 2
          };
        }
        get bottomPoint() {
          return {
            x: this.bounds.x + this.bounds.width / 2,
            y: this.bounds.y + this.bounds.height
          };
        }
        get leftPoint() {
          return {
            x: this.bounds.x,
            y: this.bounds.y + this.bounds.height / 2
          };
        }
        get topRightSideLine() {
          return new PointToPointLine(this.topPoint, this.rightPoint);
        }
        get topLeftSideLine() {
          return new PointToPointLine(this.topPoint, this.leftPoint);
        }
        get bottomRightSideLine() {
          return new PointToPointLine(this.bottomPoint, this.rightPoint);
        }
        get bottomLeftSideLine() {
          return new PointToPointLine(this.bottomPoint, this.leftPoint);
        }
        /**
         * Return the closest side of this diamond to the specified `refPoint`.
         * @param {Point} refPoint a reference point
         * @returns {Line} a line representing the closest side
         */
        closestSideLine(refPoint) {
          const c = sprotty_protocol_1.Bounds.center(this.bounds);
          if (refPoint.x > c.x) {
            if (refPoint.y > c.y) {
              return this.bottomRightSideLine;
            } else {
              return this.topRightSideLine;
            }
          } else {
            if (refPoint.y > c.y) {
              return this.bottomLeftSideLine;
            } else {
              return this.topLeftSideLine;
            }
          }
        }
      };
      exports.Diamond = Diamond;
      var PointToPointLine = class {
        constructor(p1, p2) {
          this.p1 = p1;
          this.p2 = p2;
        }
        get a() {
          return this.p1.y - this.p2.y;
        }
        get b() {
          return this.p2.x - this.p1.x;
        }
        get c() {
          return this.p2.x * this.p1.y - this.p1.x * this.p2.y;
        }
        /**
         * The counter-clockwise angle of this line relative to the x-axis.
         */
        get angle() {
          return Math.atan2(-this.a, this.b);
        }
        /**
         * The slope of the line.
         * A vertical line returns `undefined`.
         */
        get slope() {
          if (this.b === 0)
            return void 0;
          return this.a / this.b;
        }
        /**
         * The slope of the line or `Number.MAX_SAFE_INTEGER` if vertical.
         */
        get slopeOrMax() {
          if (this.slope === void 0) {
            return Number.MAX_SAFE_INTEGER;
          }
          return this.slope;
        }
        /**
         * The direction of this line, such as 'north', 'south', or 'south-west'.
         */
        get direction() {
          const hDegrees = (0, sprotty_protocol_1.toDegrees)(this.angle);
          const degrees = hDegrees < 0 ? 360 + hDegrees : hDegrees;
          if (degrees === 90) {
            return "south";
          } else if (degrees === 0 || degrees === 360) {
            return "east";
          } else if (degrees === 270) {
            return "north";
          } else if (degrees === 180) {
            return "west";
          } else if (degrees > 0 && degrees < 90) {
            return "south-east";
          } else if (degrees > 90 && degrees < 180) {
            return "south-west";
          } else if (degrees > 180 && degrees < 270) {
            return "north-west";
          } else if (degrees > 270 && degrees < 360) {
            return "north-east";
          }
          throw new Error(`Cannot determine direction of line (${this.p1.x},${this.p1.y}) to (${this.p2.x},${this.p2.y})`);
        }
        /**
         * @param otherLine the other line
         * @returns the intersection point between `this` line and the `otherLine` if exists, or `undefined`.
         */
        intersection(otherLine) {
          if (this.hasIndistinctPoints(otherLine)) {
            return void 0;
          }
          const x1 = this.p1.x;
          const y1 = this.p1.y;
          const x2 = this.p2.x;
          const y2 = this.p2.y;
          const x3 = otherLine.p1.x;
          const y3 = otherLine.p1.y;
          const x4 = otherLine.p2.x;
          const y4 = otherLine.p2.y;
          const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
          if (denominator === 0) {
            return void 0;
          }
          const numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
          const numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
          if (numeratorA === 0 && numeratorB === 0) {
            return void 0;
          }
          const determinantA = numeratorA / denominator;
          const determinantB = numeratorB / denominator;
          if (determinantA < 0 || determinantA > 1 || determinantB < 0 || determinantB > 1) {
            return void 0;
          }
          const x = x1 + determinantA * (x2 - x1);
          const y = y1 + determinantA * (y2 - y1);
          return { x, y };
        }
        /**
         * @param otherLine the other line
         * @returns whether the start and end point of this line is does not have distinct start
         * or end points with the `otherLine`
         */
        hasIndistinctPoints(otherLine) {
          return sprotty_protocol_1.Point.equals(this.p1, otherLine.p1) || sprotty_protocol_1.Point.equals(this.p1, otherLine.p2) || sprotty_protocol_1.Point.equals(this.p2, otherLine.p1) || sprotty_protocol_1.Point.equals(this.p2, otherLine.p2);
        }
      };
      exports.PointToPointLine = PointToPointLine;
      function intersection(l1, l2) {
        return {
          x: (l1.c * l2.b - l2.c * l1.b) / (l1.a * l2.b - l2.a * l1.b),
          y: (l1.a * l2.c - l2.a * l1.c) / (l1.a * l2.b - l2.a * l1.b)
        };
      }
      exports.intersection = intersection;
      function limit(value, limits) {
        if (value < limits.min) {
          return limits.min;
        }
        if (value > limits.max) {
          return limits.max;
        }
        return value;
      }
      exports.limit = limit;
    }
  });

  // node_modules/sprotty/lib/features/viewport/model.js
  var require_model12 = __commonJS({
    "node_modules/sprotty/lib/features/viewport/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.limitViewport = exports.isViewport = exports.viewportFeature = void 0;
      var sprotty_protocol_1 = require_lib();
      var smodel_1 = require_smodel();
      var geometry_1 = require_geometry2();
      exports.viewportFeature = Symbol("viewportFeature");
      function isViewport(element) {
        return element instanceof smodel_1.SModelRootImpl && element.hasFeature(exports.viewportFeature) && "zoom" in element && "scroll" in element;
      }
      exports.isViewport = isViewport;
      function limitViewport(viewport, canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits) {
        if (canvasBounds && !sprotty_protocol_1.Dimension.isValid(canvasBounds)) {
          canvasBounds = void 0;
        }
        let zoom = zoomLimits ? (0, geometry_1.limit)(viewport.zoom, zoomLimits) : viewport.zoom;
        if (canvasBounds && horizontalScrollLimits) {
          const minZoom = canvasBounds.width / (horizontalScrollLimits.max - horizontalScrollLimits.min);
          if (zoom < minZoom) {
            zoom = minZoom;
          }
        }
        if (canvasBounds && verticalScrollLimits) {
          const minZoom = canvasBounds.height / (verticalScrollLimits.max - verticalScrollLimits.min);
          if (zoom < minZoom) {
            zoom = minZoom;
          }
        }
        let scrollX;
        if (horizontalScrollLimits) {
          const min = horizontalScrollLimits.min;
          const max = canvasBounds ? horizontalScrollLimits.max - canvasBounds.width / zoom : horizontalScrollLimits.max;
          scrollX = (0, geometry_1.limit)(viewport.scroll.x, { min, max });
        } else {
          scrollX = viewport.scroll.x;
        }
        let scrollY;
        if (verticalScrollLimits) {
          const min = verticalScrollLimits.min;
          const max = canvasBounds ? verticalScrollLimits.max - canvasBounds.height / zoom : verticalScrollLimits.max;
          scrollY = (0, geometry_1.limit)(viewport.scroll.y, { min, max });
        } else {
          scrollY = viewport.scroll.y;
        }
        return { scroll: { x: scrollX, y: scrollY }, zoom };
      }
      exports.limitViewport = limitViewport;
    }
  });

  // node_modules/sprotty/lib/features/export/model.js
  var require_model13 = __commonJS({
    "node_modules/sprotty/lib/features/export/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isExportable = exports.exportFeature = void 0;
      exports.exportFeature = Symbol("exportFeature");
      function isExportable(element) {
        return element.hasFeature(exports.exportFeature);
      }
      exports.isExportable = isExportable;
    }
  });

  // node_modules/sprotty/lib/features/viewport/viewport-root.js
  var require_viewport_root = __commonJS({
    "node_modules/sprotty/lib/features/viewport/viewport-root.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportRootElementImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model12();
      var model_2 = require_model13();
      var ViewportRootElementImpl = class extends smodel_1.SModelRootImpl {
        constructor(index) {
          super(index);
          this.scroll = { x: 0, y: 0 };
          this.zoom = 1;
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
        localToParent(point) {
          const result = {
            x: (point.x - this.scroll.x) * this.zoom,
            y: (point.y - this.scroll.y) * this.zoom,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width * this.zoom;
            result.height = point.height * this.zoom;
          }
          return result;
        }
        parentToLocal(point) {
          const result = {
            x: point.x / this.zoom + this.scroll.x,
            y: point.y / this.zoom + this.scroll.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point) && geometry_1.Dimension.isValid(point)) {
            result.width = point.width / this.zoom;
            result.height = point.height / this.zoom;
          }
          return result;
        }
      };
      exports.ViewportRootElementImpl = ViewportRootElementImpl;
      ViewportRootElementImpl.DEFAULT_FEATURES = [model_1.viewportFeature, model_2.exportFeature];
    }
  });

  // node_modules/sprotty/lib/graph/sgraph.js
  var require_sgraph = __commonJS({
    "node_modules/sprotty/lib/graph/sgraph.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SGraphIndex = exports.SCompartmentImpl = exports.SLabelImpl = exports.SEdgeImpl = exports.SPortImpl = exports.SNodeImpl = exports.SGraphImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model10();
      var delete_1 = require_delete();
      var model_3 = require_model11();
      var model_4 = require_model3();
      var model_5 = require_model7();
      var model_6 = require_model8();
      var model_7 = require_model9();
      var model_8 = require_model6();
      var viewport_root_1 = require_viewport_root();
      var iterable_1 = require_iterable();
      var SGraphImpl2 = class extends viewport_root_1.ViewportRootElementImpl {
        constructor(index = new SGraphIndex()) {
          super(index);
        }
      };
      exports.SGraphImpl = SGraphImpl2;
      var SNodeImpl2 = class extends model_7.SConnectableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
        canConnect(routable, role) {
          return this.children.find((c) => c instanceof SPortImpl3) === void 0;
        }
        get incomingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getIncomingEdges(this);
          }
          const allEdges = this.index.all().filter((e) => e instanceof SEdgeImpl2);
          return allEdges.filter((e) => e.targetId === this.id);
        }
        get outgoingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getOutgoingEdges(this);
          }
          const allEdges = this.index.all().filter((e) => e instanceof SEdgeImpl2);
          return allEdges.filter((e) => e.sourceId === this.id);
        }
      };
      exports.SNodeImpl = SNodeImpl2;
      SNodeImpl2.DEFAULT_FEATURES = [
        model_7.connectableFeature,
        delete_1.deletableFeature,
        model_8.selectFeature,
        model_1.boundsFeature,
        model_6.moveFeature,
        model_1.layoutContainerFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature,
        model_5.popupFeature
      ];
      var SPortImpl3 = class extends model_7.SConnectableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
        get incomingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getIncomingEdges(this);
          }
          return super.incomingEdges.filter((e) => e instanceof SEdgeImpl2);
        }
        get outgoingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getOutgoingEdges(this);
          }
          return super.outgoingEdges.filter((e) => e instanceof SEdgeImpl2);
        }
      };
      exports.SPortImpl = SPortImpl3;
      SPortImpl3.DEFAULT_FEATURES = [
        model_7.connectableFeature,
        model_8.selectFeature,
        model_1.boundsFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature
      ];
      var SEdgeImpl2 = class extends model_7.SRoutableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
      };
      exports.SEdgeImpl = SEdgeImpl2;
      SEdgeImpl2.DEFAULT_FEATURES = [
        model_3.editFeature,
        delete_1.deletableFeature,
        model_8.selectFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature
      ];
      var SLabelImpl2 = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.alignment = geometry_1.Point.ORIGIN;
          this.opacity = 1;
        }
      };
      exports.SLabelImpl = SLabelImpl2;
      SLabelImpl2.DEFAULT_FEATURES = [
        model_1.boundsFeature,
        model_1.alignFeature,
        model_1.layoutableChildFeature,
        model_2.edgeLayoutFeature,
        model_4.fadeFeature
      ];
      var SCompartmentImpl2 = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.opacity = 1;
        }
      };
      exports.SCompartmentImpl = SCompartmentImpl2;
      SCompartmentImpl2.DEFAULT_FEATURES = [
        model_1.boundsFeature,
        model_1.layoutContainerFeature,
        model_1.layoutableChildFeature,
        model_4.fadeFeature
      ];
      var SGraphIndex = class extends smodel_1.ModelIndexImpl {
        constructor() {
          super(...arguments);
          this.outgoing = /* @__PURE__ */ new Map();
          this.incoming = /* @__PURE__ */ new Map();
        }
        add(element) {
          super.add(element);
          if (element instanceof SEdgeImpl2) {
            if (element.sourceId) {
              const sourceArr = this.outgoing.get(element.sourceId);
              if (sourceArr === void 0)
                this.outgoing.set(element.sourceId, [element]);
              else
                sourceArr.push(element);
            }
            if (element.targetId) {
              const targetArr = this.incoming.get(element.targetId);
              if (targetArr === void 0)
                this.incoming.set(element.targetId, [element]);
              else
                targetArr.push(element);
            }
          }
        }
        remove(element) {
          super.remove(element);
          if (element instanceof SEdgeImpl2) {
            const sourceArr = this.outgoing.get(element.sourceId);
            if (sourceArr !== void 0) {
              const index = sourceArr.indexOf(element);
              if (index >= 0) {
                if (sourceArr.length === 1)
                  this.outgoing.delete(element.sourceId);
                else
                  sourceArr.splice(index, 1);
              }
            }
            const targetArr = this.incoming.get(element.targetId);
            if (targetArr !== void 0) {
              const index = targetArr.indexOf(element);
              if (index >= 0) {
                if (targetArr.length === 1)
                  this.incoming.delete(element.targetId);
                else
                  targetArr.splice(index, 1);
              }
            }
          }
        }
        getAttachedElements(element) {
          return new iterable_1.FluentIterableImpl(() => ({
            outgoing: this.outgoing.get(element.id),
            incoming: this.incoming.get(element.id),
            nextOutgoingIndex: 0,
            nextIncomingIndex: 0
          }), (state) => {
            let index = state.nextOutgoingIndex;
            if (state.outgoing !== void 0 && index < state.outgoing.length) {
              state.nextOutgoingIndex = index + 1;
              return { done: false, value: state.outgoing[index] };
            }
            index = state.nextIncomingIndex;
            if (state.incoming !== void 0) {
              while (index < state.incoming.length) {
                const edge = state.incoming[index];
                if (edge.sourceId !== edge.targetId) {
                  state.nextIncomingIndex = index + 1;
                  return { done: false, value: edge };
                }
                index++;
              }
            }
            return { done: true, value: void 0 };
          });
        }
        getIncomingEdges(element) {
          return this.incoming.get(element.id) || [];
        }
        getOutgoingEdges(element) {
          return this.outgoing.get(element.id) || [];
        }
      };
      exports.SGraphIndex = SGraphIndex;
    }
  });

  // node_modules/sprotty/lib/features/routing/anchor.js
  var require_anchor = __commonJS({
    "node_modules/sprotty/lib/features/routing/anchor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnchorComputerRegistry = exports.RECTANGULAR_ANCHOR_KIND = exports.ELLIPTIC_ANCHOR_KIND = exports.DIAMOND_ANCHOR_KIND = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var registry_1 = require_registry();
      exports.DIAMOND_ANCHOR_KIND = "diamond";
      exports.ELLIPTIC_ANCHOR_KIND = "elliptic";
      exports.RECTANGULAR_ANCHOR_KIND = "rectangular";
      var AnchorComputerRegistry2 = class AnchorComputerRegistry extends registry_1.InstanceRegistry {
        constructor(anchors) {
          super();
          anchors.forEach((anchor) => this.register(anchor.kind, anchor));
        }
        get defaultAnchorKind() {
          return exports.RECTANGULAR_ANCHOR_KIND;
        }
        get(routerKind, anchorKind) {
          return super.get(`${routerKind}:${anchorKind || this.defaultAnchorKind}`);
        }
      };
      exports.AnchorComputerRegistry = AnchorComputerRegistry2;
      exports.AnchorComputerRegistry = AnchorComputerRegistry2 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IAnchorComputer)),
        __metadata("design:paramtypes", [Array])
      ], AnchorComputerRegistry2);
    }
  });

  // node_modules/sprotty/lib/features/routing/abstract-edge-router.js
  var require_abstract_edge_router = __commonJS({
    "node_modules/sprotty/lib/features/routing/abstract-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractEdgeRouter = exports.DefaultAnchors = exports.Side = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model9();
      var anchor_1 = require_anchor();
      var model_2 = require_model9();
      var Side;
      (function(Side2) {
        Side2[Side2["RIGHT"] = 0] = "RIGHT";
        Side2[Side2["LEFT"] = 1] = "LEFT";
        Side2[Side2["TOP"] = 2] = "TOP";
        Side2[Side2["BOTTOM"] = 3] = "BOTTOM";
      })(Side || (exports.Side = Side = {}));
      var DefaultAnchors = class {
        constructor(element, edgeParent, kind) {
          this.element = element;
          this.kind = kind;
          const bounds = element.bounds;
          this.bounds = (0, smodel_utils_1.translateBounds)(bounds, element.parent, edgeParent);
          this.left = { x: this.bounds.x, y: this.bounds.y + 0.5 * this.bounds.height, kind };
          this.right = { x: this.bounds.x + this.bounds.width, y: this.bounds.y + 0.5 * this.bounds.height, kind };
          this.top = { x: this.bounds.x + 0.5 * this.bounds.width, y: this.bounds.y, kind };
          this.bottom = { x: this.bounds.x + 0.5 * this.bounds.width, y: this.bounds.y + this.bounds.height, kind };
        }
        get(side) {
          return this[Side[side].toLowerCase()];
        }
        getNearestSide(point) {
          const leftDistance = geometry_1.Point.euclideanDistance(point, this.left);
          const rightDistance = geometry_1.Point.euclideanDistance(point, this.right);
          const topDistance = geometry_1.Point.euclideanDistance(point, this.top);
          const bottomDistance = geometry_1.Point.euclideanDistance(point, this.bottom);
          let currentNearestSide = Side.LEFT;
          let currentMinDist = leftDistance;
          if (rightDistance < currentMinDist) {
            currentMinDist = rightDistance;
            currentNearestSide = Side.RIGHT;
          }
          if (topDistance < currentMinDist) {
            currentMinDist = topDistance;
            currentNearestSide = Side.TOP;
          }
          if (bottomDistance < currentMinDist) {
            currentMinDist = bottomDistance;
            currentNearestSide = Side.BOTTOM;
          }
          return currentNearestSide;
        }
      };
      exports.DefaultAnchors = DefaultAnchors;
      var AbstractEdgeRouter = class AbstractEdgeRouter {
        pointAt(edge, t) {
          const segments = this.calculateSegment(edge, t);
          if (!segments)
            return void 0;
          const { segmentStart, segmentEnd, lambda } = segments;
          return geometry_1.Point.linear(segmentStart, segmentEnd, lambda);
        }
        derivativeAt(edge, t) {
          const segments = this.calculateSegment(edge, t);
          if (!segments)
            return void 0;
          const { segmentStart, segmentEnd } = segments;
          return {
            x: segmentEnd.x - segmentStart.x,
            y: segmentEnd.y - segmentStart.y
          };
        }
        calculateSegment(edge, t) {
          if (t < 0 || t > 1)
            return void 0;
          const routedPoints = this.route(edge);
          if (routedPoints.length < 2)
            return void 0;
          const segmentLengths = [];
          let totalLength = 0;
          for (let i = 0; i < routedPoints.length - 1; ++i) {
            segmentLengths[i] = geometry_1.Point.euclideanDistance(routedPoints[i], routedPoints[i + 1]);
            totalLength += segmentLengths[i];
          }
          let currentLenght = 0;
          const tAsLenght = t * totalLength;
          for (let i = 0; i < routedPoints.length - 1; ++i) {
            const newLength = currentLenght + segmentLengths[i];
            if (segmentLengths[i] > 1e-8) {
              if (newLength >= tAsLenght) {
                const lambda = Math.max(0, tAsLenght - currentLenght) / segmentLengths[i];
                return {
                  segmentStart: routedPoints[i],
                  segmentEnd: routedPoints[i + 1],
                  lambda
                };
              }
            }
            currentLenght = newLength;
          }
          return {
            segmentEnd: routedPoints.pop(),
            segmentStart: routedPoints.pop(),
            lambda: 1
          };
        }
        addHandle(edge, kind, type, routingPointIndex) {
          const handle = new model_1.SRoutingHandleImpl();
          handle.kind = kind;
          handle.pointIndex = routingPointIndex;
          handle.type = type;
          if (kind === "target" && edge.id === model_1.edgeInProgressID)
            handle.id = model_1.edgeInProgressTargetHandleID;
          edge.add(handle);
          return handle;
        }
        getHandlePosition(edge, route, handle) {
          switch (handle.kind) {
            case "source":
              if (edge.source instanceof model_1.SDanglingAnchorImpl)
                return edge.source.position;
              else
                return route[0];
            case "target":
              if (edge.target instanceof model_1.SDanglingAnchorImpl)
                return edge.target.position;
              else {
                return route[route.length - 1];
              }
            default:
              const position = this.getInnerHandlePosition(edge, route, handle);
              if (position !== void 0)
                return position;
              if (handle.pointIndex >= 0 && handle.pointIndex < edge.routingPoints.length)
                return edge.routingPoints[handle.pointIndex];
          }
          return void 0;
        }
        findRouteSegment(edge, route, handleIndex) {
          const getIndex = (rp) => {
            if (rp.pointIndex !== void 0)
              return rp.pointIndex;
            else if (rp.kind === "target")
              return edge.routingPoints.length;
            else
              return -2;
          };
          let start, end;
          for (const rp of route) {
            const i = getIndex(rp);
            if (i <= handleIndex && (start === void 0 || i > getIndex(start)))
              start = rp;
            if (i > handleIndex && (end === void 0 || i < getIndex(end)))
              end = rp;
          }
          return { start, end };
        }
        getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection = 0) {
          const translatedRefPoint = (0, smodel_utils_1.translatePoint)(refPoint, refContainer, connectable.parent);
          const anchorComputer = this.getAnchorComputer(connectable);
          const strokeCorrection = 0.5 * connectable.strokeWidth;
          const anchor = anchorComputer.getAnchor(connectable, translatedRefPoint, anchorCorrection + strokeCorrection);
          return (0, smodel_utils_1.translatePoint)(anchor, connectable.parent, edge.parent);
        }
        getAnchorComputer(connectable) {
          return this.anchorRegistry.get(this.kind, connectable.anchorKind);
        }
        applyHandleMoves(edge, moves) {
          const remainingMoves = moves.slice();
          moves.forEach((move) => {
            const handle = move.handle;
            if (handle.kind === "source" && !(edge.source instanceof model_1.SDanglingAnchorImpl)) {
              const anchor = new model_1.SDanglingAnchorImpl();
              anchor.id = edge.id + "_dangling-source";
              anchor.original = edge.source;
              anchor.position = move.toPosition;
              handle.root.add(anchor);
              handle.danglingAnchor = anchor;
              edge.sourceId = anchor.id;
            } else if (handle.kind === "target" && !(edge.target instanceof model_1.SDanglingAnchorImpl)) {
              const anchor = new model_1.SDanglingAnchorImpl();
              anchor.id = edge.id + "_dangling-target";
              anchor.original = edge.target;
              anchor.position = move.toPosition;
              handle.root.add(anchor);
              handle.danglingAnchor = anchor;
              edge.targetId = anchor.id;
            }
            if (handle.danglingAnchor) {
              handle.danglingAnchor.position = move.toPosition;
              remainingMoves.splice(remainingMoves.indexOf(move), 1);
            }
          });
          if (remainingMoves.length > 0)
            this.applyInnerHandleMoves(edge, remainingMoves);
          this.cleanupRoutingPoints(edge, edge.routingPoints, true, true);
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          const sourceAnchors = new DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new DefaultAnchors(edge.target, edge.parent, "target");
          this.resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors);
        }
        resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors) {
          if (routingPoints.length === 0 || edge.source instanceof model_1.SDanglingAnchorImpl || edge.target instanceof model_1.SDanglingAnchorImpl) {
            const options = this.getOptions(edge);
            const corners = this.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
            routingPoints.splice(0, routingPoints.length, ...corners);
            if (updateHandles) {
              let maxPointIndex = -2;
              edge.children.forEach((child) => {
                if (child instanceof model_1.SRoutingHandleImpl) {
                  if (child.kind === "target")
                    child.pointIndex = routingPoints.length;
                  else if (child.kind === "line" && child.pointIndex >= routingPoints.length)
                    edge.remove(child);
                  else
                    maxPointIndex = Math.max(child.pointIndex, maxPointIndex);
                }
              });
              for (let i = maxPointIndex; i < routingPoints.length - 1; ++i)
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", i);
            }
            return true;
          }
          return false;
        }
        applyReconnect(edge, newSourceId, newTargetId) {
          let hasChanged = false;
          if (newSourceId) {
            const newSource = edge.root.index.getById(newSourceId);
            if (newSource instanceof model_2.SConnectableElementImpl) {
              edge.sourceId = newSource.id;
              hasChanged = true;
            }
          }
          if (newTargetId) {
            const newTarget = edge.root.index.getById(newTargetId);
            if (newTarget instanceof model_2.SConnectableElementImpl) {
              edge.targetId = newTarget.id;
              hasChanged = true;
            }
          }
          if (hasChanged) {
            edge.index.remove(edge);
            edge.index.add(edge);
            if (this.getSelfEdgeIndex(edge) > -1) {
              edge.routingPoints = [];
              this.cleanupRoutingPoints(edge, edge.routingPoints, true, true);
            }
          }
        }
        takeSnapshot(edge) {
          return {
            routingPoints: edge.routingPoints.slice(),
            routingHandles: edge.children.filter((child) => child instanceof model_1.SRoutingHandleImpl).map((child) => child),
            routedPoints: this.route(edge),
            router: this,
            source: edge.source,
            target: edge.target
          };
        }
        applySnapshot(edge, snapshot) {
          edge.routingPoints = snapshot.routingPoints;
          edge.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
          edge.routerKind = snapshot.router.kind;
          snapshot.routingHandles.forEach((handle) => edge.add(handle));
          if (snapshot.source)
            edge.sourceId = snapshot.source.id;
          if (snapshot.target)
            edge.targetId = snapshot.target.id;
          edge.root.index.remove(edge);
          edge.root.index.add(edge);
        }
        calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options) {
          const selfEdgeIndex = this.getSelfEdgeIndex(edge);
          if (selfEdgeIndex >= 0) {
            const standardDist = options.standardDistance;
            const delta = options.selfEdgeOffset * Math.min(sourceAnchors.bounds.width, sourceAnchors.bounds.height);
            switch (selfEdgeIndex % 4) {
              case 0:
                return [
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.RIGHT).y + delta },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.BOTTOM).x + delta, y: sourceAnchors.get(Side.BOTTOM).y + standardDist }
                ];
              case 1:
                return [
                  { x: sourceAnchors.get(Side.BOTTOM).x - delta, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.LEFT).y + delta }
                ];
              case 2:
                return [
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.LEFT).y - delta },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.TOP).x - delta, y: sourceAnchors.get(Side.TOP).y - standardDist }
                ];
              case 3:
                return [
                  { x: sourceAnchors.get(Side.TOP).x + delta, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.RIGHT).y - delta }
                ];
            }
          }
          return [];
        }
        getSelfEdgeIndex(edge) {
          if (!edge.source || edge.source !== edge.target)
            return -1;
          return edge.source.outgoingEdges.filter((otherEdge) => otherEdge.target === edge.source).indexOf(edge);
        }
        commitRoute(edge, routedPoints) {
          const newRoutingPoints = [];
          for (let i = 1; i < routedPoints.length - 1; ++i)
            newRoutingPoints.push({ x: routedPoints[i].x, y: routedPoints[i].y });
          edge.routingPoints = newRoutingPoints;
        }
      };
      exports.AbstractEdgeRouter = AbstractEdgeRouter;
      __decorate([
        (0, inversify_1.inject)(anchor_1.AnchorComputerRegistry),
        __metadata("design:type", anchor_1.AnchorComputerRegistry)
      ], AbstractEdgeRouter.prototype, "anchorRegistry", void 0);
      exports.AbstractEdgeRouter = AbstractEdgeRouter = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractEdgeRouter);
    }
  });

  // node_modules/sprotty/lib/features/routing/polyline-edge-router.js
  var require_polyline_edge_router = __commonJS({
    "node_modules/sprotty/lib/features/routing/polyline-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var PolylineEdgeRouter_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PolylineEdgeRouter = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var model_1 = require_model9();
      var anchor_1 = require_anchor();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var PolylineEdgeRouter2 = PolylineEdgeRouter_1 = class PolylineEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return PolylineEdgeRouter_1.KIND;
        }
        getOptions(edge) {
          return {
            minimalPointDistance: 2,
            removeAngleThreshold: 0.1,
            standardDistance: 20,
            selfEdgeOffset: 0.25
          };
        }
        route(edge) {
          const source = edge.source;
          const target = edge.target;
          if (source === void 0 || target === void 0) {
            return [];
          }
          let sourceAnchor;
          let targetAnchor;
          const options = this.getOptions(edge);
          const routingPoints = edge.routingPoints.length > 0 ? edge.routingPoints : [];
          this.cleanupRoutingPoints(edge, routingPoints, false, false);
          const rpCount = routingPoints !== void 0 ? routingPoints.length : 0;
          if (rpCount === 0) {
            const startRef = geometry_1.Bounds.center(target.bounds);
            sourceAnchor = this.getTranslatedAnchor(source, startRef, target.parent, edge, edge.sourceAnchorCorrection);
            const endRef = geometry_1.Bounds.center(source.bounds);
            targetAnchor = this.getTranslatedAnchor(target, endRef, source.parent, edge, edge.targetAnchorCorrection);
          } else {
            const p0 = routingPoints[0];
            sourceAnchor = this.getTranslatedAnchor(source, p0, edge.parent, edge, edge.sourceAnchorCorrection);
            const pn = routingPoints[rpCount - 1];
            targetAnchor = this.getTranslatedAnchor(target, pn, edge.parent, edge, edge.targetAnchorCorrection);
          }
          const result = [];
          result.push({ kind: "source", x: sourceAnchor.x, y: sourceAnchor.y });
          for (let i = 0; i < rpCount; i++) {
            const p = routingPoints[i];
            if (i > 0 && i < rpCount - 1 || i === 0 && geometry_1.Point.maxDistance(sourceAnchor, p) >= options.minimalPointDistance + (edge.sourceAnchorCorrection || 0) || i === rpCount - 1 && geometry_1.Point.maxDistance(p, targetAnchor) >= options.minimalPointDistance + (edge.targetAnchorCorrection || 0)) {
              result.push({ kind: "linear", x: p.x, y: p.y, pointIndex: i });
            }
          }
          result.push({ kind: "target", x: targetAnchor.x, y: targetAnchor.y });
          return this.filterEditModeHandles(result, edge, options);
        }
        /**
         * Remove routed points that are in edit mode and for which the angle between the preceding and
         * following points falls below a threshold.
         */
        filterEditModeHandles(route, edge, options) {
          if (edge.children.length === 0)
            return route;
          let i = 0;
          while (i < route.length) {
            const curr = route[i];
            if (curr.pointIndex !== void 0) {
              const handle = edge.children.find((child) => child instanceof model_1.SRoutingHandleImpl && child.kind === "junction" && child.pointIndex === curr.pointIndex);
              if (handle !== void 0 && handle.editMode && i > 0 && i < route.length - 1) {
                const prev = route[i - 1], next = route[i + 1];
                const prevDiff = { x: prev.x - curr.x, y: prev.y - curr.y };
                const nextDiff = { x: next.x - curr.x, y: next.y - curr.y };
                const angle = (0, geometry_1.angleBetweenPoints)(prevDiff, nextDiff);
                if (Math.abs(Math.PI - angle) < options.removeAngleThreshold) {
                  route.splice(i, 1);
                  continue;
                }
              }
            }
            i++;
          }
          return route;
        }
        createRoutingHandles(edge) {
          const rpCount = edge.routingPoints.length;
          this.addHandle(edge, "source", "routing-point", -2);
          this.addHandle(edge, "line", "volatile-routing-point", -1);
          for (let i = 0; i < rpCount; i++) {
            this.addHandle(edge, "junction", "routing-point", i);
            this.addHandle(edge, "line", "volatile-routing-point", i);
          }
          this.addHandle(edge, "target", "routing-point", rpCount);
        }
        getInnerHandlePosition(edge, route, handle) {
          if (handle.kind === "line") {
            const { start, end } = this.findRouteSegment(edge, route, handle.pointIndex);
            if (start !== void 0 && end !== void 0)
              return (0, geometry_1.centerOfLine)(start, end);
          }
          return void 0;
        }
        applyInnerHandleMoves(edge, moves) {
          moves.forEach((move) => {
            const handle = move.handle;
            const points = edge.routingPoints;
            let index = handle.pointIndex;
            if (handle.kind === "line") {
              handle.kind = "junction";
              handle.type = "routing-point";
              points.splice(index + 1, 0, move.fromPosition || points[Math.max(index, 0)]);
              edge.children.forEach((child) => {
                if (child instanceof model_1.SRoutingHandleImpl && (child === handle || child.pointIndex > index))
                  child.pointIndex++;
              });
              this.addHandle(edge, "line", "volatile-routing-point", index);
              index++;
              this.addHandle(edge, "line", "volatile-routing-point", index);
            }
            if (index >= 0 && index < points.length) {
              points[index] = move.toPosition;
            }
          });
        }
      };
      exports.PolylineEdgeRouter = PolylineEdgeRouter2;
      PolylineEdgeRouter2.KIND = "polyline";
      __decorate([
        (0, inversify_1.inject)(anchor_1.AnchorComputerRegistry),
        __metadata("design:type", anchor_1.AnchorComputerRegistry)
      ], PolylineEdgeRouter2.prototype, "anchorRegistry", void 0);
      exports.PolylineEdgeRouter = PolylineEdgeRouter2 = PolylineEdgeRouter_1 = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeRouter2);
    }
  });

  // node_modules/sprotty/lib/features/routing/routing.js
  var require_routing = __commonJS({
    "node_modules/sprotty/lib/features/routing/routing.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeRouting = exports.EdgeRouterRegistry = void 0;
      var inversify_1 = require_inversify();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var view_1 = require_view();
      var registry_1 = require_registry();
      var model_1 = require_model9();
      var polyline_edge_router_1 = require_polyline_edge_router();
      function isMultipleEdgesRouter(router) {
        return router.routeAll !== void 0;
      }
      var EdgeRouterRegistry = class EdgeRouterRegistry extends registry_1.InstanceRegistry {
        constructor(edgeRouters) {
          super();
          edgeRouters.forEach((router) => this.register(router.kind, router));
        }
        get defaultKind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND;
        }
        get(kind) {
          return super.get(kind || this.defaultKind);
        }
        /**
         * Computes the routes of all edges contained by the specified `parent`.
         * After all routes are available, it'll apply the registered `EdgeRoutePostProcessors`.
         * @param parent the parent to traverse for edges
         * @returns the routes of all edges that are children of `parent`
         */
        routeAllChildren(parent) {
          const routing = this.doRouteAllChildren(parent);
          for (const postProcessor of this.postProcessors) {
            postProcessor.apply(routing);
          }
          return routing;
        }
        /**
         * Recursively traverses the children of `parent`, collects children grouped by router kind,
         * and then routes them either.
         * @param parent the parent to traverse for edges
         * @returns the routes of all edges that are children of `parent`
         */
        doRouteAllChildren(parent) {
          const routing = new EdgeRouting();
          const routersEdges = /* @__PURE__ */ new Map();
          const elementsToProcess = [parent];
          while (elementsToProcess.length > 0) {
            const element = elementsToProcess.shift();
            for (const child of element.children) {
              if (child instanceof model_1.SRoutableElementImpl) {
                const routerKind = child.routerKind || this.defaultKind;
                if (routersEdges.has(routerKind)) {
                  routersEdges.get(routerKind).push(child);
                } else {
                  routersEdges.set(routerKind, [child]);
                }
              }
              if (child instanceof smodel_1.SParentElementImpl) {
                elementsToProcess.push(child);
              }
            }
          }
          routersEdges.forEach((edges, routerKind) => {
            const childRouter = this.get(routerKind);
            if (isMultipleEdgesRouter(childRouter)) {
              routing.setAll(childRouter.routeAll(edges, parent));
            } else {
              for (const edge of edges) {
                routing.set(edge.id, this.route(edge));
              }
            }
          });
          return routing;
        }
        /**
         * Computes or obtains the route of a single edge.
         * @param edge the edge to be routed
         * @param args arguments that may contain an `EdgeRouting` already
         * @returns the route of the specified `edge`
         */
        route(edge, args) {
          const edgeRouting = (0, view_1.findArgValue)(args, "edgeRouting");
          if (edgeRouting) {
            const route = edgeRouting.get(edge.id);
            if (route) {
              return route;
            }
          }
          const router = this.get(edge.routerKind);
          return router.route(edge);
        }
      };
      exports.EdgeRouterRegistry = EdgeRouterRegistry;
      __decorate([
        (0, inversify_1.multiInject)(types_1.TYPES.IEdgeRoutePostprocessor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], EdgeRouterRegistry.prototype, "postProcessors", void 0);
      exports.EdgeRouterRegistry = EdgeRouterRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IEdgeRouter)),
        __metadata("design:paramtypes", [Array])
      ], EdgeRouterRegistry);
      var EdgeRouting = class {
        constructor() {
          this.routesMap = /* @__PURE__ */ new Map();
        }
        set(routableId, route) {
          this.routesMap.set(routableId, route);
        }
        setAll(otherRoutes) {
          otherRoutes.routes.forEach((route, routableId) => this.set(routableId, route));
        }
        get(routableId) {
          return this.routesMap.get(routableId);
        }
        get routes() {
          return this.routesMap;
        }
      };
      exports.EdgeRouting = EdgeRouting;
    }
  });

  // node_modules/sprotty/lib/features/edge-layout/edge-layout.js
  var require_edge_layout = __commonJS({
    "node_modules/sprotty/lib/features/edge-layout/edge-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeLayoutPostprocessor = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var sgraph_1 = require_sgraph();
      var model_1 = require_model2();
      var model_2 = require_model10();
      var routing_1 = require_routing();
      var EdgeLayoutPostprocessor = class EdgeLayoutPostprocessor {
        decorate(vnode, element) {
          if ((0, model_2.isEdgeLayoutable)(element) && element.parent instanceof sgraph_1.SEdgeImpl) {
            if (element.bounds !== geometry_1.Bounds.EMPTY) {
              const placement = this.getEdgePlacement(element);
              const edge = element.parent;
              const position = Math.min(1, Math.max(0, placement.position));
              const router = this.edgeRouterRegistry.get(edge.routerKind);
              const pointOnEdge = router.pointAt(edge, position);
              const derivativeOnEdge = router.derivativeAt(edge, position);
              let transform = "";
              if (pointOnEdge && derivativeOnEdge) {
                transform += `translate(${pointOnEdge.x}, ${pointOnEdge.y})`;
                const angle = (0, geometry_1.toDegrees)(Math.atan2(derivativeOnEdge.y, derivativeOnEdge.x));
                if (placement.rotate) {
                  let flippedAngle = angle;
                  if (Math.abs(angle) > 90) {
                    if (angle < 0)
                      flippedAngle += 180;
                    else if (angle > 0)
                      flippedAngle -= 180;
                  }
                  transform += ` rotate(${flippedAngle})`;
                  const alignment = this.getRotatedAlignment(element, placement, flippedAngle !== angle);
                  transform += ` translate(${alignment.x}, ${alignment.y})`;
                } else {
                  const alignment = this.getAlignment(element, placement, angle);
                  transform += ` translate(${alignment.x}, ${alignment.y})`;
                }
                (0, vnode_utils_1.setAttr)(vnode, "transform", transform);
              }
            }
          }
          return vnode;
        }
        getRotatedAlignment(element, placement, flip) {
          let x = (0, model_1.isAlignable)(element) ? element.alignment.x : 0;
          let y = (0, model_1.isAlignable)(element) ? element.alignment.y : 0;
          const bounds = element.bounds;
          if (placement.side === "on")
            return { x: x - 0.5 * bounds.height, y: y - 0.5 * bounds.height };
          if (flip) {
            if (placement.position < 0.3333333)
              x -= bounds.width + placement.offset;
            else if (placement.position < 0.6666666)
              x -= 0.5 * bounds.width;
            else
              x += placement.offset;
            switch (placement.side) {
              case "left":
              case "bottom":
                y -= placement.offset + bounds.height;
                break;
              case "right":
              case "top":
                y += placement.offset;
            }
          } else {
            if (placement.position < 0.3333333)
              x += placement.offset;
            else if (placement.position < 0.6666666)
              x -= 0.5 * bounds.width;
            else
              x -= bounds.width + placement.offset;
            switch (placement.side) {
              case "right":
              case "bottom":
                y += -placement.offset - bounds.height;
                break;
              case "left":
              case "top":
                y += placement.offset;
            }
          }
          return { x, y };
        }
        getEdgePlacement(element) {
          let current = element;
          const allPlacements = [];
          while (current !== void 0) {
            const placement = current.edgePlacement;
            if (placement !== void 0)
              allPlacements.push(placement);
            if (current instanceof smodel_1.SChildElementImpl)
              current = current.parent;
            else
              break;
          }
          return allPlacements.reverse().reduce((a, b) => {
            return Object.assign(Object.assign({}, a), b);
          }, model_2.DEFAULT_EDGE_PLACEMENT);
        }
        getAlignment(label, placement, angle) {
          const bounds = label.bounds;
          const x = (0, model_1.isAlignable)(label) ? label.alignment.x - bounds.width : 0;
          const y = (0, model_1.isAlignable)(label) ? label.alignment.y - bounds.height : 0;
          if (placement.side === "on") {
            return { x: x + 0.5 * bounds.width, y: y + 0.5 * bounds.height };
          }
          const quadrant = this.getQuadrant(angle);
          const midLeft = { x: placement.offset, y: y + 0.5 * bounds.height };
          const topLeft = { x: placement.offset, y: y + bounds.height + placement.offset };
          const topRight = { x: -bounds.width - placement.offset, y: y + bounds.height + placement.offset };
          const midRight = { x: -bounds.width - placement.offset, y: y + 0.5 * bounds.height };
          const bottomRight = { x: -bounds.width - placement.offset, y: y - placement.offset };
          const bottomLeft = { x: placement.offset, y: y - placement.offset };
          switch (placement.side) {
            case "left":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "north":
                  return geometry_1.Point.linear(topRight, bottomRight, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "south":
                  return geometry_1.Point.linear(bottomLeft, topLeft, quadrant.position);
              }
              break;
            case "right":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "north":
                  return geometry_1.Point.linear(bottomLeft, topLeft, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "south":
                  return geometry_1.Point.linear(topRight, bottomRight, quadrant.position);
              }
              break;
            case "top":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "north":
                  return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "south":
                  return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
              }
              break;
            case "bottom":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "north":
                  return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "south":
                  return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
              }
              break;
          }
          return { x: 0, y: 0 };
        }
        getQuadrant(angle) {
          if (Math.abs(angle) > 135)
            return { orientation: "west", position: (angle > 0 ? angle - 135 : angle + 225) / 90 };
          else if (angle < -45)
            return { orientation: "north", position: (angle + 135) / 90 };
          else if (angle < 45)
            return { orientation: "east", position: (angle + 45) / 90 };
          else
            return { orientation: "south", position: (angle - 45) / 90 };
        }
        linearFlip(p0, p1, p2, p3, position) {
          return position < 0.5 ? geometry_1.Point.linear(p0, p1, 2 * position) : geometry_1.Point.linear(p2, p3, 2 * position - 1);
        }
        postUpdate() {
        }
      };
      exports.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], EdgeLayoutPostprocessor.prototype, "edgeRouterRegistry", void 0);
      exports.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeLayoutPostprocessor);
    }
  });

  // node_modules/sprotty/lib/features/edge-layout/di.config.js
  var require_di_config2 = __commonJS({
    "node_modules/sprotty/lib/features/edge-layout/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var edge_layout_1 = require_edge_layout();
      var edgeLayoutModule = new inversify_1.ContainerModule((bind) => {
        bind(edge_layout_1.EdgeLayoutPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(edge_layout_1.EdgeLayoutPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(edge_layout_1.EdgeLayoutPostprocessor);
      });
      exports.default = edgeLayoutModule;
    }
  });

  // node_modules/sprotty/lib/features/edit/create.js
  var require_create = __commonJS({
    "node_modules/sprotty/lib/features/edit/create.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CreateElementCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var CreateElementCommand = class CreateElementCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const container = context.root.index.getById(this.action.containerId);
          if (container instanceof smodel_1.SParentElementImpl) {
            this.container = container;
            this.newElement = context.modelFactory.createElement(this.action.elementSchema);
            this.container.add(this.newElement);
          }
          return context.root;
        }
        undo(context) {
          this.container.remove(this.newElement);
          return context.root;
        }
        redo(context) {
          this.container.add(this.newElement);
          return context.root;
        }
      };
      exports.CreateElementCommand = CreateElementCommand;
      CreateElementCommand.KIND = actions_1.CreateElementAction.KIND;
      exports.CreateElementCommand = CreateElementCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CreateElementCommand);
    }
  });

  // node_modules/sprotty/lib/features/edit/create-on-drag.js
  var require_create_on_drag = __commonJS({
    "node_modules/sprotty/lib/features/edit/create-on-drag.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isCreatingOnDrag = exports.creatingOnDragFeature = void 0;
      exports.creatingOnDragFeature = Symbol("creatingOnDragFeature");
      function isCreatingOnDrag(element) {
        return element.hasFeature(exports.creatingOnDragFeature) && element.createAction !== void 0;
      }
      exports.isCreatingOnDrag = isCreatingOnDrag;
    }
  });

  // node_modules/sprotty/lib/lib/svg-views.js
  var require_svg_views = __commonJS({
    "node_modules/sprotty/lib/lib/svg-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EmptyGroupView = exports.DiamondNodeView = exports.RectangularNodeView = exports.CircularNodeView = exports.SvgViewportView = void 0;
      var jsx_1 = require_jsx();
      var sgraph_1 = require_sgraph();
      var views_1 = require_views();
      var geometry_1 = require_geometry2();
      var inversify_1 = require_inversify();
      var SvgViewportView = class SvgViewportView {
        render(model, context, args) {
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          return (0, jsx_1.svg)(
            "svg",
            null,
            (0, jsx_1.svg)("g", { transform }, context.renderChildren(model))
          );
        }
      };
      exports.SvgViewportView = SvgViewportView;
      exports.SvgViewportView = SvgViewportView = __decorate([
        (0, inversify_1.injectable)()
      ], SvgViewportView);
      var CircularNodeView = class CircularNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          const radius = this.getRadius(node);
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("circle", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, r: radius, cx: radius, cy: radius }),
            context.renderChildren(node)
          );
        }
        getRadius(node) {
          const d = Math.min(node.size.width, node.size.height);
          return d > 0 ? d / 2 : 0;
        }
      };
      exports.CircularNodeView = CircularNodeView;
      exports.CircularNodeView = CircularNodeView = __decorate([
        (0, inversify_1.injectable)()
      ], CircularNodeView);
      var RectangularNodeView = class RectangularNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("rect", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, x: "0", y: "0", width: Math.max(node.size.width, 0), height: Math.max(node.size.height, 0) }),
            context.renderChildren(node)
          );
        }
      };
      exports.RectangularNodeView = RectangularNodeView;
      exports.RectangularNodeView = RectangularNodeView = __decorate([
        (0, inversify_1.injectable)()
      ], RectangularNodeView);
      var DiamondNodeView = class DiamondNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          const diamond = new geometry_1.Diamond({ height: Math.max(node.size.height, 0), width: Math.max(node.size.width, 0), x: 0, y: 0 });
          const points = `${svgStr(diamond.topPoint)} ${svgStr(diamond.rightPoint)} ${svgStr(diamond.bottomPoint)} ${svgStr(diamond.leftPoint)}`;
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("polygon", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, points }),
            context.renderChildren(node)
          );
        }
      };
      exports.DiamondNodeView = DiamondNodeView;
      exports.DiamondNodeView = DiamondNodeView = __decorate([
        (0, inversify_1.injectable)()
      ], DiamondNodeView);
      function svgStr(point) {
        return `${point.x},${point.y}`;
      }
      var EmptyGroupView = class EmptyGroupView {
        render(model, context) {
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.EmptyGroupView = EmptyGroupView;
      exports.EmptyGroupView = EmptyGroupView = __decorate([
        (0, inversify_1.injectable)()
      ], EmptyGroupView);
    }
  });

  // node_modules/sprotty/lib/features/edit/edit-label.js
  var require_edit_label = __commonJS({
    "node_modules/sprotty/lib/features/edit/edit-label.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getEditableLabel = exports.EditLabelKeyListener = exports.EditLabelMouseListener = exports.ApplyLabelEditCommand = exports.ResolvedLabelEdit = exports.isApplyLabelEditAction = exports.isEditLabelAction = exports.EditLabelAction = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var key_tool_1 = require_key_tool();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model6();
      var iterable_1 = require_iterable();
      var model_2 = require_model11();
      var EditLabelAction;
      (function(EditLabelAction2) {
        EditLabelAction2.KIND = "EditLabel";
        function create(labelId) {
          return {
            kind: EditLabelAction2.KIND,
            labelId
          };
        }
        EditLabelAction2.create = create;
      })(EditLabelAction || (exports.EditLabelAction = EditLabelAction = {}));
      function isEditLabelAction(element) {
        return (0, actions_1.isAction)(element) && element.kind === EditLabelAction.KIND && "labelId" in element;
      }
      exports.isEditLabelAction = isEditLabelAction;
      function isApplyLabelEditAction(element) {
        return (0, actions_1.isAction)(element) && element.kind === actions_1.ApplyLabelEditAction.KIND && "labelId" in element && "text" in element;
      }
      exports.isApplyLabelEditAction = isApplyLabelEditAction;
      var ResolvedLabelEdit = class {
      };
      exports.ResolvedLabelEdit = ResolvedLabelEdit;
      var ApplyLabelEditCommand = class ApplyLabelEditCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const index = context.root.index;
          const label = index.getById(this.action.labelId);
          if (label && (0, model_2.isEditableLabel)(label)) {
            this.resolvedLabelEdit = { label, oldLabel: label.text, newLabel: this.action.text };
            label.text = this.action.text;
          }
          return context.root;
        }
        undo(context) {
          if (this.resolvedLabelEdit) {
            this.resolvedLabelEdit.label.text = this.resolvedLabelEdit.oldLabel;
          }
          return context.root;
        }
        redo(context) {
          if (this.resolvedLabelEdit) {
            this.resolvedLabelEdit.label.text = this.resolvedLabelEdit.newLabel;
          }
          return context.root;
        }
      };
      exports.ApplyLabelEditCommand = ApplyLabelEditCommand;
      ApplyLabelEditCommand.KIND = actions_1.ApplyLabelEditAction.KIND;
      exports.ApplyLabelEditCommand = ApplyLabelEditCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ApplyLabelEditCommand);
      var EditLabelMouseListener = class extends mouse_tool_1.MouseListener {
        doubleClick(target, event) {
          const editableLabel = getEditableLabel(target);
          if (editableLabel) {
            return [EditLabelAction.create(editableLabel.id)];
          }
          return [];
        }
      };
      exports.EditLabelMouseListener = EditLabelMouseListener;
      var EditLabelKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "F2")) {
            const editableLabels = (0, iterable_1.toArray)(element.index.all().filter((e) => (0, model_1.isSelectable)(e) && e.selected)).map(getEditableLabel).filter((e) => e !== void 0);
            if (editableLabels.length === 1) {
              return [EditLabelAction.create(editableLabels[0].id)];
            }
          }
          return [];
        }
      };
      exports.EditLabelKeyListener = EditLabelKeyListener;
      function getEditableLabel(element) {
        if ((0, model_2.isEditableLabel)(element)) {
          return element;
        } else if ((0, model_2.isWithEditableLabel)(element) && element.editableLabel) {
          return element.editableLabel;
        }
        return void 0;
      }
      exports.getEditableLabel = getEditableLabel;
    }
  });

  // node_modules/sprotty/lib/features/export/svg-exporter.js
  var require_svg_exporter = __commonJS({
    "node_modules/sprotty/lib/features/export/svg-exporter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SvgExporter = exports.ExportSvgAction = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var model_1 = require_model2();
      var action_dispatcher_1 = require_action_dispatcher();
      var types_1 = require_types();
      var ExportSvgAction;
      (function(ExportSvgAction2) {
        ExportSvgAction2.KIND = "exportSvg";
        function create(svg3, requestId) {
          return {
            kind: ExportSvgAction2.KIND,
            svg: svg3,
            responseId: requestId
          };
        }
        ExportSvgAction2.create = create;
      })(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
      var SvgExporter = class SvgExporter {
        export(root, request) {
          if (typeof document !== "undefined") {
            const div = document.getElementById(this.options.hiddenDiv);
            if (div !== null && div.firstElementChild && div.firstElementChild.tagName === "svg") {
              const svgElement = div.firstElementChild;
              const svg3 = this.createSvg(svgElement, root);
              this.actionDispatcher.dispatch(ExportSvgAction.create(svg3, request ? request.requestId : ""));
            }
          }
        }
        createSvg(svgElementOrig, root) {
          const serializer = new XMLSerializer();
          const svgCopy = serializer.serializeToString(svgElementOrig);
          const iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          if (!iframe.contentWindow)
            throw new Error("IFrame has no contentWindow");
          const docCopy = iframe.contentWindow.document;
          docCopy.open();
          docCopy.write(svgCopy);
          docCopy.close();
          const svgElementNew = docCopy.getElementById(svgElementOrig.id);
          svgElementNew.removeAttribute("opacity");
          this.copyStyles(svgElementOrig, svgElementNew, ["width", "height", "opacity"]);
          svgElementNew.setAttribute("version", "1.1");
          const bounds = this.getBounds(root);
          svgElementNew.setAttribute("viewBox", `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
          const svgCode = serializer.serializeToString(svgElementNew);
          document.body.removeChild(iframe);
          return svgCode;
        }
        copyStyles(source, target, skipedProperties) {
          const sourceStyle = getComputedStyle(source);
          const targetStyle = getComputedStyle(target);
          let diffStyle = "";
          for (let i = 0; i < sourceStyle.length; i++) {
            const key = sourceStyle[i];
            if (skipedProperties.indexOf(key) === -1) {
              const value = sourceStyle.getPropertyValue(key);
              if (targetStyle.getPropertyValue(key) !== value) {
                diffStyle += key + ":" + value + ";";
              }
            }
          }
          if (diffStyle !== "")
            target.setAttribute("style", diffStyle);
          for (let i = 0; i < source.childNodes.length; ++i) {
            const sourceChild = source.childNodes[i];
            const targetChild = target.childNodes[i];
            if (sourceChild instanceof Element)
              this.copyStyles(sourceChild, targetChild, []);
          }
        }
        getBounds(root) {
          const allBounds = [geometry_1.Bounds.EMPTY];
          root.children.forEach((element) => {
            if ((0, model_1.isBoundsAware)(element)) {
              allBounds.push(element.bounds);
            }
          });
          return allBounds.reduce((one, two) => geometry_1.Bounds.combine(one, two));
        }
      };
      exports.SvgExporter = SvgExporter;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], SvgExporter.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.ActionDispatcher)
      ], SvgExporter.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], SvgExporter.prototype, "log", void 0);
      exports.SvgExporter = SvgExporter = __decorate([
        (0, inversify_1.injectable)()
      ], SvgExporter);
    }
  });

  // node_modules/sprotty/lib/model-source/model-source.js
  var require_model_source = __commonJS({
    "node_modules/sprotty/lib/model-source/model-source.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ComputedBoundsApplicator = exports.ModelSource = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var model_utils_1 = require_model_utils();
      var types_1 = require_types();
      var svg_exporter_1 = require_svg_exporter();
      var ModelSource2 = class ModelSource {
        initialize(registry) {
          registry.register(actions_1.RequestModelAction.KIND, this);
          registry.register(svg_exporter_1.ExportSvgAction.KIND, this);
        }
      };
      exports.ModelSource = ModelSource2;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelSource2.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ModelSource2.prototype, "viewerOptions", void 0);
      exports.ModelSource = ModelSource2 = __decorate([
        (0, inversify_1.injectable)()
      ], ModelSource2);
      var ComputedBoundsApplicator = class ComputedBoundsApplicator {
        apply(root, action) {
          const index = new model_utils_1.SModelIndex();
          index.add(root);
          for (const b of action.bounds) {
            const element = index.getById(b.elementId);
            if (element !== void 0)
              this.applyBounds(element, b.newPosition, b.newSize);
          }
          if (action.alignments !== void 0) {
            for (const a of action.alignments) {
              const element = index.getById(a.elementId);
              if (element !== void 0)
                this.applyAlignment(element, a.newAlignment);
            }
          }
          return index;
        }
        applyAlignment(element, newAlignment) {
          const e = element;
          e.alignment = { x: newAlignment.x, y: newAlignment.y };
        }
        applyBounds(element, newPosition, newSize) {
          const e = element;
          if (newPosition)
            e.position = Object.assign({}, newPosition);
          e.size = Object.assign({}, newSize);
        }
      };
      exports.ComputedBoundsApplicator = ComputedBoundsApplicator;
      exports.ComputedBoundsApplicator = ComputedBoundsApplicator = __decorate([
        (0, inversify_1.injectable)()
      ], ComputedBoundsApplicator);
    }
  });

  // node_modules/sprotty/lib/model-source/commit-model.js
  var require_commit_model = __commonJS({
    "node_modules/sprotty/lib/model-source/commit-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommitModelCommand = exports.CommitModelAction = void 0;
      var inversify_1 = require_inversify();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_source_1 = require_model_source();
      var CommitModelAction4;
      (function(CommitModelAction5) {
        CommitModelAction5.KIND = "commitModel";
        function create() {
          return {
            kind: CommitModelAction5.KIND
          };
        }
        CommitModelAction5.create = create;
      })(CommitModelAction4 || (exports.CommitModelAction = CommitModelAction4 = {}));
      var CommitModelCommand = class CommitModelCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.newModel = context.modelFactory.createSchema(context.root);
          return this.doCommit(this.newModel, context.root, true);
        }
        doCommit(model, result, doSetOriginal) {
          const commitResult = this.modelSource.commitModel(model);
          if (commitResult instanceof Promise) {
            return commitResult.then((originalModel) => {
              if (doSetOriginal)
                this.originalModel = originalModel;
              return result;
            });
          } else {
            if (doSetOriginal)
              this.originalModel = commitResult;
            return result;
          }
        }
        undo(context) {
          return this.doCommit(this.originalModel, context.root, false);
        }
        redo(context) {
          return this.doCommit(this.newModel, context.root, false);
        }
      };
      exports.CommitModelCommand = CommitModelCommand;
      CommitModelCommand.KIND = CommitModelAction4.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ModelSource),
        __metadata("design:type", model_source_1.ModelSource)
      ], CommitModelCommand.prototype, "modelSource", void 0);
      exports.CommitModelCommand = CommitModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CommitModelCommand);
    }
  });

  // node_modules/sprotty/lib/features/viewport/zoom.js
  var require_zoom = __commonJS({
    "node_modules/sprotty/lib/features/viewport/zoom.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoomMouseListener = exports.getZoom = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var browser_1 = require_browser();
      var model_1 = require_model12();
      function getZoom(label) {
        let zoom = 1;
        const viewport = (0, smodel_utils_1.findParentByFeature)(label, model_1.isViewport);
        if (viewport) {
          zoom = viewport.zoom;
        }
        return zoom;
      }
      exports.getZoom = getZoom;
      var ZoomMouseListener = class extends mouse_tool_1.MouseListener {
        wheel(target, event) {
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
          if (!viewport) {
            return [];
          }
          const newViewport = this.isScrollMode(event) ? this.processScroll(viewport, event) : this.processZoom(viewport, target, event);
          if (newViewport) {
            return [actions_1.SetViewportAction.create(viewport.id, newViewport, { animate: false })];
          }
          return [];
        }
        isScrollMode(event) {
          return event.altKey;
        }
        processScroll(viewport, event) {
          return {
            scroll: {
              x: viewport.scroll.x + event.deltaX,
              y: viewport.scroll.y + event.deltaY
            },
            zoom: viewport.zoom
          };
        }
        processZoom(viewport, target, event) {
          const zoomFactor = this.getZoomFactor(event);
          if (zoomFactor > 1 && (0, geometry_1.almostEquals)(viewport.zoom, this.viewerOptions.zoomLimits.max) || zoomFactor < 1 && (0, geometry_1.almostEquals)(viewport.zoom, this.viewerOptions.zoomLimits.min)) {
            return;
          }
          const zoom = viewport.zoom * zoomFactor;
          const viewportOffset = this.getViewportOffset(target.root, event);
          const offsetFactor = 1 / zoom - 1 / viewport.zoom;
          return {
            scroll: {
              x: viewport.scroll.x - offsetFactor * viewportOffset.x,
              y: viewport.scroll.y - offsetFactor * viewportOffset.y
            },
            zoom
          };
        }
        getViewportOffset(root, event) {
          const canvasBounds = root.canvasBounds;
          const windowScroll = (0, browser_1.getWindowScroll)();
          return {
            x: event.clientX + windowScroll.x - canvasBounds.x,
            y: event.clientY + windowScroll.y - canvasBounds.y
          };
        }
        getZoomFactor(event) {
          if (event.deltaMode === event.DOM_DELTA_PAGE)
            return Math.exp(-event.deltaY * 0.5);
          else if (event.deltaMode === event.DOM_DELTA_LINE)
            return Math.exp(-event.deltaY * 0.05);
          else
            return Math.exp(-event.deltaY * 5e-3);
        }
      };
      exports.ZoomMouseListener = ZoomMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ZoomMouseListener.prototype, "viewerOptions", void 0);
    }
  });

  // node_modules/sprotty/lib/features/edit/edit-label-ui.js
  var require_edit_label_ui = __commonJS({
    "node_modules/sprotty/lib/features/edit/edit-label-ui.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var EditLabelUI_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EditLabelUI = exports.EditLabelActionHandler = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var types_1 = require_types();
      var ui_extension_1 = require_ui_extension();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var dom_helper_1 = require_dom_helper();
      var commit_model_1 = require_commit_model();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model2();
      var zoom_1 = require_zoom();
      var edit_label_1 = require_edit_label();
      var model_2 = require_model11();
      var EditLabelActionHandler = class EditLabelActionHandler {
        handle(action) {
          if ((0, edit_label_1.isEditLabelAction)(action)) {
            return ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: EditLabelUI.ID, visible: true, contextElementsId: [action.labelId] });
          }
        }
      };
      exports.EditLabelActionHandler = EditLabelActionHandler;
      exports.EditLabelActionHandler = EditLabelActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], EditLabelActionHandler);
      var EditLabelUI = EditLabelUI_1 = class EditLabelUI extends ui_extension_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.validationTimeout = void 0;
          this.isActive = false;
          this.blockApplyEditOnInvalidInput = true;
          this.isCurrentLabelValid = true;
        }
        id() {
          return EditLabelUI_1.ID;
        }
        containerClass() {
          return "label-edit";
        }
        get labelId() {
          return this.label ? this.label.id : "unknown";
        }
        initializeContents(containerElement) {
          containerElement.style.position = "absolute";
          this.inputElement = document.createElement("input");
          this.textAreaElement = document.createElement("textarea");
          [this.inputElement, this.textAreaElement].forEach((element) => {
            element.onkeydown = (event) => this.applyLabelEditOnEvent(event, "Enter");
            this.configureAndAdd(element, containerElement);
          });
        }
        configureAndAdd(element, containerElement) {
          element.style.visibility = "hidden";
          element.style.position = "absolute";
          element.style.top = "0px";
          element.style.left = "0px";
          element.addEventListener("keydown", (event) => this.hideIfEscapeEvent(event));
          element.addEventListener("keyup", (event) => this.validateLabelIfContentChange(event, element.value));
          element.addEventListener("blur", () => window.setTimeout(() => this.applyLabelEdit(), 200));
          containerElement.appendChild(element);
        }
        get editControl() {
          if (this.label && this.label.isMultiLine) {
            return this.textAreaElement;
          }
          return this.inputElement;
        }
        hideIfEscapeEvent(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            this.hide();
          }
        }
        applyLabelEditOnEvent(event, code, ...modifiers) {
          if ((0, keyboard_1.matchesKeystroke)(event, code ? code : "Enter", ...modifiers)) {
            event.preventDefault();
            this.applyLabelEdit();
          }
        }
        validateLabelIfContentChange(event, value) {
          if (this.previousLabelContent === void 0 || this.previousLabelContent !== value) {
            this.previousLabelContent = value;
            this.performLabelValidation(event, this.editControl.value);
          }
        }
        async applyLabelEdit() {
          var _a;
          if (!this.isActive) {
            return;
          }
          if (((_a = this.label) === null || _a === void 0 ? void 0 : _a.text) === this.editControl.value) {
            this.hide();
            return;
          }
          if (this.blockApplyEditOnInvalidInput) {
            const result = await this.validateLabel(this.editControl.value);
            if ("error" === result.severity) {
              this.editControl.focus();
              return;
            }
          }
          this.actionDispatcherProvider().then((actionDispatcher) => actionDispatcher.dispatchAll([actions_1.ApplyLabelEditAction.create(this.labelId, this.editControl.value), commit_model_1.CommitModelAction.create()])).catch((reason) => this.logger.error(this, "No action dispatcher available to execute apply label edit action", reason));
          this.hide();
        }
        performLabelValidation(event, value) {
          if (this.validationTimeout) {
            window.clearTimeout(this.validationTimeout);
          }
          this.validationTimeout = window.setTimeout(() => this.validateLabel(value), 200);
        }
        async validateLabel(value) {
          if (this.labelValidator && this.label) {
            try {
              const result = await this.labelValidator.validate(value, this.label);
              this.isCurrentLabelValid = "error" !== result.severity;
              this.showValidationResult(result);
              return result;
            } catch (reason) {
              this.logger.error(this, "Error validating edited label", reason);
            }
          }
          this.isCurrentLabelValid = true;
          return { severity: "ok", message: void 0 };
        }
        showValidationResult(result) {
          this.clearValidationResult();
          if (this.validationDecorator) {
            this.validationDecorator.decorate(this.editControl, result);
          }
        }
        clearValidationResult() {
          if (this.validationDecorator) {
            this.validationDecorator.dispose(this.editControl);
          }
        }
        show(root, ...contextElementIds) {
          if (!hasEditableLabel(contextElementIds, root) || this.isActive) {
            return;
          }
          super.show(root, ...contextElementIds);
          this.isActive = true;
        }
        hide() {
          this.editControl.style.visibility = "hidden";
          super.hide();
          this.clearValidationResult();
          this.isActive = false;
          this.isCurrentLabelValid = true;
          this.previousLabelContent = void 0;
          if (this.labelElement) {
            this.labelElement.style.visibility = "visible";
          }
        }
        onBeforeShow(containerElement, root, ...contextElementIds) {
          this.label = getEditableLabels(contextElementIds, root)[0];
          this.previousLabelContent = this.label.text;
          this.setPosition(containerElement);
          this.applyTextContents();
          this.applyFontStyling();
          this.editControl.style.visibility = "visible";
          this.editControl.focus();
        }
        setPosition(containerElement) {
          let x = 0;
          let y = 0;
          let width = 100;
          let height = 20;
          if (this.label) {
            const zoom = (0, zoom_1.getZoom)(this.label);
            const bounds = (0, model_1.getAbsoluteClientBounds)(this.label, this.domHelper, this.viewerOptions);
            x = bounds.x + (this.label.editControlPositionCorrection ? this.label.editControlPositionCorrection.x : 0) * zoom;
            y = bounds.y + (this.label.editControlPositionCorrection ? this.label.editControlPositionCorrection.y : 0) * zoom;
            height = (this.label.editControlDimension ? this.label.editControlDimension.height : height) * zoom;
            width = (this.label.editControlDimension ? this.label.editControlDimension.width : width) * zoom;
          }
          containerElement.style.left = `${x}px`;
          containerElement.style.top = `${y}px`;
          containerElement.style.width = `${width}px`;
          this.editControl.style.width = `${width}px`;
          containerElement.style.height = `${height}px`;
          this.editControl.style.height = `${height}px`;
        }
        applyTextContents() {
          if (this.label) {
            this.editControl.value = this.label.text;
            if (this.editControl instanceof HTMLTextAreaElement) {
              this.editControl.selectionStart = 0;
              this.editControl.selectionEnd = 0;
              this.editControl.scrollTop = 0;
              this.editControl.scrollLeft = 0;
            } else {
              this.editControl.setSelectionRange(0, this.editControl.value.length);
            }
          }
        }
        applyFontStyling() {
          if (this.label) {
            this.labelElement = document.getElementById(this.domHelper.createUniqueDOMElementId(this.label));
            if (this.labelElement) {
              this.labelElement.style.visibility = "hidden";
              const style = window.getComputedStyle(this.labelElement);
              this.editControl.style.font = style.font;
              this.editControl.style.fontStyle = style.fontStyle;
              this.editControl.style.fontFamily = style.fontFamily;
              this.editControl.style.fontSize = scaledFont(style.fontSize, (0, zoom_1.getZoom)(this.label));
              this.editControl.style.fontWeight = style.fontWeight;
              this.editControl.style.lineHeight = style.lineHeight;
            }
          }
        }
      };
      exports.EditLabelUI = EditLabelUI;
      EditLabelUI.ID = "editLabelUi";
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcherProvider),
        __metadata("design:type", Function)
      ], EditLabelUI.prototype, "actionDispatcherProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], EditLabelUI.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IEditLabelValidator),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "labelValidator", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IEditLabelValidationDecorator),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "validationDecorator", void 0);
      exports.EditLabelUI = EditLabelUI = EditLabelUI_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EditLabelUI);
      function hasEditableLabel(contextElementIds, root) {
        return getEditableLabels(contextElementIds, root).length === 1;
      }
      function getEditableLabels(contextElementIds, root) {
        return contextElementIds.map((id) => root.index.getById(id)).filter(model_2.isEditableLabel);
      }
      function scaledFont(font, zoom) {
        return font.replace(/\d+(\.\d+)?/, (match) => {
          return String(Number.parseInt(match, 10) * zoom);
        });
      }
    }
  });

  // node_modules/sprotty/lib/features/edit/edit-routing.js
  var require_edit_routing = __commonJS({
    "node_modules/sprotty/lib/features/edit/edit-routing.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SwitchEditModeCommand = exports.SwitchEditModeAction = void 0;
      var inversify_1 = require_inversify();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var model_2 = require_model11();
      var SwitchEditModeAction;
      (function(SwitchEditModeAction2) {
        SwitchEditModeAction2.KIND = "switchEditMode";
        function create(options) {
          var _a, _b;
          return {
            kind: SwitchEditModeAction2.KIND,
            elementsToActivate: (_a = options.elementsToActivate) !== null && _a !== void 0 ? _a : [],
            elementsToDeactivate: (_b = options.elementsToDeactivate) !== null && _b !== void 0 ? _b : []
          };
        }
        SwitchEditModeAction2.create = create;
      })(SwitchEditModeAction || (exports.SwitchEditModeAction = SwitchEditModeAction = {}));
      var SwitchEditModeCommand = class SwitchEditModeCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.elementsToActivate = [];
          this.elementsToDeactivate = [];
          this.handlesToRemove = [];
        }
        execute(context) {
          const index = context.root.index;
          this.action.elementsToActivate.forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0)
              this.elementsToActivate.push(element);
          });
          this.action.elementsToDeactivate.forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0)
              this.elementsToDeactivate.push(element);
            if (element instanceof model_1.SRoutingHandleImpl && element.parent instanceof model_1.SRoutableElementImpl) {
              const parent = element.parent;
              if (this.shouldRemoveHandle(element, parent)) {
                this.handlesToRemove.push({ handle: element, parent });
                this.elementsToDeactivate.push(parent);
                this.elementsToActivate.push(parent);
              }
            }
          });
          return this.doExecute(context);
        }
        doExecute(context) {
          this.handlesToRemove.forEach((entry) => {
            entry.point = entry.parent.routingPoints.splice(entry.handle.pointIndex, 1)[0];
          });
          this.elementsToDeactivate.forEach((element) => {
            if (element instanceof model_1.SRoutableElementImpl)
              element.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
            else if (element instanceof model_1.SRoutingHandleImpl) {
              element.editMode = false;
              if (element.danglingAnchor) {
                if (element.parent instanceof model_1.SRoutableElementImpl && element.danglingAnchor.original) {
                  if (element.parent.source === element.danglingAnchor)
                    element.parent.sourceId = element.danglingAnchor.original.id;
                  else if (element.parent.target === element.danglingAnchor)
                    element.parent.targetId = element.danglingAnchor.original.id;
                  element.danglingAnchor.parent.remove(element.danglingAnchor);
                  element.danglingAnchor = void 0;
                }
              }
            }
          });
          this.elementsToActivate.forEach((element) => {
            if ((0, model_2.canEditRouting)(element) && element instanceof smodel_1.SParentElementImpl) {
              const router = this.edgeRouterRegistry.get(element.routerKind);
              router.createRoutingHandles(element);
            } else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = true;
          });
          return context.root;
        }
        shouldRemoveHandle(handle, parent) {
          if (handle.kind === "junction") {
            const route = this.edgeRouterRegistry.route(parent);
            return route.find((rp) => rp.pointIndex === handle.pointIndex) === void 0;
          }
          return false;
        }
        undo(context) {
          this.handlesToRemove.forEach((entry) => {
            if (entry.point !== void 0)
              entry.parent.routingPoints.splice(entry.handle.pointIndex, 0, entry.point);
          });
          this.elementsToActivate.forEach((element) => {
            if (element instanceof model_1.SRoutableElementImpl)
              element.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
            else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = false;
          });
          this.elementsToDeactivate.forEach((element) => {
            if ((0, model_2.canEditRouting)(element)) {
              const router = this.edgeRouterRegistry.get(element.routerKind);
              router.createRoutingHandles(element);
            } else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = true;
          });
          return context.root;
        }
        redo(context) {
          return this.doExecute(context);
        }
      };
      exports.SwitchEditModeCommand = SwitchEditModeCommand;
      SwitchEditModeCommand.KIND = SwitchEditModeAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SwitchEditModeCommand.prototype, "edgeRouterRegistry", void 0);
      exports.SwitchEditModeCommand = SwitchEditModeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SwitchEditModeCommand);
    }
  });

  // node_modules/sprotty/lib/features/edit/reconnect.js
  var require_reconnect = __commonJS({
    "node_modules/sprotty/lib/features/edit/reconnect.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReconnectCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var ReconnectCommand = class ReconnectCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.doExecute(context);
          return context.root;
        }
        doExecute(context) {
          const index = context.root.index;
          const edge = index.getById(this.action.routableId);
          if (edge instanceof model_1.SRoutableElementImpl) {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            const before = router.takeSnapshot(edge);
            router.applyReconnect(edge, this.action.newSourceId, this.action.newTargetId);
            const after = router.takeSnapshot(edge);
            this.memento = {
              edge,
              before,
              after
            };
          }
        }
        undo(context) {
          if (this.memento) {
            const router = this.edgeRouterRegistry.get(this.memento.edge.routerKind);
            router.applySnapshot(this.memento.edge, this.memento.before);
          }
          return context.root;
        }
        redo(context) {
          if (this.memento) {
            const router = this.edgeRouterRegistry.get(this.memento.edge.routerKind);
            router.applySnapshot(this.memento.edge, this.memento.after);
          }
          return context.root;
        }
      };
      exports.ReconnectCommand = ReconnectCommand;
      ReconnectCommand.KIND = actions_1.ReconnectAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], ReconnectCommand.prototype, "edgeRouterRegistry", void 0);
      exports.ReconnectCommand = ReconnectCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ReconnectCommand);
    }
  });

  // node_modules/sprotty/lib/features/edit/di.config.js
  var require_di_config3 = __commonJS({
    "node_modules/sprotty/lib/features/edit/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.labelEditUiModule = exports.labelEditModule = exports.edgeEditModule = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var command_registration_1 = require_command_registration();
      var action_handler_1 = require_action_handler();
      var view_1 = require_view();
      var model_1 = require_model9();
      var svg_views_1 = require_svg_views();
      var delete_1 = require_delete();
      var edit_label_1 = require_edit_label();
      var edit_label_ui_1 = require_edit_label_ui();
      var edit_routing_1 = require_edit_routing();
      var reconnect_1 = require_reconnect();
      exports.edgeEditModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, edit_routing_1.SwitchEditModeCommand);
        (0, command_registration_1.configureCommand)(context, reconnect_1.ReconnectCommand);
        (0, command_registration_1.configureCommand)(context, delete_1.DeleteElementCommand);
        (0, view_1.configureModelElement)(context, "dangling-anchor", model_1.SDanglingAnchorImpl, svg_views_1.EmptyGroupView);
      });
      exports.labelEditModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(edit_label_1.EditLabelMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(edit_label_1.EditLabelMouseListener);
        bind(edit_label_1.EditLabelKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(edit_label_1.EditLabelKeyListener);
        (0, command_registration_1.configureCommand)({ bind, isBound }, edit_label_1.ApplyLabelEditCommand);
      });
      exports.labelEditUiModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, action_handler_1.configureActionHandler)(context, edit_label_1.EditLabelAction.KIND, edit_label_ui_1.EditLabelActionHandler);
        bind(edit_label_ui_1.EditLabelUI).toSelf().inSingletonScope();
        bind(types_1.TYPES.IUIExtension).toService(edit_label_ui_1.EditLabelUI);
      });
    }
  });

  // node_modules/sprotty/lib/features/expand/model.js
  var require_model14 = __commonJS({
    "node_modules/sprotty/lib/features/expand/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isExpandable = exports.expandFeature = void 0;
      exports.expandFeature = Symbol("expandFeature");
      function isExpandable(element) {
        return element.hasFeature(exports.expandFeature) && "expanded" in element;
      }
      exports.isExpandable = isExpandable;
    }
  });

  // node_modules/sprotty/lib/features/expand/expand.js
  var require_expand = __commonJS({
    "node_modules/sprotty/lib/features/expand/expand.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExpandButtonHandler = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model14();
      var ExpandButtonHandler = class ExpandButtonHandler {
        buttonPressed(button) {
          const expandable = (0, smodel_utils_1.findParentByFeature)(button, model_1.isExpandable);
          if (expandable !== void 0) {
            return [actions_1.CollapseExpandAction.create({
              expandIds: expandable.expanded ? [] : [expandable.id],
              collapseIds: expandable.expanded ? [expandable.id] : []
            })];
          } else {
            return [];
          }
        }
      };
      exports.ExpandButtonHandler = ExpandButtonHandler;
      ExpandButtonHandler.TYPE = "button:expand";
      exports.ExpandButtonHandler = ExpandButtonHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ExpandButtonHandler);
    }
  });

  // node_modules/sprotty/lib/features/expand/views.js
  var require_views2 = __commonJS({
    "node_modules/sprotty/lib/features/expand/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExpandButtonView = void 0;
      var jsx_1 = require_jsx();
      var model_1 = require_model14();
      var smodel_utils_1 = require_smodel_utils();
      var inversify_1 = require_inversify();
      var ExpandButtonView = class ExpandButtonView {
        render(button, context) {
          const expandable = (0, smodel_utils_1.findParentByFeature)(button, model_1.isExpandable);
          const path = expandable !== void 0 && expandable.expanded ? "M 1,5 L 8,12 L 15,5 Z" : "M 1,8 L 8,15 L 8,1 Z";
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-button": "{true}", "class-enabled": "{button.enabled}" },
            (0, jsx_1.svg)("rect", { x: 0, y: 0, width: 16, height: 16, opacity: 0 }),
            (0, jsx_1.svg)("path", { d: path })
          );
        }
      };
      exports.ExpandButtonView = ExpandButtonView;
      exports.ExpandButtonView = ExpandButtonView = __decorate([
        (0, inversify_1.injectable)()
      ], ExpandButtonView);
    }
  });

  // node_modules/sprotty/lib/features/export/export.js
  var require_export = __commonJS({
    "node_modules/sprotty/lib/features/export/export.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExportSvgPostprocessor = exports.ExportSvgCommand = exports.RequestExportSvgAction = exports.ExportSvgKeyListener = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var model_1 = require_model6();
      var smodel_1 = require_smodel();
      var key_tool_1 = require_key_tool();
      var keyboard_1 = require_keyboard();
      var model_2 = require_model13();
      var svg_exporter_1 = require_svg_exporter();
      var model_3 = require_model12();
      var model_4 = require_model7();
      var types_1 = require_types();
      var ExportSvgKeyListener = class ExportSvgKeyListener extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyE", "ctrlCmd", "shift"))
            return [RequestExportSvgAction.create()];
          else
            return [];
        }
      };
      exports.ExportSvgKeyListener = ExportSvgKeyListener;
      exports.ExportSvgKeyListener = ExportSvgKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], ExportSvgKeyListener);
      var RequestExportSvgAction;
      (function(RequestExportSvgAction2) {
        RequestExportSvgAction2.KIND = "requestExportSvg";
        function create() {
          return {
            kind: RequestExportSvgAction2.KIND,
            requestId: (0, actions_1.generateRequestId)()
          };
        }
        RequestExportSvgAction2.create = create;
      })(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
      var ExportSvgCommand = class ExportSvgCommand extends command_1.HiddenCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          if ((0, model_2.isExportable)(context.root)) {
            const root = context.modelFactory.createRoot(context.root);
            if ((0, model_2.isExportable)(root)) {
              if ((0, model_3.isViewport)(root)) {
                root.zoom = 1;
                root.scroll = { x: 0, y: 0 };
              }
              root.index.all().forEach((element) => {
                if ((0, model_1.isSelectable)(element) && element.selected)
                  element.selected = false;
                if ((0, model_4.isHoverable)(element) && element.hoverFeedback)
                  element.hoverFeedback = false;
              });
              return {
                model: root,
                modelChanged: true,
                cause: this.action
              };
            }
          }
          return {
            model: context.root,
            modelChanged: false
          };
        }
      };
      exports.ExportSvgCommand = ExportSvgCommand;
      ExportSvgCommand.KIND = RequestExportSvgAction.KIND;
      exports.ExportSvgCommand = ExportSvgCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ExportSvgCommand);
      var ExportSvgPostprocessor = class ExportSvgPostprocessor {
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl)
            this.root = element;
          return vnode;
        }
        postUpdate(cause) {
          if (this.root && cause !== void 0 && cause.kind === RequestExportSvgAction.KIND) {
            this.svgExporter.export(this.root, cause);
          }
        }
      };
      exports.ExportSvgPostprocessor = ExportSvgPostprocessor;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.SvgExporter),
        __metadata("design:type", svg_exporter_1.SvgExporter)
      ], ExportSvgPostprocessor.prototype, "svgExporter", void 0);
      exports.ExportSvgPostprocessor = ExportSvgPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], ExportSvgPostprocessor);
    }
  });

  // node_modules/sprotty/lib/features/fade/fade.js
  var require_fade = __commonJS({
    "node_modules/sprotty/lib/features/fade/fade.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ElementFader = exports.FadeAnimation = void 0;
      var inversify_1 = require_inversify();
      var animation_1 = require_animation();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var model_1 = require_model3();
      var FadeAnimation = class extends animation_1.Animation {
        constructor(model, elementFades, context, removeAfterFadeOut = false) {
          super(context);
          this.model = model;
          this.elementFades = elementFades;
          this.removeAfterFadeOut = removeAfterFadeOut;
        }
        tween(t, context) {
          for (const elementFade of this.elementFades) {
            const element = elementFade.element;
            if (elementFade.type === "in") {
              element.opacity = t;
            } else if (elementFade.type === "out") {
              element.opacity = 1 - t;
              if (t === 1 && this.removeAfterFadeOut && element instanceof smodel_1.SChildElementImpl) {
                element.parent.remove(element);
              }
            }
          }
          return this.model;
        }
      };
      exports.FadeAnimation = FadeAnimation;
      var ElementFader = class ElementFader {
        decorate(vnode, element) {
          if ((0, model_1.isFadeable)(element) && element.opacity !== 1) {
            (0, vnode_utils_1.setAttr)(vnode, "opacity", element.opacity);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.ElementFader = ElementFader;
      exports.ElementFader = ElementFader = __decorate([
        (0, inversify_1.injectable)()
      ], ElementFader);
    }
  });

  // node_modules/sprotty/lib/features/hover/hover.js
  var require_hover = __commonJS({
    "node_modules/sprotty/lib/features/hover/hover.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClosePopupActionHandler = exports.HoverKeyListener = exports.PopupHoverMouseListener = exports.HoverMouseListener = exports.AbstractHoverMouseListener = exports.SetPopupModelCommand = exports.HoverFeedbackCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var keyboard_1 = require_keyboard();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var mouse_tool_1 = require_mouse_tool();
      var command_1 = require_command();
      var smodel_factory_1 = require_smodel_factory();
      var key_tool_1 = require_key_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model2();
      var model_2 = require_model7();
      var HoverFeedbackCommand = class HoverFeedbackCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const model = context.root;
          const modelElement = model.index.getById(this.action.mouseoverElement);
          if (modelElement) {
            if ((0, model_2.isHoverable)(modelElement)) {
              modelElement.hoverFeedback = this.action.mouseIsOver;
            }
          }
          return this.redo(context);
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.HoverFeedbackCommand = HoverFeedbackCommand;
      HoverFeedbackCommand.KIND = actions_1.HoverFeedbackAction.KIND;
      exports.HoverFeedbackCommand = HoverFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], HoverFeedbackCommand);
      var SetPopupModelCommand = class SetPopupModelCommand extends command_1.PopupCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.oldRoot = context.root;
          this.newRoot = context.modelFactory.createRoot(this.action.newRoot);
          return this.newRoot;
        }
        undo(context) {
          return this.oldRoot;
        }
        redo(context) {
          return this.newRoot;
        }
      };
      exports.SetPopupModelCommand = SetPopupModelCommand;
      SetPopupModelCommand.KIND = actions_1.SetPopupModelAction.KIND;
      exports.SetPopupModelCommand = SetPopupModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetPopupModelCommand);
      var AbstractHoverMouseListener = class extends mouse_tool_1.MouseListener {
        mouseDown(target, event) {
          this.mouseIsDown = true;
          return [];
        }
        mouseUp(target, event) {
          this.mouseIsDown = false;
          return [];
        }
        stopMouseOutTimer() {
          if (this.state.mouseOutTimer !== void 0) {
            window.clearTimeout(this.state.mouseOutTimer);
            this.state.mouseOutTimer = void 0;
          }
        }
        startMouseOutTimer() {
          this.stopMouseOutTimer();
          return new Promise((resolve) => {
            this.state.mouseOutTimer = window.setTimeout(() => {
              this.state.popupOpen = false;
              this.state.previousPopupElement = void 0;
              resolve(actions_1.SetPopupModelAction.create({ type: smodel_factory_1.EMPTY_ROOT.type, id: smodel_factory_1.EMPTY_ROOT.id }));
            }, this.options.popupCloseDelay);
          });
        }
        stopMouseOverTimer() {
          if (this.state.mouseOverTimer !== void 0) {
            window.clearTimeout(this.state.mouseOverTimer);
            this.state.mouseOverTimer = void 0;
          }
        }
      };
      exports.AbstractHoverMouseListener = AbstractHoverMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], AbstractHoverMouseListener.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.HoverState),
        __metadata("design:type", Object)
      ], AbstractHoverMouseListener.prototype, "state", void 0);
      var HoverMouseListener = class HoverMouseListener extends AbstractHoverMouseListener {
        computePopupBounds(target, mousePosition) {
          let offset = { x: -5, y: 20 };
          const targetBounds = (0, model_1.getAbsoluteBounds)(target);
          const canvasBounds = target.root.canvasBounds;
          const boundsInWindow = geometry_1.Bounds.translate(targetBounds, canvasBounds);
          const distRight = boundsInWindow.x + boundsInWindow.width - mousePosition.x;
          const distBottom = boundsInWindow.y + boundsInWindow.height - mousePosition.y;
          if (distBottom <= distRight && this.allowSidePosition(target, "below", distBottom)) {
            offset = { x: -5, y: Math.round(distBottom + 5) };
          } else if (distRight <= distBottom && this.allowSidePosition(target, "right", distRight)) {
            offset = { x: Math.round(distRight + 5), y: -5 };
          }
          let leftPopupPosition = mousePosition.x + offset.x;
          const canvasRightBorderPosition = canvasBounds.x + canvasBounds.width;
          if (leftPopupPosition > canvasRightBorderPosition) {
            leftPopupPosition = canvasRightBorderPosition;
          }
          let topPopupPosition = mousePosition.y + offset.y;
          const canvasBottomBorderPosition = canvasBounds.y + canvasBounds.height;
          if (topPopupPosition > canvasBottomBorderPosition) {
            topPopupPosition = canvasBottomBorderPosition;
          }
          return { x: leftPopupPosition, y: topPopupPosition, width: -1, height: -1 };
        }
        allowSidePosition(target, side, distance) {
          return !(target instanceof smodel_1.SModelRootImpl) && distance <= 150;
        }
        startMouseOverTimer(target, event) {
          this.stopMouseOverTimer();
          return new Promise((resolve) => {
            this.state.mouseOverTimer = window.setTimeout(() => {
              const popupBounds = this.computePopupBounds(target, { x: event.pageX, y: event.pageY });
              resolve(actions_1.RequestPopupModelAction.create({ elementId: target.id, bounds: popupBounds }));
              this.state.popupOpen = true;
              this.state.previousPopupElement = target;
            }, this.options.popupOpenDelay);
          });
        }
        mouseOver(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
            if (this.state.popupOpen && (popupTarget === void 0 || this.state.previousPopupElement !== void 0 && this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOutTimer());
            } else {
              this.stopMouseOverTimer();
              this.stopMouseOutTimer();
            }
            if (popupTarget !== void 0 && (this.state.previousPopupElement === void 0 || this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOverTimer(popupTarget, event));
            }
            if (this.lastHoverFeedbackElementId) {
              result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: this.lastHoverFeedbackElementId, mouseIsOver: false }));
              this.lastHoverFeedbackElementId = void 0;
            }
            const hoverTarget = (0, smodel_utils_1.findParentByFeature)(target, model_2.isHoverable);
            if (hoverTarget !== void 0) {
              result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: hoverTarget.id, mouseIsOver: true }));
              this.lastHoverFeedbackElementId = hoverTarget.id;
            }
          }
          return result;
        }
        mouseOut(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            const elementUnderMouse = this.getElementFromEventPosition(event);
            if (!this.isSprottyPopup(elementUnderMouse)) {
              if (this.state.popupOpen) {
                const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
                if (this.state.previousPopupElement !== void 0 && popupTarget !== void 0 && this.state.previousPopupElement.id === popupTarget.id)
                  result.push(this.startMouseOutTimer());
              }
              this.stopMouseOverTimer();
              const hoverTarget = (0, smodel_utils_1.findParentByFeature)(target, model_2.isHoverable);
              if (hoverTarget !== void 0) {
                result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: hoverTarget.id, mouseIsOver: false }));
                if (this.lastHoverFeedbackElementId && this.lastHoverFeedbackElementId !== hoverTarget.id) {
                  result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: this.lastHoverFeedbackElementId, mouseIsOver: false }));
                }
                this.lastHoverFeedbackElementId = void 0;
              }
            }
          }
          return result;
        }
        getElementFromEventPosition(event) {
          return document.elementFromPoint(event.x, event.y);
        }
        isSprottyPopup(element) {
          return element ? element.id === this.options.popupDiv || !!element.parentElement && this.isSprottyPopup(element.parentElement) : false;
        }
        mouseMove(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            if (this.state.previousPopupElement !== void 0 && this.closeOnMouseMove(this.state.previousPopupElement, event)) {
              result.push(this.startMouseOutTimer());
            }
            const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
            if (popupTarget !== void 0 && (this.state.previousPopupElement === void 0 || this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOverTimer(popupTarget, event));
            }
          }
          return result;
        }
        closeOnMouseMove(target, event) {
          return target instanceof smodel_1.SModelRootImpl;
        }
      };
      exports.HoverMouseListener = HoverMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], HoverMouseListener.prototype, "options", void 0);
      exports.HoverMouseListener = HoverMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], HoverMouseListener);
      var PopupHoverMouseListener = class PopupHoverMouseListener extends AbstractHoverMouseListener {
        mouseOut(target, event) {
          return [this.startMouseOutTimer()];
        }
        mouseOver(target, event) {
          this.stopMouseOutTimer();
          this.stopMouseOverTimer();
          return [];
        }
      };
      exports.PopupHoverMouseListener = PopupHoverMouseListener;
      exports.PopupHoverMouseListener = PopupHoverMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], PopupHoverMouseListener);
      var HoverKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            return [actions_1.SetPopupModelAction.create({ type: smodel_factory_1.EMPTY_ROOT.type, id: smodel_factory_1.EMPTY_ROOT.id })];
          }
          return [];
        }
      };
      exports.HoverKeyListener = HoverKeyListener;
      var ClosePopupActionHandler = class ClosePopupActionHandler {
        constructor() {
          this.popupOpen = false;
        }
        handle(action) {
          if (action.kind === SetPopupModelCommand.KIND) {
            this.popupOpen = action.newRoot.type !== smodel_factory_1.EMPTY_ROOT.type;
          } else if (this.popupOpen) {
            return actions_1.SetPopupModelAction.create({ id: smodel_factory_1.EMPTY_ROOT.id, type: smodel_factory_1.EMPTY_ROOT.type });
          }
        }
      };
      exports.ClosePopupActionHandler = ClosePopupActionHandler;
      exports.ClosePopupActionHandler = ClosePopupActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ClosePopupActionHandler);
    }
  });

  // node_modules/sprotty/lib/features/decoration/model.js
  var require_model15 = __commonJS({
    "node_modules/sprotty/lib/features/decoration/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SIssue = exports.SIssueMarker = exports.SDecoration = exports.isDecoration = exports.decorationFeature = void 0;
      var model_1 = require_model2();
      var model_2 = require_model7();
      exports.decorationFeature = Symbol("decorationFeature");
      function isDecoration(e) {
        return e.hasFeature(exports.decorationFeature);
      }
      exports.isDecoration = isDecoration;
      var SDecoration = class extends model_1.SShapeElementImpl {
      };
      exports.SDecoration = SDecoration;
      SDecoration.DEFAULT_FEATURES = [exports.decorationFeature, model_1.boundsFeature, model_2.hoverFeedbackFeature, model_2.popupFeature];
      var SIssueMarker = class extends SDecoration {
      };
      exports.SIssueMarker = SIssueMarker;
      var SIssue = class {
      };
      exports.SIssue = SIssue;
    }
  });

  // node_modules/sprotty/lib/features/decoration/views.js
  var require_views3 = __commonJS({
    "node_modules/sprotty/lib/features/decoration/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IssueMarkerView = void 0;
      var jsx_1 = require_jsx();
      var vnode_utils_1 = require_vnode_utils();
      var inversify_1 = require_inversify();
      var IssueMarkerView = class IssueMarkerView {
        render(marker, context) {
          const scale = 16 / 1792;
          const trafo = `scale(${scale}, ${scale})`;
          const maxSeverity = this.getMaxSeverity(marker);
          const group = (0, jsx_1.svg)(
            "g",
            { "class-sprotty-issue": true },
            (0, jsx_1.svg)(
              "g",
              { transform: trafo },
              (0, jsx_1.svg)("path", { d: this.getPath(maxSeverity) })
            )
          );
          (0, vnode_utils_1.setClass)(group, "sprotty-" + maxSeverity, true);
          return group;
        }
        getMaxSeverity(marker) {
          let currentSeverity = "info";
          for (const severity of marker.issues.map((s) => s.severity)) {
            if (severity === "error" || severity === "warning" && currentSeverity === "info")
              currentSeverity = severity;
          }
          return currentSeverity;
        }
        getPath(severity) {
          switch (severity) {
            case "error":
            case "warning":
              return "M768 128q209 0 385.5 103t279.5 279.5 103 385.5-103 385.5-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103zm128 1247v-190q0-14-9-23.5t-22-9.5h-192q-13 0-23 10t-10 23v190q0 13 10 23t23 10h192q13 0 22-9.5t9-23.5zm-2-344l18-621q0-12-10-18-10-8-24-8h-220q-14 0-24 8-10 6-10 18l17 621q0 10 10 17.5t24 7.5h185q14 0 23.5-7.5t10.5-17.5z";
            case "info":
              return "M1024 1376v-160q0-14-9-23t-23-9h-96v-512q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v160q0 14 9 23t23 9h96v320h-96q-14 0-23 9t-9 23v160q0 14 9 23t23 9h448q14 0 23-9t9-23zm-128-896v-160q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v160q0 14 9 23t23 9h192q14 0 23-9t9-23zm640 416q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z";
          }
        }
      };
      exports.IssueMarkerView = IssueMarkerView;
      exports.IssueMarkerView = IssueMarkerView = __decorate([
        (0, inversify_1.injectable)()
      ], IssueMarkerView);
    }
  });

  // node_modules/sprotty/lib/features/decoration/decoration-placer.js
  var require_decoration_placer = __commonJS({
    "node_modules/sprotty/lib/features/decoration/decoration-placer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecorationPlacer = void 0;
      var inversify_1 = require_inversify();
      var smodel_1 = require_smodel();
      var model_1 = require_model15();
      var vnode_utils_1 = require_vnode_utils();
      var model_2 = require_model2();
      var model_3 = require_model9();
      var routing_1 = require_routing();
      var sprotty_protocol_1 = require_lib();
      var DecorationPlacer = class DecorationPlacer {
        decorate(vnode, element) {
          if ((0, model_1.isDecoration)(element)) {
            const position = this.getPosition(element);
            const translate = "translate(" + position.x + ", " + position.y + ")";
            (0, vnode_utils_1.setAttr)(vnode, "transform", translate);
          }
          return vnode;
        }
        getPosition(element) {
          if (element instanceof smodel_1.SChildElementImpl && element.parent instanceof model_3.SRoutableElementImpl) {
            const route = this.edgeRouterRegistry.route(element.parent);
            if (route.length > 1) {
              const index = Math.floor(0.5 * (route.length - 1));
              const offset = (0, model_2.isSizeable)(element) ? {
                x: -0.5 * element.bounds.width,
                y: -0.5 * element.bounds.width
              } : sprotty_protocol_1.Point.ORIGIN;
              return {
                x: 0.5 * (route[index].x + route[index + 1].x) + offset.x,
                y: 0.5 * (route[index].y + route[index + 1].y) + offset.y
              };
            }
          }
          if ((0, model_2.isSizeable)(element))
            return {
              x: -0.666 * element.bounds.width,
              y: -0.666 * element.bounds.height
            };
          return sprotty_protocol_1.Point.ORIGIN;
        }
        postUpdate() {
        }
      };
      exports.DecorationPlacer = DecorationPlacer;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], DecorationPlacer.prototype, "edgeRouterRegistry", void 0);
      exports.DecorationPlacer = DecorationPlacer = __decorate([
        (0, inversify_1.injectable)()
      ], DecorationPlacer);
    }
  });

  // node_modules/tinyqueue/tinyqueue.js
  var require_tinyqueue = __commonJS({
    "node_modules/tinyqueue/tinyqueue.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.TinyQueue = factory());
      })(exports, function() {
        "use strict";
        var TinyQueue = function TinyQueue2(data, compare) {
          if (data === void 0)
            data = [];
          if (compare === void 0)
            compare = defaultCompare;
          this.data = data;
          this.length = this.data.length;
          this.compare = compare;
          if (this.length > 0) {
            for (var i = (this.length >> 1) - 1; i >= 0; i--) {
              this._down(i);
            }
          }
        };
        TinyQueue.prototype.push = function push(item) {
          this.data.push(item);
          this.length++;
          this._up(this.length - 1);
        };
        TinyQueue.prototype.pop = function pop() {
          if (this.length === 0) {
            return void 0;
          }
          var top = this.data[0];
          var bottom = this.data.pop();
          this.length--;
          if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
          }
          return top;
        };
        TinyQueue.prototype.peek = function peek() {
          return this.data[0];
        };
        TinyQueue.prototype._up = function _up(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var item = data[pos];
          while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) {
              break;
            }
            data[pos] = current;
            pos = parent;
          }
          data[pos] = item;
        };
        TinyQueue.prototype._down = function _down(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var halfLength = this.length >> 1;
          var item = data[pos];
          while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
              left = right;
              best = data[right];
            }
            if (compare(best, item) >= 0) {
              break;
            }
            data[pos] = best;
            pos = left;
          }
          data[pos] = item;
        };
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return TinyQueue;
      });
    }
  });

  // node_modules/sprotty/lib/features/edge-intersection/sweepline.js
  var require_sweepline = __commonJS({
    "node_modules/sprotty/lib/features/edge-intersection/sweepline.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.intersectionOfSegments = exports.getSegmentIndex = exports.checkWhichSegmentHasRightEndpointFirst = exports.runSweep = exports.Segment = exports.SweepEvent = exports.checkWhichEventIsLeft = exports.addRoute = void 0;
      var tinyqueue_1 = __importDefault(require_tinyqueue());
      var geometry_1 = require_geometry2();
      function addRoute(routeId, route, queue) {
        if (route.length < 1)
          return;
        let currentPoint = route[0];
        let nextPoint = void 0;
        for (let i = 0; i < route.length - 1; i++) {
          nextPoint = route[i + 1];
          const e1 = new SweepEvent(routeId, currentPoint, i);
          const e2 = new SweepEvent(routeId, nextPoint, i + 1);
          e1.otherEvent = e2;
          e2.otherEvent = e1;
          if (checkWhichEventIsLeft(e1, e2) > 0) {
            e2.isLeftEndpoint = true;
            e1.isLeftEndpoint = false;
          } else {
            e1.isLeftEndpoint = true;
            e2.isLeftEndpoint = false;
          }
          queue.push(e1);
          queue.push(e2);
          currentPoint = nextPoint;
        }
      }
      exports.addRoute = addRoute;
      function checkWhichEventIsLeft(e1, e2) {
        if (e1.point.x > e2.point.x)
          return 1;
        if (e1.point.x < e2.point.x)
          return -1;
        if (e1.point.y !== e2.point.y)
          return e1.point.y > e2.point.y ? 1 : -1;
        return 1;
      }
      exports.checkWhichEventIsLeft = checkWhichEventIsLeft;
      var SweepEvent = class {
        constructor(edgeId, point, segmentIndex) {
          this.edgeId = edgeId;
          this.point = point;
          this.segmentIndex = segmentIndex;
        }
      };
      exports.SweepEvent = SweepEvent;
      var Segment = class {
        constructor(event) {
          this.leftSweepEvent = event;
          this.rightSweepEvent = event.otherEvent;
        }
      };
      exports.Segment = Segment;
      function runSweep(eventQueue) {
        const intersectionPoints = [];
        const outQueue = new tinyqueue_1.default([], checkWhichSegmentHasRightEndpointFirst);
        while (eventQueue.length) {
          const event = eventQueue.pop();
          if (event === null || event === void 0 ? void 0 : event.isLeftEndpoint) {
            const segment = new Segment(event);
            for (let i = 0; i < outQueue.data.length; i++) {
              const otherSegment = outQueue.data[i];
              const intersection = intersectionOfSegments(segment, otherSegment);
              if (intersection) {
                intersectionPoints.push({
                  routable1: event.edgeId,
                  routable2: otherSegment.leftSweepEvent.edgeId,
                  segmentIndex1: getSegmentIndex(segment),
                  segmentIndex2: getSegmentIndex(otherSegment),
                  intersectionPoint: intersection
                });
              }
            }
            outQueue.push(segment);
          } else if ((event === null || event === void 0 ? void 0 : event.isLeftEndpoint) === false) {
            outQueue.pop();
          }
        }
        return intersectionPoints;
      }
      exports.runSweep = runSweep;
      function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
        if (seg1.rightSweepEvent.point.x > seg2.rightSweepEvent.point.x)
          return 1;
        if (seg1.rightSweepEvent.point.x < seg2.rightSweepEvent.point.x)
          return -1;
        if (seg1.rightSweepEvent.point.y !== seg2.rightSweepEvent.point.y)
          return seg1.rightSweepEvent.point.y < seg2.rightSweepEvent.point.y ? 1 : -1;
        return 1;
      }
      exports.checkWhichSegmentHasRightEndpointFirst = checkWhichSegmentHasRightEndpointFirst;
      function getSegmentIndex(segment) {
        return Math.min(segment.leftSweepEvent.segmentIndex, segment.rightSweepEvent.segmentIndex);
      }
      exports.getSegmentIndex = getSegmentIndex;
      function intersectionOfSegments(seg1, seg2) {
        if (seg1.leftSweepEvent.edgeId === seg2.leftSweepEvent.edgeId) {
          return void 0;
        }
        const seg1Line = new geometry_1.PointToPointLine(seg1.leftSweepEvent.point, seg1.rightSweepEvent.point);
        const seg2Line = new geometry_1.PointToPointLine(seg2.leftSweepEvent.point, seg2.rightSweepEvent.point);
        return seg1Line.intersection(seg2Line);
      }
      exports.intersectionOfSegments = intersectionOfSegments;
    }
  });

  // node_modules/sprotty/lib/features/edge-intersection/intersection-finder.js
  var require_intersection_finder = __commonJS({
    "node_modules/sprotty/lib/features/edge-intersection/intersection-finder.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntersectionFinder = exports.BY_DESCENDING_X_THEN_DESCENDING_Y = exports.BY_X_THEN_DESCENDING_Y = exports.BY_DESCENDING_X_THEN_Y = exports.BY_X_THEN_Y = exports.isIntersectingRoutedPoint = void 0;
      var inversify_1 = require_inversify();
      var tinyqueue_1 = __importDefault(require_tinyqueue());
      var sweepline_1 = require_sweepline();
      function isIntersectingRoutedPoint(routedPoint) {
        return routedPoint !== void 0 && "intersections" in routedPoint && "kind" in routedPoint;
      }
      exports.isIntersectingRoutedPoint = isIntersectingRoutedPoint;
      var BY_X_THEN_Y = (a, b) => {
        if (a.intersectionPoint.x === b.intersectionPoint.x) {
          return a.intersectionPoint.y - b.intersectionPoint.y;
        }
        return a.intersectionPoint.x - b.intersectionPoint.x;
      };
      exports.BY_X_THEN_Y = BY_X_THEN_Y;
      var BY_DESCENDING_X_THEN_Y = (a, b) => {
        if (a.intersectionPoint.x === b.intersectionPoint.x) {
          return a.intersectionPoint.y - b.intersectionPoint.y;
        }
        return b.intersectionPoint.x - a.intersectionPoint.x;
      };
      exports.BY_DESCENDING_X_THEN_Y = BY_DESCENDING_X_THEN_Y;
      var BY_X_THEN_DESCENDING_Y = (a, b) => {
        if (a.intersectionPoint.x === b.intersectionPoint.x) {
          return b.intersectionPoint.y - a.intersectionPoint.y;
        }
        return a.intersectionPoint.x - b.intersectionPoint.x;
      };
      exports.BY_X_THEN_DESCENDING_Y = BY_X_THEN_DESCENDING_Y;
      var BY_DESCENDING_X_THEN_DESCENDING_Y = (a, b) => {
        if (a.intersectionPoint.x === b.intersectionPoint.x) {
          return b.intersectionPoint.y - a.intersectionPoint.y;
        }
        return b.intersectionPoint.x - a.intersectionPoint.x;
      };
      exports.BY_DESCENDING_X_THEN_DESCENDING_Y = BY_DESCENDING_X_THEN_DESCENDING_Y;
      var IntersectionFinder = class IntersectionFinder {
        /**
         * Finds all intersections in the specified `routing` and replaces the `RoutedPoints` that are
         * intersecting by adding intersection information to routing points (@see `IntersectingRoutedPoints`).
         * @param routing the edge routing to find intersections for and update.
         */
        apply(routing) {
          const intersections = this.find(routing);
          this.addToRouting(intersections, routing);
        }
        /**
         * Finds the intersections in the specified `routing` and returns them.
         * @param routing the edge routing to find intersections for and update.
         * @returns the identified intersections.
         */
        find(routing) {
          const eventQueue = new tinyqueue_1.default(void 0, sweepline_1.checkWhichEventIsLeft);
          routing.routes.forEach((route, routeId) => {
            if (this.isSupportedRoute(route)) {
              (0, sweepline_1.addRoute)(routeId, route, eventQueue);
            }
          });
          return (0, sweepline_1.runSweep)(eventQueue);
        }
        /**
         * Specifies whether or not a specific route should be included in this intersection search or not.
         *
         * As this intersection finder only supports linear line segments, this method only returns `true`
         * for routes that only contain routed points, which are either 'source', 'target' or 'linear'.
         */
        isSupportedRoute(route) {
          return route.find((point) => point.kind !== "source" && point.kind !== "target" && point.kind !== "linear") === void 0;
        }
        addToRouting(intersections, routing) {
          for (const intersection of intersections) {
            const routable1 = routing.get(intersection.routable1);
            const routable2 = routing.get(intersection.routable2);
            this.addIntersectionToRoutedPoint(intersection, routable1, intersection.segmentIndex1);
            this.addIntersectionToRoutedPoint(intersection, routable2, intersection.segmentIndex2);
          }
        }
        addIntersectionToRoutedPoint(intersection, routedPoint, segmentIndex) {
          if (routedPoint && routedPoint.length > segmentIndex) {
            const segment = routedPoint[segmentIndex + 1];
            if (isIntersectingRoutedPoint(segment)) {
              segment.intersections.push(intersection);
            } else {
              const intersectingRoutedPoint = Object.assign(Object.assign({}, segment), { intersections: [intersection] });
              routedPoint[segmentIndex + 1] = intersectingRoutedPoint;
            }
          }
        }
      };
      exports.IntersectionFinder = IntersectionFinder;
      exports.IntersectionFinder = IntersectionFinder = __decorate([
        (0, inversify_1.injectable)()
      ], IntersectionFinder);
    }
  });

  // node_modules/sprotty/lib/features/move/move.js
  var require_move = __commonJS({
    "node_modules/sprotty/lib/features/move/move.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var MoveCommand_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocationPostprocessor = exports.MoveMouseListener = exports.MorphEdgesAnimation = exports.MoveAnimation = exports.MoveCommand = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var actions_1 = require_actions();
      var animation_1 = require_animation();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var vnode_utils_1 = require_vnode_utils();
      var sgraph_1 = require_sgraph();
      var commit_model_1 = require_commit_model();
      var model_1 = require_model2();
      var create_on_drag_1 = require_create_on_drag();
      var edit_routing_1 = require_edit_routing();
      var reconnect_1 = require_reconnect();
      var model_2 = require_model9();
      var routing_1 = require_routing();
      var model_3 = require_model10();
      var model_4 = require_model6();
      var model_5 = require_model12();
      var model_6 = require_model8();
      var MoveCommand = MoveCommand_1 = class MoveCommand extends command_1.MergeableCommand {
        constructor(action) {
          super();
          this.action = action;
          this.resolvedMoves = /* @__PURE__ */ new Map();
          this.edgeMementi = [];
        }
        execute(context) {
          const index = context.root.index;
          const edge2handleMoves = /* @__PURE__ */ new Map();
          const attachedEdgeShifts = /* @__PURE__ */ new Map();
          this.action.moves.forEach((move) => {
            const element = index.getById(move.elementId);
            if (element instanceof model_2.SRoutingHandleImpl && this.edgeRouterRegistry) {
              const edge = element.parent;
              if (edge instanceof model_2.SRoutableElementImpl) {
                const resolvedMove = this.resolveHandleMove(element, edge, move);
                if (resolvedMove) {
                  let movesByEdge = edge2handleMoves.get(edge);
                  if (!movesByEdge) {
                    movesByEdge = [];
                    edge2handleMoves.set(edge, movesByEdge);
                  }
                  movesByEdge.push(resolvedMove);
                }
              }
            } else if (element && (0, model_6.isLocateable)(element)) {
              const resolvedMove = this.resolveElementMove(element, move);
              if (resolvedMove) {
                this.resolvedMoves.set(resolvedMove.element.id, resolvedMove);
                if (this.edgeRouterRegistry) {
                  index.getAttachedElements(element).forEach((edge) => {
                    if (edge instanceof model_2.SRoutableElementImpl) {
                      const existingDelta = attachedEdgeShifts.get(edge);
                      const newDelta = geometry_1.Point.subtract(resolvedMove.toPosition, resolvedMove.fromPosition);
                      const delta = existingDelta ? geometry_1.Point.linear(existingDelta, newDelta, 0.5) : newDelta;
                      attachedEdgeShifts.set(edge, delta);
                    }
                  });
                }
              }
            }
          });
          this.doMove(edge2handleMoves, attachedEdgeShifts);
          if (this.action.animate) {
            this.undoMove();
            return new animation_1.CompoundAnimation(context.root, context, [
              new MoveAnimation(context.root, this.resolvedMoves, context, false),
              new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)
            ]).start();
          }
          return context.root;
        }
        resolveHandleMove(handle, edge, move) {
          let fromPosition = move.fromPosition;
          if (!fromPosition) {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            fromPosition = router.getHandlePosition(edge, router.route(edge), handle);
          }
          if (fromPosition)
            return {
              handle,
              fromPosition,
              toPosition: move.toPosition
            };
          return void 0;
        }
        resolveElementMove(element, move) {
          const fromPosition = move.fromPosition || { x: element.position.x, y: element.position.y };
          return {
            element,
            fromPosition,
            toPosition: move.toPosition
          };
        }
        doMove(edge2move, attachedEdgeShifts) {
          this.resolvedMoves.forEach((res) => {
            res.element.position = res.toPosition;
          });
          edge2move.forEach((moves, edge) => {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            const before = router.takeSnapshot(edge);
            router.applyHandleMoves(edge, moves);
            const after = router.takeSnapshot(edge);
            this.edgeMementi.push({ edge, before, after });
          });
          attachedEdgeShifts.forEach((delta, edge) => {
            if (!edge2move.get(edge)) {
              const router = this.edgeRouterRegistry.get(edge.routerKind);
              const before = router.takeSnapshot(edge);
              if (edge.source && edge.target && this.resolvedMoves.get(edge.source.id) && this.resolvedMoves.get(edge.target.id)) {
                edge.routingPoints = edge.routingPoints.map((rp) => geometry_1.Point.add(rp, delta));
              } else {
                const updateHandles = (0, model_4.isSelectable)(edge) && edge.selected;
                router.cleanupRoutingPoints(edge, edge.routingPoints, updateHandles, this.action.finished);
              }
              const after = router.takeSnapshot(edge);
              this.edgeMementi.push({ edge, before, after });
            }
          });
        }
        undoMove() {
          this.resolvedMoves.forEach((res) => {
            res.element.position = res.fromPosition;
          });
          this.edgeMementi.forEach((memento) => {
            const router = this.edgeRouterRegistry.get(memento.edge.routerKind);
            router.applySnapshot(memento.edge, memento.before);
          });
        }
        undo(context) {
          return new animation_1.CompoundAnimation(context.root, context, [
            new MoveAnimation(context.root, this.resolvedMoves, context, true),
            new MorphEdgesAnimation(context.root, this.edgeMementi, context, true)
          ]).start();
        }
        redo(context) {
          return new animation_1.CompoundAnimation(context.root, context, [
            new MoveAnimation(context.root, this.resolvedMoves, context, false),
            new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)
          ]).start();
        }
        merge(other, context) {
          if (!this.action.animate && other instanceof MoveCommand_1) {
            other.resolvedMoves.forEach((otherMove, otherElementId) => {
              const existingMove = this.resolvedMoves.get(otherElementId);
              if (existingMove) {
                existingMove.toPosition = otherMove.toPosition;
              } else {
                this.resolvedMoves.set(otherElementId, otherMove);
              }
            });
            other.edgeMementi.forEach((otherMemento) => {
              const existingMemento = this.edgeMementi.find((edgeMemento) => edgeMemento.edge.id === otherMemento.edge.id);
              if (existingMemento) {
                existingMemento.after = otherMemento.after;
              } else {
                this.edgeMementi.push(otherMemento);
              }
            });
            return true;
          } else if (other instanceof reconnect_1.ReconnectCommand) {
            const otherMemento = other.memento;
            if (otherMemento) {
              const existingMemento = this.edgeMementi.find((edgeMemento) => edgeMemento.edge.id === otherMemento.edge.id);
              if (existingMemento) {
                existingMemento.after = otherMemento.after;
              } else {
                this.edgeMementi.push(otherMemento);
              }
            }
            return true;
          }
          return false;
        }
      };
      exports.MoveCommand = MoveCommand;
      MoveCommand.KIND = actions_1.MoveAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], MoveCommand.prototype, "edgeRouterRegistry", void 0);
      exports.MoveCommand = MoveCommand = MoveCommand_1 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], MoveCommand);
      var MoveAnimation = class extends animation_1.Animation {
        constructor(model, elementMoves, context, reverse = false) {
          super(context);
          this.model = model;
          this.elementMoves = elementMoves;
          this.reverse = reverse;
        }
        tween(t) {
          this.elementMoves.forEach((elementMove) => {
            if (this.reverse) {
              elementMove.element.position = {
                x: (1 - t) * elementMove.toPosition.x + t * elementMove.fromPosition.x,
                y: (1 - t) * elementMove.toPosition.y + t * elementMove.fromPosition.y
              };
            } else {
              elementMove.element.position = {
                x: (1 - t) * elementMove.fromPosition.x + t * elementMove.toPosition.x,
                y: (1 - t) * elementMove.fromPosition.y + t * elementMove.toPosition.y
              };
            }
          });
          return this.model;
        }
      };
      exports.MoveAnimation = MoveAnimation;
      var MorphEdgesAnimation = class extends animation_1.Animation {
        constructor(model, originalMementi, context, reverse = false) {
          super(context);
          this.model = model;
          this.reverse = reverse;
          this.expanded = [];
          originalMementi.forEach((edgeMemento) => {
            const start = this.reverse ? edgeMemento.after : edgeMemento.before;
            const end = this.reverse ? edgeMemento.before : edgeMemento.after;
            const startRoute = start.routedPoints;
            const endRoute = end.routedPoints;
            const maxRoutingPoints = Math.max(startRoute.length, endRoute.length);
            this.expanded.push({
              startExpandedRoute: this.growToSize(startRoute, maxRoutingPoints),
              endExpandedRoute: this.growToSize(endRoute, maxRoutingPoints),
              memento: edgeMemento
            });
          });
        }
        midPoint(edgeMemento) {
          const edge = edgeMemento.edge;
          const source = edgeMemento.edge.source;
          const target = edgeMemento.edge.target;
          return geometry_1.Point.linear((0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(source.bounds), source.parent, edge.parent), (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(target.bounds), target.parent, edge.parent), 0.5);
        }
        start() {
          this.expanded.forEach((morph) => {
            morph.memento.edge.removeAll((e) => e instanceof model_2.SRoutingHandleImpl);
          });
          return super.start();
        }
        tween(t) {
          if (t === 1) {
            this.expanded.forEach((morph) => {
              const memento = morph.memento;
              if (this.reverse)
                memento.before.router.applySnapshot(memento.edge, memento.before);
              else
                memento.after.router.applySnapshot(memento.edge, memento.after);
            });
          } else {
            this.expanded.forEach((morph) => {
              const newRoutingPoints = [];
              for (let i = 1; i < morph.startExpandedRoute.length - 1; ++i)
                newRoutingPoints.push(geometry_1.Point.linear(morph.startExpandedRoute[i], morph.endExpandedRoute[i], t));
              const closestSnapshot = t < 0.5 ? morph.memento.before : morph.memento.after;
              const newSnapshot = Object.assign(Object.assign({}, closestSnapshot), { routingPoints: newRoutingPoints, routingHandles: [] });
              closestSnapshot.router.applySnapshot(morph.memento.edge, newSnapshot);
            });
          }
          return this.model;
        }
        growToSize(route, targetSize) {
          const diff = targetSize - route.length;
          if (diff <= 0)
            return route;
          const result = [];
          result.push(route[0]);
          const deltaDiff = 1 / (diff + 1);
          const deltaSmaller = 1 / (route.length - 1);
          let nextInsertion = 1;
          for (let i = 1; i < route.length; ++i) {
            const pos = deltaSmaller * i;
            let insertions = 0;
            while (pos > (nextInsertion + insertions) * deltaDiff)
              ++insertions;
            nextInsertion += insertions;
            for (let j = 0; j < insertions; ++j) {
              const p = geometry_1.Point.linear(route[i - 1], route[i], (j + 1) / (insertions + 1));
              result.push(p);
            }
            result.push(route[i]);
          }
          return result;
        }
      };
      exports.MorphEdgesAnimation = MorphEdgesAnimation;
      var MoveMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.hasDragged = false;
          this.elementId2startPos = /* @__PURE__ */ new Map();
        }
        mouseDown(target, event) {
          if (event.button === 0) {
            const moveable = (0, smodel_utils_1.findParentByFeature)(target, model_6.isMoveable);
            const isRoutingHandle = target instanceof model_2.SRoutingHandleImpl;
            if (moveable !== void 0 || isRoutingHandle || (0, create_on_drag_1.isCreatingOnDrag)(target)) {
              this.startDragPosition = { x: event.pageX, y: event.pageY };
            } else {
              this.startDragPosition = void 0;
            }
            this.hasDragged = false;
            if ((0, create_on_drag_1.isCreatingOnDrag)(target)) {
              return this.startCreatingOnDrag(target, event);
            } else if (isRoutingHandle) {
              return this.activateRoutingHandle(target, event);
            }
          }
          return [];
        }
        startCreatingOnDrag(target, event) {
          const result = [];
          result.push(actions_1.SelectAllAction.create({ select: false }));
          result.push(target.createAction(model_2.edgeInProgressID));
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [model_2.edgeInProgressID] }));
          result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [model_2.edgeInProgressID] }));
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [model_2.edgeInProgressTargetHandleID] }));
          result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [model_2.edgeInProgressTargetHandleID] }));
          return result;
        }
        activateRoutingHandle(target, event) {
          return [edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [target.id] })];
        }
        mouseMove(target, event) {
          const result = [];
          if (event.buttons === 0)
            this.mouseUp(target, event);
          else if (this.startDragPosition) {
            if (this.elementId2startPos.size === 0) {
              this.collectStartPositions(target.root);
            }
            this.hasDragged = true;
            const moveAction = this.getElementMoves(target, event, false);
            if (moveAction)
              result.push(moveAction);
          }
          return result;
        }
        collectStartPositions(root) {
          const selectedElements = new Set(root.index.all().filter((element) => (0, model_4.isSelectable)(element) && element.selected));
          selectedElements.forEach((element) => {
            if (!this.isChildOfSelected(selectedElements, element)) {
              if ((0, model_6.isMoveable)(element))
                this.elementId2startPos.set(element.id, element.position);
              else if (element instanceof model_2.SRoutingHandleImpl) {
                const position = this.getHandlePosition(element);
                if (position)
                  this.elementId2startPos.set(element.id, position);
              }
            }
          });
        }
        isChildOfSelected(selectedElements, element) {
          while (element instanceof smodel_1.SChildElementImpl) {
            element = element.parent;
            if ((0, model_6.isMoveable)(element) && selectedElements.has(element)) {
              return true;
            }
          }
          return false;
        }
        getElementMoves(target, event, isFinished) {
          if (!this.startDragPosition)
            return void 0;
          const elementMoves = [];
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_5.isViewport);
          const zoom = viewport ? viewport.zoom : 1;
          const delta = {
            x: (event.pageX - this.startDragPosition.x) / zoom,
            y: (event.pageY - this.startDragPosition.y) / zoom
          };
          this.elementId2startPos.forEach((startPosition, elementId) => {
            const element = target.root.index.getById(elementId);
            if (element) {
              const move = this.createElementMove(element, startPosition, delta, event);
              if (move) {
                elementMoves.push(move);
              }
            }
          });
          if (elementMoves.length > 0)
            return actions_1.MoveAction.create(elementMoves, { animate: false, finished: isFinished });
          else
            return void 0;
        }
        createElementMove(element, startPosition, delta, event) {
          const toPosition = this.snap({
            x: startPosition.x + delta.x,
            y: startPosition.y + delta.y
          }, element, !event.shiftKey);
          if ((0, model_6.isMoveable)(element)) {
            return {
              elementId: element.id,
              elementType: element.type,
              fromPosition: {
                x: element.position.x,
                y: element.position.y
              },
              toPosition
            };
          } else if (element instanceof model_2.SRoutingHandleImpl) {
            const point = this.getHandlePosition(element);
            if (point !== void 0) {
              return {
                elementId: element.id,
                elementType: element.type,
                fromPosition: point,
                toPosition
              };
            }
          }
          return void 0;
        }
        snap(position, element, isSnap) {
          if (isSnap && this.snapper)
            return this.snapper.snap(position, element);
          else
            return position;
        }
        getHandlePosition(handle) {
          if (this.edgeRouterRegistry) {
            const parent = handle.parent;
            if (!(parent instanceof model_2.SRoutableElementImpl))
              return void 0;
            const router = this.edgeRouterRegistry.get(parent.routerKind);
            const route = router.route(parent);
            return router.getHandlePosition(parent, route, handle);
          }
          return void 0;
        }
        mouseEnter(target, event) {
          if (target instanceof smodel_1.SModelRootImpl && event.buttons === 0 && !this.startDragPosition)
            this.mouseUp(target, event);
          return [];
        }
        mouseUp(target, event) {
          const result = [];
          if (this.startDragPosition) {
            const moveAction = this.getElementMoves(target, event, true);
            if (moveAction) {
              result.push(moveAction);
            }
            target.root.index.all().forEach((element) => {
              if (element instanceof model_2.SRoutingHandleImpl) {
                result.push(...this.deactivateRoutingHandle(element, target, event));
              }
            });
          }
          if (!result.some((a) => a.kind === actions_1.ReconnectAction.KIND)) {
            const edgeInProgress = target.root.index.getById(model_2.edgeInProgressID);
            if (edgeInProgress instanceof smodel_1.SChildElementImpl) {
              result.push(this.deleteEdgeInProgress(edgeInProgress));
            }
          }
          if (this.hasDragged) {
            result.push(commit_model_1.CommitModelAction.create());
          }
          this.hasDragged = false;
          this.startDragPosition = void 0;
          this.elementId2startPos.clear();
          return result;
        }
        deactivateRoutingHandle(element, target, event) {
          const result = [];
          const parent = element.parent;
          if (parent instanceof model_2.SRoutableElementImpl && element.danglingAnchor) {
            const handlePos = this.getHandlePosition(element);
            if (handlePos) {
              const handlePosAbs = (0, smodel_utils_1.translatePoint)(handlePos, element.parent, element.root);
              const newEnd = (0, model_1.findChildrenAtPosition)(target.root, handlePosAbs).find((e) => (0, model_2.isConnectable)(e) && e.canConnect(parent, element.kind));
              if (newEnd && this.hasDragged) {
                result.push(actions_1.ReconnectAction.create({
                  routableId: element.parent.id,
                  newSourceId: element.kind === "source" ? newEnd.id : parent.sourceId,
                  newTargetId: element.kind === "target" ? newEnd.id : parent.targetId
                }));
              }
            }
          }
          if (element.editMode) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: [element.id] }));
          }
          return result;
        }
        deleteEdgeInProgress(edgeInProgress) {
          const deleteIds = [];
          deleteIds.push(model_2.edgeInProgressID);
          edgeInProgress.children.forEach((c) => {
            if (c instanceof model_2.SRoutingHandleImpl && c.danglingAnchor)
              deleteIds.push(c.danglingAnchor.id);
          });
          return actions_1.DeleteElementAction.create(deleteIds);
        }
        decorate(vnode, element) {
          return vnode;
        }
      };
      exports.MoveMouseListener = MoveMouseListener;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], MoveMouseListener.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], MoveMouseListener.prototype, "snapper", void 0);
      var LocationPostprocessor = class LocationPostprocessor {
        decorate(vnode, element) {
          if ((0, model_3.isEdgeLayoutable)(element) && element.parent instanceof sgraph_1.SEdgeImpl) {
            return vnode;
          }
          let translate = "";
          if ((0, model_6.isLocateable)(element) && element instanceof smodel_1.SChildElementImpl && element.parent !== void 0) {
            const pos = element.position;
            if (pos.x !== 0 || pos.y !== 0) {
              translate = "translate(" + pos.x + ", " + pos.y + ")";
            }
          }
          if ((0, model_1.isAlignable)(element)) {
            const ali = element.alignment;
            if (ali.x !== 0 || ali.y !== 0) {
              if (translate.length > 0) {
                translate += " ";
              }
              translate += "translate(" + ali.x + ", " + ali.y + ")";
            }
          }
          if (translate.length > 0) {
            (0, vnode_utils_1.setAttr)(vnode, "transform", translate);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.LocationPostprocessor = LocationPostprocessor;
      exports.LocationPostprocessor = LocationPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], LocationPostprocessor);
    }
  });

  // node_modules/sprotty/lib/features/move/snap.js
  var require_snap = __commonJS({
    "node_modules/sprotty/lib/features/move/snap.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CenterGridSnapper = void 0;
      var inversify_1 = require_inversify();
      var model_1 = require_model2();
      var CenterGridSnapper = class CenterGridSnapper {
        get gridX() {
          return 10;
        }
        get gridY() {
          return 10;
        }
        snap(position, element) {
          if (element && (0, model_1.isBoundsAware)(element))
            return {
              x: Math.round((position.x + 0.5 * element.bounds.width) / this.gridX) * this.gridX - 0.5 * element.bounds.width,
              y: Math.round((position.y + 0.5 * element.bounds.height) / this.gridY) * this.gridY - 0.5 * element.bounds.height
            };
          else
            return {
              x: Math.round(position.x / this.gridX) * this.gridX,
              y: Math.round(position.y / this.gridY) * this.gridY
            };
        }
      };
      exports.CenterGridSnapper = CenterGridSnapper;
      exports.CenterGridSnapper = CenterGridSnapper = __decorate([
        (0, inversify_1.injectable)()
      ], CenterGridSnapper);
    }
  });

  // node_modules/sprotty/lib/features/open/model.js
  var require_model16 = __commonJS({
    "node_modules/sprotty/lib/features/open/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isOpenable = exports.openFeature = void 0;
      exports.openFeature = Symbol("openFeature");
      function isOpenable(element) {
        return element.hasFeature(exports.openFeature);
      }
      exports.isOpenable = isOpenable;
    }
  });

  // node_modules/sprotty/lib/features/open/open.js
  var require_open = __commonJS({
    "node_modules/sprotty/lib/features/open/open.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OpenMouseListener = void 0;
      var actions_1 = require_actions();
      var mouse_tool_1 = require_mouse_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model16();
      var OpenMouseListener = class extends mouse_tool_1.MouseListener {
        doubleClick(target, event) {
          const openableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_1.isOpenable);
          if (openableTarget !== void 0) {
            return [actions_1.OpenAction.create(openableTarget.id)];
          }
          return [];
        }
      };
      exports.OpenMouseListener = OpenMouseListener;
    }
  });

  // node_modules/sprotty/lib/features/projection/model.js
  var require_model17 = __commonJS({
    "node_modules/sprotty/lib/features/projection/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getModelBounds = exports.getProjectedBounds = exports.getProjections = exports.isProjectable = void 0;
      var geometry_1 = require_geometry();
      var object_1 = require_object();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model2();
      function isProjectable(arg) {
        return (0, object_1.hasOwnProperty)(arg, "projectionCssClasses");
      }
      exports.isProjectable = isProjectable;
      function getProjections(parent) {
        let result;
        for (const child of parent.children) {
          if (isProjectable(child) && child.projectionCssClasses.length > 0) {
            const projectedBounds = getProjectedBounds(child);
            if (projectedBounds) {
              const projection = {
                elementId: child.id,
                projectedBounds,
                cssClasses: child.projectionCssClasses
              };
              if (result) {
                result.push(projection);
              } else {
                result = [projection];
              }
            }
          }
          if (child.children.length > 0) {
            const childProj = getProjections(child);
            if (childProj) {
              if (result) {
                result.push(...childProj);
              } else {
                result = childProj;
              }
            }
          }
        }
        return result;
      }
      exports.getProjections = getProjections;
      function getProjectedBounds(model) {
        const parent = model.parent;
        if (model.projectedBounds) {
          let bounds = model.projectedBounds;
          if ((0, model_1.isBoundsAware)(parent)) {
            bounds = (0, smodel_utils_1.transformToRootBounds)(parent, bounds);
          }
          return bounds;
        } else if ((0, model_1.isBoundsAware)(model)) {
          let bounds = model.bounds;
          bounds = (0, smodel_utils_1.transformToRootBounds)(parent, bounds);
          return bounds;
        }
        return void 0;
      }
      exports.getProjectedBounds = getProjectedBounds;
      var MAX_COORD = 1e9;
      function getModelBounds(model) {
        let minX = MAX_COORD;
        let minY = MAX_COORD;
        let maxX = -MAX_COORD;
        let maxY = -MAX_COORD;
        const bounds = (0, model_1.isBoundsAware)(model) ? model.bounds : void 0;
        if (bounds && geometry_1.Dimension.isValid(bounds)) {
          minX = bounds.x;
          minY = bounds.y;
          maxX = minX + bounds.width;
          maxY = minY + bounds.height;
        } else {
          for (const element of model.children) {
            if ((0, model_1.isBoundsAware)(element)) {
              const b = element.bounds;
              minX = Math.min(minX, b.x);
              minY = Math.min(minY, b.y);
              maxX = Math.max(maxX, b.x + b.width);
              maxY = Math.max(maxY, b.y + b.height);
            }
          }
        }
        minX = Math.min(minX, model.scroll.x);
        minY = Math.min(minY, model.scroll.y);
        maxX = Math.max(maxX, model.scroll.x + model.canvasBounds.width / model.zoom);
        maxY = Math.max(maxY, model.scroll.y + model.canvasBounds.height / model.zoom);
        if (minX < maxX && minY < maxY) {
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        }
        return void 0;
      }
      exports.getModelBounds = getModelBounds;
    }
  });

  // node_modules/sprotty/lib/features/projection/views.js
  var require_views4 = __commonJS({
    "node_modules/sprotty/lib/features/projection/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProjectedViewportView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_inversify();
      var snabbdom_1 = require_snabbdom_cjs();
      var vnode_utils_1 = require_vnode_utils();
      var model_1 = require_model17();
      var ProjectedViewportView = class ProjectedViewportView {
        render(model, context, args) {
          const rootNode = (0, jsx_1.html)(
            "div",
            { "class-sprotty-root": true },
            this.renderSvg(model, context, args),
            this.renderProjections(model, context, args)
          );
          (0, vnode_utils_1.setAttr)(rootNode, "tabindex", 0);
          return rootNode;
        }
        renderSvg(model, context, args) {
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          const ns = "http://www.w3.org/2000/svg";
          return (0, snabbdom_1.h)("svg", { ns }, (0, snabbdom_1.h)("g", { ns, attrs: { transform } }, context.renderChildren(model)));
        }
        renderProjections(model, context, args) {
          var _a;
          if (model.zoom <= 0) {
            return [];
          }
          const modelBounds = (0, model_1.getModelBounds)(model);
          if (!modelBounds) {
            return [];
          }
          const projections = (_a = (0, model_1.getProjections)(model)) !== null && _a !== void 0 ? _a : [];
          return [
            this.renderProjectionBar(projections, model, modelBounds, "vertical"),
            this.renderProjectionBar(projections, model, modelBounds, "horizontal")
          ];
        }
        renderProjectionBar(projections, model, modelBounds, orientation) {
          const params = { modelBounds, orientation };
          params.factor = orientation === "horizontal" ? model.canvasBounds.width / modelBounds.width : model.canvasBounds.height / modelBounds.height;
          params.zoomedFactor = params.factor / model.zoom;
          return (0, jsx_1.html)(
            "div",
            { "class-sprotty-projection-bar": true, "class-horizontal": orientation === "horizontal", "class-vertical": orientation === "vertical" },
            this.renderViewport(model, params),
            projections.map((p) => this.renderProjection(p, model, params))
          );
        }
        renderViewport(model, params) {
          let canvasSize, viewportPos;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            viewportPos = (model.scroll.x - params.modelBounds.x) * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            viewportPos = (model.scroll.y - params.modelBounds.y) * params.factor;
          }
          let viewportSize = canvasSize * params.zoomedFactor;
          if (viewportPos < 0) {
            viewportSize += viewportPos;
            viewportPos = 0;
          } else if (viewportPos > canvasSize) {
            viewportPos = canvasSize;
          }
          if (viewportSize < 0) {
            viewportSize = 0;
          } else if (viewportPos + viewportSize > canvasSize) {
            viewportSize = canvasSize - viewportPos;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${viewportPos}px`,
            width: `${viewportSize}px`
          } : {
            top: `${viewportPos}px`,
            height: `${viewportSize}px`
          };
          return (0, jsx_1.html)("div", { "class-sprotty-viewport": true, style });
        }
        renderProjection(projection, model, params) {
          let canvasSize, projPos, projSize;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            projPos = (projection.projectedBounds.x - params.modelBounds.x) * params.factor;
            projSize = projection.projectedBounds.width * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            projPos = (projection.projectedBounds.y - params.modelBounds.y) * params.factor;
            projSize = projection.projectedBounds.height * params.factor;
          }
          if (projPos < 0) {
            projSize += projPos;
            projPos = 0;
          } else if (projPos > canvasSize) {
            projPos = canvasSize;
          }
          if (projSize < 0) {
            projSize = 0;
          } else if (projPos + projSize > canvasSize) {
            projSize = canvasSize - projPos;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${projPos}px`,
            width: `${projSize}px`
          } : {
            top: `${projPos}px`,
            height: `${projSize}px`
          };
          const result = (0, jsx_1.html)("div", { id: `${params.orientation}-projection:${projection.elementId}`, "class-sprotty-projection": true, style });
          projection.cssClasses.forEach((cl) => (0, vnode_utils_1.setClass)(result, cl, true));
          return result;
        }
      };
      exports.ProjectedViewportView = ProjectedViewportView;
      exports.ProjectedViewportView = ProjectedViewportView = __decorate([
        (0, inversify_1.injectable)()
      ], ProjectedViewportView);
    }
  });

  // node_modules/sprotty/lib/features/routing/polyline-anchors.js
  var require_polyline_anchors = __commonJS({
    "node_modules/sprotty/lib/features/routing/polyline-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiamondAnchor = exports.RectangleAnchor = exports.EllipseAnchor = void 0;
      var anchor_1 = require_anchor();
      var geometry_1 = require_geometry2();
      var inversify_1 = require_inversify();
      var polyline_edge_router_1 = require_polyline_edge_router();
      var geometry_2 = require_geometry();
      var EllipseAnchor = class EllipseAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const bounds = connectable.bounds;
          const c = geometry_2.Bounds.center(bounds);
          const dx = c.x - refPoint.x;
          const dy = c.y - refPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const normX = dx / distance || 0;
          const normY = dy / distance || 0;
          return {
            x: c.x - normX * (0.5 * bounds.width + offset),
            y: c.y - normY * (0.5 * bounds.height + offset)
          };
        }
      };
      exports.EllipseAnchor = EllipseAnchor;
      exports.EllipseAnchor = EllipseAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], EllipseAnchor);
      var RectangleAnchor = class RectangleAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const bounds = connectable.bounds;
          const c = geometry_2.Bounds.center(bounds);
          const finder = new NearestPointFinder(c, refPoint);
          if (!(0, geometry_2.almostEquals)(c.y, refPoint.y)) {
            const xTop = this.getXIntersection(bounds.y, c, refPoint);
            if (xTop >= bounds.x && xTop <= bounds.x + bounds.width)
              finder.addCandidate(xTop, bounds.y - offset);
            const xBottom = this.getXIntersection(bounds.y + bounds.height, c, refPoint);
            if (xBottom >= bounds.x && xBottom <= bounds.x + bounds.width)
              finder.addCandidate(xBottom, bounds.y + bounds.height + offset);
          }
          if (!(0, geometry_2.almostEquals)(c.x, refPoint.x)) {
            const yLeft = this.getYIntersection(bounds.x, c, refPoint);
            if (yLeft >= bounds.y && yLeft <= bounds.y + bounds.height)
              finder.addCandidate(bounds.x - offset, yLeft);
            const yRight = this.getYIntersection(bounds.x + bounds.width, c, refPoint);
            if (yRight >= bounds.y && yRight <= bounds.y + bounds.height)
              finder.addCandidate(bounds.x + bounds.width + offset, yRight);
          }
          return finder.best;
        }
        getXIntersection(yIntersection, centerPoint, point) {
          const t = (yIntersection - centerPoint.y) / (point.y - centerPoint.y);
          return (point.x - centerPoint.x) * t + centerPoint.x;
        }
        getYIntersection(xIntersection, centerPoint, point) {
          const t = (xIntersection - centerPoint.x) / (point.x - centerPoint.x);
          return (point.y - centerPoint.y) * t + centerPoint.y;
        }
      };
      exports.RectangleAnchor = RectangleAnchor;
      exports.RectangleAnchor = RectangleAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], RectangleAnchor);
      var NearestPointFinder = class {
        constructor(centerPoint, refPoint) {
          this.centerPoint = centerPoint;
          this.refPoint = refPoint;
          this.currentDist = -1;
        }
        addCandidate(x, y) {
          const dx = this.refPoint.x - x;
          const dy = this.refPoint.y - y;
          const dist = dx * dx + dy * dy;
          if (this.currentDist < 0 || dist < this.currentDist) {
            this.currentBest = {
              x,
              y
            };
            this.currentDist = dist;
          }
        }
        get best() {
          if (this.currentBest === void 0)
            return this.centerPoint;
          else
            return this.currentBest;
        }
      };
      var DiamondAnchor = class DiamondAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset) {
          const bounds = connectable.bounds;
          const referenceLine = new geometry_1.PointToPointLine(geometry_2.Bounds.center(bounds), refPoint);
          const closestDiamondSide = new geometry_1.Diamond(bounds).closestSideLine(refPoint);
          const anchorPoint = (0, geometry_1.intersection)(closestDiamondSide, referenceLine);
          return geometry_2.Point.shiftTowards(anchorPoint, refPoint, offset);
        }
      };
      exports.DiamondAnchor = DiamondAnchor;
      exports.DiamondAnchor = DiamondAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], DiamondAnchor);
    }
  });

  // node_modules/sprotty/lib/features/routing/bezier-edge-router.js
  var require_bezier_edge_router = __commonJS({
    "node_modules/sprotty/lib/features/routing/bezier-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var BezierEdgeRouter_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AddRemoveBezierSegmentCommand = exports.AddRemoveBezierSegmentAction = exports.BezierMouseListener = exports.BezierEdgeRouter = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var mouse_tool_1 = require_mouse_tool();
      var command_1 = require_command();
      var types_1 = require_types();
      var BezierEdgeRouter = BezierEdgeRouter_1 = class BezierEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return BezierEdgeRouter_1.KIND;
        }
        route(edge) {
          if (!edge.source || !edge.target)
            return [];
          const rpCount = edge.routingPoints.length;
          const source = edge.source;
          const target = edge.target;
          const result = [];
          result.push({ kind: "source", x: 0, y: 0 });
          if (rpCount === 0) {
            const [h1, h2] = this.createDefaultBezierHandles(source.position, target.position);
            result.push({ kind: "bezier-control-after", x: h1.x, y: h1.y, pointIndex: 0 });
            result.push({ kind: "bezier-control-before", x: h2.x, y: h2.y, pointIndex: 1 });
            edge.routingPoints.push(h1);
            edge.routingPoints.push(h2);
          } else if (rpCount >= 2) {
            for (let i = 0; i < rpCount; i++) {
              const p = edge.routingPoints[i];
              if (i % 3 === 0) {
                result.push({ kind: "bezier-control-after", x: p.x, y: p.y, pointIndex: i });
              }
              if ((i + 1) % 3 === 0) {
                result.push({ kind: "bezier-junction", x: p.x, y: p.y, pointIndex: i });
              } else if ((i + 2) % 3 === 0) {
                result.push({ kind: "bezier-control-before", x: p.x, y: p.y, pointIndex: i });
              }
            }
          }
          result.push({ kind: "target", x: 0, y: 0 });
          const p0 = rpCount > 2 ? edge.routingPoints[2] : target.position;
          const pn = rpCount > 2 ? edge.routingPoints[edge.routingPoints.length - 3] : source.position;
          const sourceAnchor = this.getTranslatedAnchor(source, p0, target.parent, edge, edge.sourceAnchorCorrection);
          const targetAnchor = this.getTranslatedAnchor(target, pn, source.parent, edge, edge.targetAnchorCorrection);
          result[0] = { kind: "source", x: sourceAnchor.x, y: sourceAnchor.y };
          result[result.length - 1] = { kind: "target", x: targetAnchor.x, y: targetAnchor.y };
          return result;
        }
        createDefaultBezierHandles(relH1, relH2) {
          const h1 = {
            x: relH1.x - BezierEdgeRouter_1.DEFAULT_BEZIER_HANDLE_OFFSET,
            y: relH1.y
          };
          const h2 = {
            x: relH2.x + BezierEdgeRouter_1.DEFAULT_BEZIER_HANDLE_OFFSET,
            y: relH2.y
          };
          return [h1, h2];
        }
        createRoutingHandles(edge) {
          this.route(edge);
          this.rebuildHandles(edge);
        }
        rebuildHandles(edge) {
          this.addHandle(edge, "source", "routing-point", -2);
          this.addHandle(edge, "bezier-control-after", "bezier-routing-point", 0);
          this.addHandle(edge, "bezier-add", "bezier-create-routing-point", 0);
          const rpCount = edge.routingPoints.length;
          if (rpCount > 2) {
            for (let i = 1; i < rpCount - 1; i += 3) {
              this.addHandle(edge, "bezier-control-before", "bezier-routing-point", i);
              this.addHandle(edge, "bezier-add", "bezier-create-routing-point", i + 1);
              this.addHandle(edge, "bezier-junction", "routing-point", i + 1);
              this.addHandle(edge, "bezier-remove", "bezier-remove-routing-point", i + 1);
              this.addHandle(edge, "bezier-control-after", "bezier-routing-point", i + 2);
              this.moveBezierControlPair(edge.routingPoints[i], i, edge);
            }
          }
          this.addHandle(edge, "bezier-control-before", "bezier-routing-point", rpCount - 1);
          this.addHandle(edge, "target", "routing-point", -1);
        }
        getInnerHandlePosition(edge, route, handle) {
          if (handle.kind === "bezier-control-before" || handle.kind === "bezier-junction" || handle.kind === "bezier-control-after") {
            for (let i = 0; i < route.length; i++) {
              const p = route[i];
              if (p.pointIndex === handle.pointIndex && p.kind === handle.kind)
                return p;
            }
          } else if (handle.kind === "bezier-add") {
            const ctrlPoint = this.findBezierControl(edge, route, handle.pointIndex);
            return { x: ctrlPoint.x, y: ctrlPoint.y + 12.5 };
          } else if (handle.kind === "bezier-remove") {
            const ctrlPoint = this.findBezierControl(edge, route, handle.pointIndex);
            return { x: ctrlPoint.x, y: ctrlPoint.y - 12.5 };
          }
          return void 0;
        }
        findBezierControl(edge, route, handleIndex) {
          let result = { x: route[0].x, y: route[0].y };
          if (handleIndex > 0) {
            for (const rp of route) {
              if (rp.pointIndex !== void 0 && rp.pointIndex === handleIndex && rp.kind === "bezier-junction") {
                result = { x: rp.x, y: rp.y };
                break;
              }
            }
          }
          return result;
        }
        applyHandleMoves(edge, moves) {
          moves.forEach((move) => {
            const handle = move.handle;
            let orgPosition = { x: 0, y: 0 };
            let relativePos, newControlPos, ctrlPointIndex;
            const moveToPos = move.toPosition;
            switch (handle.kind) {
              case "bezier-control-before":
              case "bezier-control-after":
                this.moveBezierControlPair(moveToPos, move.handle.pointIndex, edge);
                break;
              case "bezier-junction":
                const index = handle.pointIndex;
                if (index >= 0 && index < edge.routingPoints.length) {
                  ctrlPointIndex = index - 1;
                  orgPosition = edge.routingPoints[index];
                  relativePos = edge.routingPoints[ctrlPointIndex];
                  newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                  edge.routingPoints[index] = moveToPos;
                  this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                }
                break;
              case "source":
                ctrlPointIndex = 0;
                relativePos = edge.routingPoints[ctrlPointIndex];
                if (!(edge.source instanceof model_1.SDanglingAnchorImpl)) {
                  const anchor = new model_1.SDanglingAnchorImpl();
                  anchor.id = edge.id + "_dangling-source";
                  anchor.original = edge.source;
                  anchor.position = move.toPosition;
                  handle.root.add(anchor);
                  handle.danglingAnchor = anchor;
                  edge.sourceId = anchor.id;
                  if (edge.source)
                    orgPosition = edge.source.position;
                } else if (handle.danglingAnchor) {
                  orgPosition = handle.danglingAnchor.position;
                  handle.danglingAnchor.position = moveToPos;
                }
                newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                break;
              case "target":
                ctrlPointIndex = edge.routingPoints.length - 1;
                relativePos = edge.routingPoints[ctrlPointIndex];
                if (!(edge.target instanceof model_1.SDanglingAnchorImpl)) {
                  const anchor = new model_1.SDanglingAnchorImpl();
                  anchor.id = edge.id + "_dangling-target";
                  anchor.original = edge.target;
                  anchor.position = moveToPos;
                  handle.root.add(anchor);
                  handle.danglingAnchor = anchor;
                  edge.targetId = anchor.id;
                  if (edge.target)
                    orgPosition = edge.target.position;
                } else if (handle.danglingAnchor) {
                  orgPosition = handle.danglingAnchor.position;
                  handle.danglingAnchor.position = moveToPos;
                }
                newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                break;
              default:
                break;
            }
          });
        }
        applyInnerHandleMoves(edge, moves) {
        }
        getOptions(edge) {
          return {
            minimalPointDistance: 2,
            standardDistance: 0.1,
            selfEdgeOffset: 20
          };
        }
        calcRelativeMove(oldPos, newPos, relativePoint) {
          return {
            x: relativePoint.x - (oldPos.x - newPos.x),
            y: relativePoint.y - (oldPos.y - newPos.y)
          };
        }
        createNewBezierSegment(index, edge) {
          const routingPoints = edge.routingPoints;
          let bezierJunctionPos, start, end;
          if (routingPoints.length === 2) {
            start = routingPoints[index < 0 ? 0 : index];
            end = routingPoints[routingPoints.length - 1];
            bezierJunctionPos = (0, geometry_1.centerOfLine)(start, end);
          } else {
            start = routingPoints[index];
            end = routingPoints[index + 2];
            bezierJunctionPos = (0, geometry_1.centerOfLine)(start, end);
          }
          const [h1, h2] = this.createDefaultBezierHandles(bezierJunctionPos, bezierJunctionPos);
          routingPoints.splice(index + 1, 0, h1);
          routingPoints.splice(index + 2, 0, bezierJunctionPos);
          routingPoints.splice(index + 3, 0, h2);
          this.moveBezierControlPair(h1, index + 1, edge);
          edge.removeAll((c) => c instanceof model_1.SRoutingHandleImpl);
          this.rebuildHandles(edge);
        }
        removeBezierSegment(index, edge) {
          const routingPoints = edge.routingPoints;
          routingPoints.splice(index - 1, 3);
          edge.removeAll((c) => c instanceof model_1.SRoutingHandleImpl);
          this.rebuildHandles(edge);
        }
        moveBezierControlPair(newPos, ctrlPointIndex, edge) {
          if (ctrlPointIndex >= 0 && ctrlPointIndex < edge.routingPoints.length) {
            const before = ctrlPointIndex - 1;
            const after = ctrlPointIndex + 1;
            if (before < 0 || after === edge.routingPoints.length) {
              edge.routingPoints[ctrlPointIndex] = newPos;
            } else {
              if (ctrlPointIndex % 3 === 0) {
                this.setBezierMirror(edge, newPos, ctrlPointIndex, false);
              } else if ((ctrlPointIndex + 2) % 3 === 0) {
                this.setBezierMirror(edge, newPos, ctrlPointIndex, true);
              }
            }
          }
        }
        setBezierMirror(edge, newPos, pointIndex, before) {
          edge.routingPoints[pointIndex] = newPos;
          const jct = edge.routingPoints[before ? pointIndex + 1 : pointIndex - 1];
          edge.routingPoints[before ? pointIndex + 2 : pointIndex - 2] = {
            x: jct.x - (newPos.x - jct.x),
            y: jct.y - (newPos.y - jct.y)
          };
        }
      };
      exports.BezierEdgeRouter = BezierEdgeRouter;
      BezierEdgeRouter.KIND = "bezier";
      BezierEdgeRouter.DEFAULT_BEZIER_HANDLE_OFFSET = 25;
      exports.BezierEdgeRouter = BezierEdgeRouter = BezierEdgeRouter_1 = __decorate([
        (0, inversify_1.injectable)()
      ], BezierEdgeRouter);
      var BezierMouseListener = class extends mouse_tool_1.MouseListener {
        mouseDown(target, event) {
          const result = [];
          if (target instanceof model_1.SRoutingHandleImpl && (target.kind === "bezier-add" || target.kind === "bezier-remove")) {
            if (target.type === "bezier-create-routing-point") {
              result.push(AddRemoveBezierSegmentAction.create("add", target.id));
            } else if (target.type === "bezier-remove-routing-point") {
              result.push(AddRemoveBezierSegmentAction.create("remove", target.id));
            }
          }
          return result;
        }
      };
      exports.BezierMouseListener = BezierMouseListener;
      var AddRemoveBezierSegmentAction;
      (function(AddRemoveBezierSegmentAction2) {
        AddRemoveBezierSegmentAction2.KIND = "addRemoveBezierSegment";
        function create(actionTask, targetId) {
          return {
            kind: AddRemoveBezierSegmentAction2.KIND,
            actionTask,
            targetId
          };
        }
        AddRemoveBezierSegmentAction2.create = create;
      })(AddRemoveBezierSegmentAction || (exports.AddRemoveBezierSegmentAction = AddRemoveBezierSegmentAction = {}));
      var AddRemoveBezierSegmentCommand = class AddRemoveBezierSegmentCommand extends command_1.Command {
        constructor(action, edgeRouterRegistry) {
          super();
          this.action = action;
          this.edgeRouterRegistry = edgeRouterRegistry;
        }
        execute(context) {
          const index = context.root.index;
          const target = index.getById(this.action.targetId);
          if (this.edgeRouterRegistry && target instanceof model_1.SRoutingHandleImpl) {
            const raw = this.edgeRouterRegistry.get(target.parent.routerKind);
            if (raw instanceof BezierEdgeRouter) {
              const router = raw;
              for (const child of context.root.children) {
                if (child.id === target.parent.id) {
                  if (this.action.actionTask === "add") {
                    router.createNewBezierSegment(target.pointIndex, child);
                  } else if (this.action.actionTask === "remove") {
                    router.removeBezierSegment(target.pointIndex, child);
                  }
                  break;
                }
              }
            }
          }
          return context.root;
        }
        undo(context) {
          throw new Error("Method not implemented.");
        }
        redo(context) {
          throw new Error("Method not implemented.");
        }
      };
      exports.AddRemoveBezierSegmentCommand = AddRemoveBezierSegmentCommand;
      AddRemoveBezierSegmentCommand.KIND = AddRemoveBezierSegmentAction.KIND;
      exports.AddRemoveBezierSegmentCommand = AddRemoveBezierSegmentCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(routing_1.EdgeRouterRegistry)),
        __metadata("design:paramtypes", [Object, routing_1.EdgeRouterRegistry])
      ], AddRemoveBezierSegmentCommand);
    }
  });

  // node_modules/sprotty/lib/features/routing/bezier-anchors.js
  var require_bezier_anchors = __commonJS({
    "node_modules/sprotty/lib/features/routing/bezier-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BezierDiamondAnchor = exports.BezierRectangleAnchor = exports.BezierEllipseAnchor = void 0;
      var anchor_1 = require_anchor();
      var inversify_1 = require_inversify();
      var polyline_anchors_1 = require_polyline_anchors();
      var bezier_edge_router_1 = require_bezier_edge_router();
      var BezierEllipseAnchor = class BezierEllipseAnchor extends polyline_anchors_1.EllipseAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.BezierEllipseAnchor = BezierEllipseAnchor;
      exports.BezierEllipseAnchor = BezierEllipseAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierEllipseAnchor);
      var BezierRectangleAnchor = class BezierRectangleAnchor extends polyline_anchors_1.RectangleAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.BezierRectangleAnchor = BezierRectangleAnchor;
      exports.BezierRectangleAnchor = BezierRectangleAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierRectangleAnchor);
      var BezierDiamondAnchor = class BezierDiamondAnchor extends polyline_anchors_1.DiamondAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
        }
      };
      exports.BezierDiamondAnchor = BezierDiamondAnchor;
      exports.BezierDiamondAnchor = BezierDiamondAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierDiamondAnchor);
    }
  });

  // node_modules/sprotty/lib/features/routing/manhattan-edge-router.js
  var require_manhattan_edge_router = __commonJS({
    "node_modules/sprotty/lib/features/routing/manhattan-edge-router.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ManhattanEdgeRouter = void 0;
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var model_1 = require_model9();
      var ManhattanEdgeRouter = class extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return ManhattanEdgeRouter.KIND;
        }
        getOptions(edge) {
          return {
            standardDistance: 20,
            minimalPointDistance: 3,
            selfEdgeOffset: 0.25
          };
        }
        route(edge) {
          if (!edge.source || !edge.target)
            return [];
          const routedCorners = this.createRoutedCorners(edge);
          const sourceRefPoint = routedCorners[0] || (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(edge.target.bounds), edge.target.parent, edge.parent);
          const sourceAnchor = this.getTranslatedAnchor(edge.source, sourceRefPoint, edge.parent, edge, edge.sourceAnchorCorrection);
          const targetRefPoint = routedCorners[routedCorners.length - 1] || (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(edge.source.bounds), edge.source.parent, edge.parent);
          const targetAnchor = this.getTranslatedAnchor(edge.target, targetRefPoint, edge.parent, edge, edge.targetAnchorCorrection);
          if (!sourceAnchor || !targetAnchor)
            return [];
          const routedPoints = [];
          routedPoints.push(Object.assign({ kind: "source" }, sourceAnchor));
          routedCorners.forEach((corner) => routedPoints.push(corner));
          routedPoints.push(Object.assign({ kind: "target" }, targetAnchor));
          return routedPoints;
        }
        createRoutedCorners(edge) {
          const sourceAnchors = new abstract_edge_router_1.DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new abstract_edge_router_1.DefaultAnchors(edge.target, edge.parent, "target");
          if (edge.routingPoints.length > 0) {
            const routingPointsCopy = edge.routingPoints.slice();
            this.cleanupRoutingPoints(edge, routingPointsCopy, false, true);
            if (routingPointsCopy.length > 0)
              return routingPointsCopy.map((routingPoint, index) => {
                return Object.assign({ kind: "linear", pointIndex: index }, routingPoint);
              });
          }
          const options = this.getOptions(edge);
          const corners = this.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
          return corners.map((corner) => {
            return Object.assign({ kind: "linear" }, corner);
          });
        }
        createRoutingHandles(edge) {
          const routedPoints = this.route(edge);
          this.commitRoute(edge, routedPoints);
          if (routedPoints.length > 0) {
            this.addHandle(edge, "source", "routing-point", -2);
            for (let i = 0; i < routedPoints.length - 1; ++i)
              this.addHandle(edge, "manhattan-50%", "volatile-routing-point", i - 1);
            this.addHandle(edge, "target", "routing-point", routedPoints.length - 2);
          }
        }
        getInnerHandlePosition(edge, route, handle) {
          const fraction = this.getFraction(handle.kind);
          if (fraction !== void 0) {
            const { start, end } = this.findRouteSegment(edge, route, handle.pointIndex);
            if (start !== void 0 && end !== void 0)
              return geometry_1.Point.linear(start, end, fraction);
          }
          return void 0;
        }
        getFraction(kind) {
          switch (kind) {
            case "manhattan-50%":
              return 0.5;
            default:
              return void 0;
          }
        }
        applyInnerHandleMoves(edge, moves) {
          const route = this.route(edge);
          const routingPoints = edge.routingPoints;
          const minimalPointDistance = this.getOptions(edge).minimalPointDistance;
          moves.forEach((move) => {
            const handle = move.handle;
            const index = handle.pointIndex;
            const correctedX = this.correctX(routingPoints, index, move.toPosition.x, minimalPointDistance);
            const correctedY = this.correctY(routingPoints, index, move.toPosition.y, minimalPointDistance);
            switch (handle.kind) {
              case "manhattan-50%":
                if (index < 0) {
                  if (routingPoints.length === 0) {
                    routingPoints.push({ x: correctedX, y: correctedY });
                    handle.pointIndex = 0;
                  } else if ((0, geometry_1.almostEquals)(route[0].x, route[1].x)) {
                    this.alignX(routingPoints, 0, correctedX);
                  } else {
                    this.alignY(routingPoints, 0, correctedY);
                  }
                } else if (index < routingPoints.length - 1) {
                  if ((0, geometry_1.almostEquals)(routingPoints[index].x, routingPoints[index + 1].x)) {
                    this.alignX(routingPoints, index, correctedX);
                    this.alignX(routingPoints, index + 1, correctedX);
                  } else {
                    this.alignY(routingPoints, index, correctedY);
                    this.alignY(routingPoints, index + 1, correctedY);
                  }
                } else {
                  if ((0, geometry_1.almostEquals)(route[route.length - 2].x, route[route.length - 1].x)) {
                    this.alignX(routingPoints, routingPoints.length - 1, correctedX);
                  } else {
                    this.alignY(routingPoints, routingPoints.length - 1, correctedY);
                  }
                }
                break;
            }
          });
        }
        correctX(routingPoints, index, x, minimalPointDistance) {
          if (index > 0 && Math.abs(x - routingPoints[index - 1].x) < minimalPointDistance)
            return routingPoints[index - 1].x;
          else if (index < routingPoints.length - 2 && Math.abs(x - routingPoints[index + 2].x) < minimalPointDistance)
            return routingPoints[index + 2].x;
          else
            return x;
        }
        alignX(routingPoints, index, x) {
          if (index >= 0 && index < routingPoints.length)
            routingPoints[index] = {
              x,
              y: routingPoints[index].y
            };
        }
        correctY(routingPoints, index, y, minimalPointDistance) {
          if (index > 0 && Math.abs(y - routingPoints[index - 1].y) < minimalPointDistance)
            return routingPoints[index - 1].y;
          else if (index < routingPoints.length - 2 && Math.abs(y - routingPoints[index + 2].y) < minimalPointDistance)
            return routingPoints[index + 2].y;
          else
            return y;
        }
        alignY(routingPoints, index, y) {
          if (index >= 0 && index < routingPoints.length)
            routingPoints[index] = {
              x: routingPoints[index].x,
              y
            };
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          const sourceAnchors = new abstract_edge_router_1.DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new abstract_edge_router_1.DefaultAnchors(edge.target, edge.parent, "target");
          if (this.resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors))
            return;
          for (let i = 0; i < routingPoints.length; ++i)
            if (geometry_1.Bounds.includes(sourceAnchors.bounds, routingPoints[i])) {
              routingPoints.splice(0, 1);
              if (updateHandles) {
                this.removeHandle(edge, -1);
              }
            } else {
              break;
            }
          for (let i = routingPoints.length - 1; i >= 0; --i)
            if (geometry_1.Bounds.includes(targetAnchors.bounds, routingPoints[i])) {
              routingPoints.splice(i, 1);
              if (updateHandles) {
                this.removeHandle(edge, i);
              }
            } else {
              break;
            }
          if (routingPoints.length >= 2) {
            const options = this.getOptions(edge);
            for (let i = routingPoints.length - 2; i >= 0; --i) {
              if (geometry_1.Point.manhattanDistance(routingPoints[i], routingPoints[i + 1]) < options.minimalPointDistance) {
                routingPoints.splice(i, 2);
                --i;
                if (updateHandles) {
                  this.removeHandle(edge, i - 1);
                  this.removeHandle(edge, i);
                }
              }
            }
          }
          if (addRoutingPoints) {
            this.addAdditionalCorner(edge, routingPoints, sourceAnchors, targetAnchors, updateHandles);
            this.addAdditionalCorner(edge, routingPoints, targetAnchors, sourceAnchors, updateHandles);
            this.manhattanify(edge, routingPoints);
          }
        }
        removeHandle(edge, pointIndex) {
          const toBeRemoved = [];
          edge.children.forEach((child) => {
            if (child instanceof model_1.SRoutingHandleImpl) {
              if (child.pointIndex > pointIndex)
                --child.pointIndex;
              else if (child.pointIndex === pointIndex)
                toBeRemoved.push(child);
            }
          });
          toBeRemoved.forEach((child) => edge.remove(child));
        }
        addAdditionalCorner(edge, routingPoints, currentAnchors, otherAnchors, updateHandles) {
          if (routingPoints.length === 0)
            return;
          const refPoint = currentAnchors.kind === "source" ? routingPoints[0] : routingPoints[routingPoints.length - 1];
          const index = currentAnchors.kind === "source" ? 0 : routingPoints.length;
          const shiftIndex = index - (currentAnchors.kind === "source" ? 1 : 0);
          let isHorizontal;
          if (routingPoints.length > 1) {
            isHorizontal = index === 0 ? (0, geometry_1.almostEquals)(routingPoints[0].x, routingPoints[1].x) : (0, geometry_1.almostEquals)(routingPoints[routingPoints.length - 1].x, routingPoints[routingPoints.length - 2].x);
          } else {
            const nearestSide = otherAnchors.getNearestSide(refPoint);
            isHorizontal = nearestSide === abstract_edge_router_1.Side.TOP || nearestSide === abstract_edge_router_1.Side.BOTTOM;
          }
          if (isHorizontal) {
            if (refPoint.y < currentAnchors.get(abstract_edge_router_1.Side.TOP).y || refPoint.y > currentAnchors.get(abstract_edge_router_1.Side.BOTTOM).y) {
              const newPoint = { x: currentAnchors.get(abstract_edge_router_1.Side.TOP).x, y: refPoint.y };
              routingPoints.splice(index, 0, newPoint);
              if (updateHandles) {
                edge.children.forEach((child) => {
                  if (child instanceof model_1.SRoutingHandleImpl && child.pointIndex >= shiftIndex)
                    ++child.pointIndex;
                });
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", shiftIndex);
              }
            }
          } else {
            if (refPoint.x < currentAnchors.get(abstract_edge_router_1.Side.LEFT).x || refPoint.x > currentAnchors.get(abstract_edge_router_1.Side.RIGHT).x) {
              const newPoint = { x: refPoint.x, y: currentAnchors.get(abstract_edge_router_1.Side.LEFT).y };
              routingPoints.splice(index, 0, newPoint);
              if (updateHandles) {
                edge.children.forEach((child) => {
                  if (child instanceof model_1.SRoutingHandleImpl && child.pointIndex >= shiftIndex)
                    ++child.pointIndex;
                });
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", shiftIndex);
              }
            }
          }
        }
        /**
         * Add artificial routing points to keep all angles rectilinear.
         *
         * This makes edge morphing look a lot smoother, where RP positions are interpolated
         * linearly probably resulting in non-rectilinear angles. We don't add handles for
         * these additional RPs.
         */
        manhattanify(edge, routingPoints) {
          for (let i = 1; i < routingPoints.length; ++i) {
            const isVertical = Math.abs(routingPoints[i - 1].x - routingPoints[i].x) < 1;
            const isHorizontal = Math.abs(routingPoints[i - 1].y - routingPoints[i].y) < 1;
            if (!isVertical && !isHorizontal) {
              routingPoints.splice(i, 0, {
                x: routingPoints[i - 1].x,
                y: routingPoints[i].y
              });
              ++i;
            }
          }
        }
        calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options) {
          const selfEdge = super.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
          if (selfEdge.length > 0)
            return selfEdge;
          const bestAnchors = this.getBestConnectionAnchors(edge, sourceAnchors, targetAnchors, options);
          const sourceSide = bestAnchors.source;
          const targetSide = bestAnchors.target;
          const corners = [];
          const startPoint = sourceAnchors.get(sourceSide);
          let endPoint = targetAnchors.get(targetSide);
          switch (sourceSide) {
            case abstract_edge_router_1.Side.RIGHT:
              switch (targetSide) {
                case abstract_edge_router_1.Side.BOTTOM:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.RIGHT:
                  corners.push({ x: Math.max(startPoint.x, endPoint.x) + 1.5 * options.standardDistance, y: startPoint.y });
                  corners.push({ x: Math.max(startPoint.x, endPoint.x) + 1.5 * options.standardDistance, y: endPoint.y });
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.y !== startPoint.y) {
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: startPoint.y });
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: endPoint.y });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.LEFT:
              switch (targetSide) {
                case abstract_edge_router_1.Side.BOTTOM:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                default:
                  endPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
                  if (endPoint.y !== startPoint.y) {
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: startPoint.y });
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: endPoint.y });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.TOP:
              switch (targetSide) {
                case abstract_edge_router_1.Side.RIGHT:
                  if (endPoint.x - startPoint.x > 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.x - startPoint.x < 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: startPoint.x, y: Math.min(startPoint.y, endPoint.y) - 1.5 * options.standardDistance });
                  corners.push({ x: endPoint.x, y: Math.min(startPoint.y, endPoint.y) - 1.5 * options.standardDistance });
                  break;
                case abstract_edge_router_1.Side.BOTTOM:
                  if (endPoint.x !== startPoint.x) {
                    corners.push({ x: startPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                    corners.push({ x: endPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.BOTTOM:
              switch (targetSide) {
                case abstract_edge_router_1.Side.RIGHT:
                  if (endPoint.x - startPoint.x > 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.x - startPoint.x < 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                default:
                  endPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
                  if (endPoint.x !== startPoint.x) {
                    corners.push({ x: startPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                    corners.push({ x: endPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                  }
                  break;
              }
              break;
          }
          return corners;
        }
        getBestConnectionAnchors(edge, sourceAnchors, targetAnchors, options) {
          let sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          let targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.LEFT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.RIGHT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.BOTTOM };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.TOP };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (targetPoint.x - sourcePoint.x > 0.5 * options.standardDistance && targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.TOP };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (targetPoint.x - sourcePoint.x > 0.5 * options.standardDistance && sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.BOTTOM };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.LEFT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (sourcePoint.x - targetPoint.x > 0.5 * options.standardDistance && sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.BOTTOM };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (sourcePoint.x - targetPoint.x > 0.5 * options.standardDistance && targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.TOP };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (sourcePoint.y - targetPoint.y > 0.5 * options.standardDistance && sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (sourcePoint.y - targetPoint.y > 0.5 * options.standardDistance && targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (targetPoint.y - sourcePoint.y > 0.5 * options.standardDistance && sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (targetPoint.y - sourcePoint.y > 0.5 * options.standardDistance && targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint)) {
            if (sourcePoint.y - targetPoint.y < 0) {
              if (Math.abs(sourcePoint.x - targetPoint.x) > (sourceAnchors.bounds.width + options.standardDistance) / 2)
                return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.TOP };
            } else {
              if (Math.abs(sourcePoint.x - targetPoint.x) > targetAnchors.bounds.width / 2)
                return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.TOP };
            }
          }
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint)) {
            if (sourcePoint.x - targetPoint.x > 0) {
              if (Math.abs(sourcePoint.y - targetPoint.y) > (sourceAnchors.bounds.height + options.standardDistance) / 2)
                return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.RIGHT };
            } else if (Math.abs(sourcePoint.y - targetPoint.y) > targetAnchors.bounds.height / 2)
              return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.RIGHT };
          }
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.LEFT };
          return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.BOTTOM };
        }
      };
      exports.ManhattanEdgeRouter = ManhattanEdgeRouter;
      ManhattanEdgeRouter.KIND = "manhattan";
    }
  });

  // node_modules/sprotty/lib/features/routing/manhattan-anchors.js
  var require_manhattan_anchors = __commonJS({
    "node_modules/sprotty/lib/features/routing/manhattan-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var ManhattanRectangularAnchor_1;
      var ManhattanDiamondAnchor_1;
      var ManhattanEllipticAnchor_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ManhattanEllipticAnchor = exports.ManhattanDiamondAnchor = exports.ManhattanRectangularAnchor = void 0;
      var geometry_1 = require_geometry();
      var geometry_2 = require_geometry2();
      var anchor_1 = require_anchor();
      var manhattan_edge_router_1 = require_manhattan_edge_router();
      var inversify_1 = require_inversify();
      var ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = class ManhattanRectangularAnchor {
        get kind() {
          return ManhattanRectangularAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset) {
          const b = connectable.bounds;
          if (b.width <= 0 || b.height <= 0) {
            return b;
          }
          const bounds = {
            x: b.x - offset,
            y: b.y - offset,
            width: b.width + 2 * offset,
            height: b.height + 2 * offset
          };
          if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
            if (refPoint.y < bounds.y + 0.5 * bounds.height)
              return { x: refPoint.x, y: bounds.y };
            else
              return { x: refPoint.x, y: bounds.y + bounds.height };
          }
          if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
            if (refPoint.x < bounds.x + 0.5 * bounds.width)
              return { x: bounds.x, y: refPoint.y };
            else
              return { x: bounds.x + bounds.width, y: refPoint.y };
          }
          return geometry_1.Bounds.center(bounds);
        }
      };
      exports.ManhattanRectangularAnchor = ManhattanRectangularAnchor;
      ManhattanRectangularAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
      exports.ManhattanRectangularAnchor = ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanRectangularAnchor);
      var ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = class ManhattanDiamondAnchor {
        get kind() {
          return ManhattanDiamondAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const b = connectable.bounds;
          if (b.width <= 0 || b.height <= 0) {
            return b;
          }
          const bounds = {
            x: b.x - offset,
            y: b.y - offset,
            width: b.width + 2 * offset,
            height: b.height + 2 * offset
          };
          const c = geometry_1.Bounds.center(bounds);
          let outline = void 0;
          let refLine = void 0;
          if (refPoint.x >= bounds.x && refPoint.x <= bounds.x + bounds.width) {
            if (bounds.x + 0.5 * bounds.width >= refPoint.x) {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: refPoint.x, y: c.y });
              if (refPoint.y < c.y)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c.y }, { x: c.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c.y }, { x: c.x, y: bounds.y + bounds.height });
            } else {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: refPoint.x, y: c.y });
              if (refPoint.y < c.y)
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c.y }, { x: c.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c.y }, { x: c.x, y: bounds.y + bounds.height });
            }
          } else if (refPoint.y >= bounds.y && refPoint.y <= bounds.y + bounds.height) {
            if (bounds.y + 0.5 * bounds.height >= refPoint.y) {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: c.x, y: refPoint.y });
              if (refPoint.x < c.x)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c.y }, { x: c.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c.y }, { x: c.x, y: bounds.y });
            } else {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: c.x, y: refPoint.y });
              if (refPoint.x < c.x)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c.y }, { x: c.x, y: bounds.y + bounds.height });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c.y }, { x: c.x, y: bounds.y + bounds.height });
            }
          }
          if (!!refLine && !!outline)
            return (0, geometry_2.intersection)(outline, refLine);
          else
            return c;
        }
      };
      exports.ManhattanDiamondAnchor = ManhattanDiamondAnchor;
      ManhattanDiamondAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
      exports.ManhattanDiamondAnchor = ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanDiamondAnchor);
      var ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = class ManhattanEllipticAnchor {
        get kind() {
          return ManhattanEllipticAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const b = connectable.bounds;
          if (b.width <= 0 || b.height <= 0) {
            return b;
          }
          const bounds = {
            x: b.x - offset,
            y: b.y - offset,
            width: b.width + 2 * offset,
            height: b.height + 2 * offset
          };
          const c = geometry_1.Bounds.center(bounds);
          const refRelative = geometry_1.Point.subtract(refPoint, c);
          let x = c.x;
          let y = c.y;
          if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
            x += refRelative.x;
            const dy = 0.5 * bounds.height * Math.sqrt(1 - refRelative.x * refRelative.x / (0.25 * bounds.width * bounds.width));
            if (refRelative.y < 0)
              y -= dy;
            else
              y += dy;
          } else if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
            y += refRelative.y;
            const dx = 0.5 * bounds.width * Math.sqrt(1 - refRelative.y * refRelative.y / (0.25 * bounds.height * bounds.height));
            if (refRelative.x < 0)
              x -= dx;
            else
              x += dx;
          }
          return { x, y };
        }
      };
      exports.ManhattanEllipticAnchor = ManhattanEllipticAnchor;
      ManhattanEllipticAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
      exports.ManhattanEllipticAnchor = ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanEllipticAnchor);
    }
  });

  // node_modules/sprotty/lib/features/routing/views.js
  var require_views5 = __commonJS({
    "node_modules/sprotty/lib/features/routing/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RoutableView = void 0;
      var inversify_1 = require_inversify();
      var model_1 = require_model9();
      var RoutableView = class RoutableView {
        /**
         * Check whether the given model element is in the current viewport. Use this method
         * in your `render` implementation to skip rendering in case the element is not visible.
         * This can greatly enhance performance for large models.
         */
        isVisible(model, route, context) {
          if (context.targetKind === "hidden") {
            return true;
          }
          if (route.length === 0) {
            return true;
          }
          const ab = (0, model_1.getAbsoluteRouteBounds)(model, route);
          const canvasBounds = model.root.canvasBounds;
          return ab.x <= canvasBounds.width && ab.x + ab.width >= 0 && ab.y <= canvasBounds.height && ab.y + ab.height >= 0;
        }
      };
      exports.RoutableView = RoutableView;
      exports.RoutableView = RoutableView = __decorate([
        (0, inversify_1.injectable)()
      ], RoutableView);
    }
  });

  // node_modules/sprotty/lib/base/commands/request-command.js
  var require_request_command = __commonJS({
    "node_modules/sprotty/lib/base/commands/request-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModelRequestCommand = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var command_1 = require_command();
      var ModelRequestCommand = class ModelRequestCommand extends command_1.SystemCommand {
        execute(context) {
          const result = this.retrieveResult(context);
          this.actionDispatcher.dispatch(result);
          return { model: context.root, modelChanged: false };
        }
        undo(context) {
          return { model: context.root, modelChanged: false };
        }
        redo(context) {
          return { model: context.root, modelChanged: false };
        }
      };
      exports.ModelRequestCommand = ModelRequestCommand;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelRequestCommand.prototype, "actionDispatcher", void 0);
      exports.ModelRequestCommand = ModelRequestCommand = __decorate([
        (0, inversify_1.injectable)()
      ], ModelRequestCommand);
    }
  });

  // node_modules/sprotty/lib/features/viewport/scroll.js
  var require_scroll = __commonJS({
    "node_modules/sprotty/lib/features/viewport/scroll.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findViewportScrollbar = exports.ScrollMouseListener = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var mouse_tool_1 = require_mouse_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model12();
      var model_2 = require_model8();
      var model_3 = require_model9();
      var model_4 = require_model17();
      var browser_1 = require_browser();
      var types_1 = require_types();
      var ScrollMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.scrollbarMouseDownDelay = 200;
        }
        mouseDown(target, event) {
          const moveable = (0, smodel_utils_1.findParentByFeature)(target, model_2.isMoveable);
          if (moveable === void 0 && !(target instanceof model_3.SRoutingHandleImpl)) {
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              this.lastScrollPosition = { x: event.pageX, y: event.pageY };
              this.scrollbar = this.getScrollbar(event);
              if (this.scrollbar) {
                window.clearTimeout(this.scrollbarMouseDownTimeout);
                return this.moveScrollBar(viewport, event, this.scrollbar, true).map((action) => new Promise((resolve) => {
                  this.scrollbarMouseDownTimeout = window.setTimeout(() => resolve(action), this.scrollbarMouseDownDelay);
                }));
              }
            } else {
              this.lastScrollPosition = void 0;
              this.scrollbar = void 0;
            }
          }
          return [];
        }
        mouseMove(target, event) {
          if (event.buttons === 0) {
            return this.mouseUp(target, event);
          }
          if (this.scrollbar) {
            window.clearTimeout(this.scrollbarMouseDownTimeout);
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              return this.moveScrollBar(viewport, event, this.scrollbar);
            }
          }
          if (this.lastScrollPosition) {
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              return this.dragCanvas(viewport, event, this.lastScrollPosition);
            }
          }
          return [];
        }
        mouseEnter(target, event) {
          if (target instanceof smodel_1.SModelRootImpl && event.buttons === 0) {
            this.mouseUp(target, event);
          }
          return [];
        }
        mouseUp(target, event) {
          this.lastScrollPosition = void 0;
          this.scrollbar = void 0;
          return [];
        }
        doubleClick(target, event) {
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
          if (viewport) {
            const scrollbar = this.getScrollbar(event);
            if (scrollbar) {
              window.clearTimeout(this.scrollbarMouseDownTimeout);
              const targetElement = this.findClickTarget(scrollbar, event);
              let elementId;
              if (targetElement && targetElement.id.startsWith("horizontal-projection:")) {
                elementId = targetElement.id.substring("horizontal-projection:".length);
              } else if (targetElement && targetElement.id.startsWith("vertical-projection:")) {
                elementId = targetElement.id.substring("vertical-projection:".length);
              }
              if (elementId) {
                return [actions_1.CenterAction.create([elementId], { animate: true, retainZoom: true })];
              }
            }
          }
          return [];
        }
        dragCanvas(model, event, lastScrollPosition) {
          let dx = (event.pageX - lastScrollPosition.x) / model.zoom;
          if (dx > 0 && (0, geometry_1.almostEquals)(model.scroll.x, this.viewerOptions.horizontalScrollLimits.min) || dx < 0 && (0, geometry_1.almostEquals)(model.scroll.x, this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom)) {
            dx = 0;
          }
          let dy = (event.pageY - lastScrollPosition.y) / model.zoom;
          if (dy > 0 && (0, geometry_1.almostEquals)(model.scroll.y, this.viewerOptions.verticalScrollLimits.min) || dy < 0 && (0, geometry_1.almostEquals)(model.scroll.y, this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom)) {
            dy = 0;
          }
          if (dx === 0 && dy === 0) {
            return [];
          }
          const newViewport = {
            scroll: {
              x: model.scroll.x - dx,
              y: model.scroll.y - dy
            },
            zoom: model.zoom
          };
          this.lastScrollPosition = { x: event.pageX, y: event.pageY };
          return [actions_1.SetViewportAction.create(model.id, newViewport, { animate: false })];
        }
        moveScrollBar(model, event, scrollbar, animate = false) {
          const modelBounds = (0, model_4.getModelBounds)(model);
          if (!modelBounds || model.zoom <= 0) {
            return [];
          }
          const scrollbarRect = scrollbar.getBoundingClientRect();
          let newScroll;
          if (this.getScrollbarOrientation(scrollbar) === "horizontal") {
            if (scrollbarRect.width <= 0) {
              return [];
            }
            const viewportSize = model.canvasBounds.width / (model.zoom * modelBounds.width) * scrollbarRect.width;
            let position = event.clientX - scrollbarRect.x - viewportSize / 2;
            if (position < 0) {
              position = 0;
            } else if (position > scrollbarRect.width - viewportSize) {
              position = scrollbarRect.width - viewportSize;
            }
            newScroll = {
              x: modelBounds.x + position / scrollbarRect.width * modelBounds.width,
              y: model.scroll.y
            };
            if (newScroll.x < this.viewerOptions.horizontalScrollLimits.min) {
              newScroll.x = this.viewerOptions.horizontalScrollLimits.min;
            } else if (newScroll.x > this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom) {
              newScroll.x = this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom;
            }
            if ((0, geometry_1.almostEquals)(newScroll.x, model.scroll.x)) {
              return [];
            }
          } else {
            if (scrollbarRect.height <= 0) {
              return [];
            }
            const viewportSize = model.canvasBounds.height / (model.zoom * modelBounds.height) * scrollbarRect.height;
            let position = event.clientY - scrollbarRect.y - viewportSize / 2;
            if (position < 0) {
              position = 0;
            } else if (position > scrollbarRect.height - viewportSize) {
              position = scrollbarRect.height - viewportSize;
            }
            newScroll = {
              x: model.scroll.x,
              y: modelBounds.y + position / scrollbarRect.height * modelBounds.height
            };
            if (newScroll.y < this.viewerOptions.verticalScrollLimits.min) {
              newScroll.y = this.viewerOptions.verticalScrollLimits.min;
            } else if (newScroll.y > this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom) {
              newScroll.y = this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom;
            }
            if ((0, geometry_1.almostEquals)(newScroll.y, model.scroll.y)) {
              return [];
            }
          }
          return [actions_1.SetViewportAction.create(model.id, { scroll: newScroll, zoom: model.zoom }, { animate })];
        }
        getScrollbar(event) {
          return findViewportScrollbar(event);
        }
        getScrollbarOrientation(scrollbar) {
          if (scrollbar.classList.contains("horizontal")) {
            return "horizontal";
          } else {
            return "vertical";
          }
        }
        findClickTarget(scrollbar, event) {
          const matching = Array.from(scrollbar.children).filter((child) => child.id && child.classList.contains("sprotty-projection") && (0, browser_1.hitsMouseEvent)(child, event));
          if (matching.length > 0) {
            return matching[matching.length - 1];
          }
          return void 0;
        }
      };
      exports.ScrollMouseListener = ScrollMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ScrollMouseListener.prototype, "viewerOptions", void 0);
      function findViewportScrollbar(event) {
        let element = event.target;
        while (element) {
          if (element.classList && element.classList.contains("sprotty-projection-bar")) {
            return element;
          }
          element = element.parentElement;
        }
        return void 0;
      }
      exports.findViewportScrollbar = findViewportScrollbar;
    }
  });

  // node_modules/sprotty/lib/features/select/select.js
  var require_select = __commonJS({
    "node_modules/sprotty/lib/features/select/select.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectKeyboardListener = exports.GetSelectionCommand = exports.SelectMouseListener = exports.SelectAllCommand = exports.SelectCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var request_command_1 = require_request_command();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var key_tool_1 = require_key_tool();
      var mouse_tool_1 = require_mouse_tool();
      var vnode_utils_1 = require_vnode_utils();
      var browser_1 = require_browser();
      var iterable_1 = require_iterable();
      var keyboard_1 = require_keyboard();
      var button_handler_1 = require_button_handler();
      var model_1 = require_model4();
      var edit_routing_1 = require_edit_routing();
      var model_2 = require_model9();
      var model_3 = require_model9();
      var scroll_1 = require_scroll();
      var model_4 = require_model6();
      var SelectCommand = class SelectCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.selected = [];
          this.deselected = [];
        }
        execute(context) {
          const model = context.root;
          this.action.selectedElementsIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof smodel_1.SChildElementImpl && (0, model_4.isSelectable)(element)) {
              this.selected.push(element);
            }
          });
          this.action.deselectedElementsIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof smodel_1.SChildElementImpl && (0, model_4.isSelectable)(element)) {
              this.deselected.push(element);
            }
          });
          return this.redo(context);
        }
        undo(context) {
          for (const element of this.selected) {
            element.selected = false;
          }
          for (const element of this.deselected) {
            element.selected = true;
          }
          return context.root;
        }
        redo(context) {
          for (const element of this.deselected) {
            element.selected = false;
          }
          for (const element of this.selected) {
            element.selected = true;
          }
          return context.root;
        }
      };
      exports.SelectCommand = SelectCommand;
      SelectCommand.KIND = actions_1.SelectAction.KIND;
      exports.SelectCommand = SelectCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SelectCommand);
      var SelectAllCommand = class SelectAllCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.previousSelection = {};
        }
        execute(context) {
          this.selectAll(context.root, this.action.select);
          return context.root;
        }
        selectAll(element, newState) {
          if ((0, model_4.isSelectable)(element)) {
            this.previousSelection[element.id] = element.selected;
            element.selected = newState;
          }
          for (const child of element.children) {
            this.selectAll(child, newState);
          }
        }
        undo(context) {
          const index = context.root.index;
          Object.keys(this.previousSelection).forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0 && (0, model_4.isSelectable)(element))
              element.selected = this.previousSelection[id];
          });
          return context.root;
        }
        redo(context) {
          this.selectAll(context.root, this.action.select);
          return context.root;
        }
      };
      exports.SelectAllCommand = SelectAllCommand;
      SelectAllCommand.KIND = actions_1.SelectAllAction.KIND;
      exports.SelectAllCommand = SelectAllCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SelectAllCommand);
      var SelectMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.wasSelected = false;
          this.hasDragged = false;
        }
        mouseDown(target, event) {
          if (event.button !== 0) {
            return [];
          }
          const buttonHandled = this.handleButton(target, event);
          if (buttonHandled) {
            return buttonHandled;
          }
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_4.isSelectable);
          if (selectableTarget !== void 0 || target instanceof smodel_1.SModelRootImpl) {
            this.hasDragged = false;
          }
          if (selectableTarget !== void 0) {
            let deselectedElements = [];
            if (!(0, browser_1.isCtrlOrCmd)(event)) {
              deselectedElements = this.collectElementsToDeselect(target, selectableTarget);
            }
            if (selectableTarget !== void 0) {
              if (!selectableTarget.selected) {
                this.wasSelected = false;
                return this.handleSelectTarget(selectableTarget, deselectedElements, event);
              } else if ((0, browser_1.isCtrlOrCmd)(event)) {
                this.wasSelected = false;
                return this.handleDeselectTarget(selectableTarget, event);
              } else {
                this.wasSelected = true;
              }
            } else {
              return this.handleDeselectAll(deselectedElements, event);
            }
          }
          return [];
        }
        collectElementsToDeselect(target, selectableTarget) {
          return (0, iterable_1.toArray)(target.root.index.all().filter((element) => (0, model_4.isSelectable)(element) && element.selected && !(selectableTarget instanceof model_2.SRoutingHandleImpl && element === selectableTarget.parent)));
        }
        handleButton(target, event) {
          if (this.buttonHandlerRegistry !== void 0 && target instanceof model_1.SButtonImpl && target.enabled) {
            const buttonHandler = this.buttonHandlerRegistry.get(target.type);
            if (buttonHandler !== void 0) {
              return buttonHandler.buttonPressed(target);
            }
          }
          return void 0;
        }
        handleSelectTarget(selectableTarget, deselectedElements, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs: deselectedElements.map((e) => e.id) }));
          result.push(actions_1.BringToFrontAction.create([selectableTarget.id]));
          const routableDeselect = deselectedElements.filter((e) => e instanceof model_3.SRoutableElementImpl).map((e) => e.id);
          if (selectableTarget instanceof model_3.SRoutableElementImpl) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [selectableTarget.id], elementsToDeactivate: routableDeselect }));
          } else if (routableDeselect.length > 0) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: routableDeselect }));
          }
          return result;
        }
        handleDeselectTarget(selectableTarget, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: [selectableTarget.id] }));
          if (selectableTarget instanceof model_3.SRoutableElementImpl) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: [selectableTarget.id] }));
          }
          return result;
        }
        handleDeselectAll(deselectedElements, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: deselectedElements.map((e) => e.id) }));
          const routableDeselect = deselectedElements.filter((e) => e instanceof model_3.SRoutableElementImpl).map((e) => e.id);
          if (routableDeselect.length > 0) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: routableDeselect }));
          }
          return result;
        }
        mouseMove(target, event) {
          this.hasDragged = true;
          return [];
        }
        mouseUp(target, event) {
          if (event.button === 0) {
            if (!this.hasDragged) {
              const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_4.isSelectable);
              if (selectableTarget !== void 0) {
                if (this.wasSelected) {
                  return [actions_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs: [] })];
                }
              } else if (target instanceof smodel_1.SModelRootImpl && !(0, scroll_1.findViewportScrollbar)(event)) {
                return this.handleDeselectAll(this.collectElementsToDeselect(target, void 0), event);
              }
            }
          }
          this.hasDragged = false;
          return [];
        }
        decorate(vnode, element) {
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(element, model_4.isSelectable);
          if (selectableTarget !== void 0) {
            (0, vnode_utils_1.setClass)(vnode, "selected", selectableTarget.selected);
          }
          return vnode;
        }
      };
      exports.SelectMouseListener = SelectMouseListener;
      __decorate([
        (0, inversify_1.inject)(button_handler_1.ButtonHandlerRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", button_handler_1.ButtonHandlerRegistry)
      ], SelectMouseListener.prototype, "buttonHandlerRegistry", void 0);
      var GetSelectionCommand = class GetSelectionCommand extends request_command_1.ModelRequestCommand {
        constructor(action) {
          super();
          this.action = action;
          this.previousSelection = {};
        }
        retrieveResult(context) {
          const selection = context.root.index.all().filter((e) => (0, model_4.isSelectable)(e) && e.selected).map((e) => e.id);
          return actions_1.SelectionResult.create((0, iterable_1.toArray)(selection), this.action.requestId);
        }
      };
      exports.GetSelectionCommand = GetSelectionCommand;
      GetSelectionCommand.KIND = actions_1.GetSelectionAction.KIND;
      exports.GetSelectionCommand = GetSelectionCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], GetSelectionCommand);
      var SelectKeyboardListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyA", "ctrlCmd")) {
            return [actions_1.SelectAllAction.create()];
          }
          return [];
        }
      };
      exports.SelectKeyboardListener = SelectKeyboardListener;
    }
  });

  // node_modules/sprotty/lib/features/undo-redo/undo-redo.js
  var require_undo_redo = __commonJS({
    "node_modules/sprotty/lib/features/undo-redo/undo-redo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UndoRedoKeyListener = void 0;
      var actions_1 = require_actions();
      var keyboard_1 = require_keyboard();
      var key_tool_1 = require_key_tool();
      var browser_1 = require_browser();
      var UndoRedoKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd"))
            return [actions_1.UndoAction.create()];
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd", "shift") || !(0, browser_1.isMac)() && (0, keyboard_1.matchesKeystroke)(event, "KeyY", "ctrlCmd"))
            return [actions_1.RedoAction.create()];
          return [];
        }
      };
      exports.UndoRedoKeyListener = UndoRedoKeyListener;
    }
  });

  // node_modules/sprotty/lib/features/update/model-matching.js
  var require_model_matching = __commonJS({
    "node_modules/sprotty/lib/features/update/model-matching.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.applyMatches = exports.ModelMatcher = exports.forEachMatch = void 0;
      var smodel_1 = require_smodel();
      var sprotty_protocol_1 = require_lib();
      function forEachMatch(matchResult, callback) {
        Object.keys(matchResult).forEach((id) => callback(id, matchResult[id]));
      }
      exports.forEachMatch = forEachMatch;
      var ModelMatcher = class {
        match(left, right) {
          const result = {};
          this.matchLeft(left, result);
          this.matchRight(right, result);
          return result;
        }
        matchLeft(element, result, parentId) {
          let match = result[element.id];
          if (match !== void 0) {
            match.left = element;
            match.leftParentId = parentId;
          } else {
            match = {
              left: element,
              leftParentId: parentId
            };
            result[element.id] = match;
          }
          if ((0, smodel_1.isParent)(element)) {
            for (const child of element.children) {
              this.matchLeft(child, result, element.id);
            }
          }
        }
        matchRight(element, result, parentId) {
          let match = result[element.id];
          if (match !== void 0) {
            match.right = element;
            match.rightParentId = parentId;
          } else {
            match = {
              right: element,
              rightParentId: parentId
            };
            result[element.id] = match;
          }
          if ((0, smodel_1.isParent)(element)) {
            for (const child of element.children) {
              this.matchRight(child, result, element.id);
            }
          }
        }
      };
      exports.ModelMatcher = ModelMatcher;
      function applyMatches(root, matches, index) {
        if (root instanceof smodel_1.SModelRootImpl) {
          index = root.index;
        } else if (index === void 0) {
          index = new sprotty_protocol_1.SModelIndex();
          index.add(root);
        }
        for (const match of matches) {
          let newElementInserted = false;
          if (match.left !== void 0 && match.leftParentId !== void 0) {
            const parent = index.getById(match.leftParentId);
            if (parent !== void 0 && parent.children !== void 0) {
              const i = parent.children.indexOf(match.left);
              if (i >= 0) {
                if (match.right !== void 0 && match.leftParentId === match.rightParentId) {
                  parent.children.splice(i, 1, match.right);
                  newElementInserted = true;
                } else {
                  parent.children.splice(i, 1);
                }
              }
              index.remove(match.left);
            }
          }
          if (!newElementInserted && match.right !== void 0 && match.rightParentId !== void 0) {
            const parent = index.getById(match.rightParentId);
            if (parent !== void 0) {
              if (parent.children === void 0)
                parent.children = [];
              parent.children.push(match.right);
            }
          }
        }
      }
      exports.applyMatches = applyMatches;
    }
  });

  // node_modules/sprotty/lib/features/bounds/resize.js
  var require_resize = __commonJS({
    "node_modules/sprotty/lib/features/bounds/resize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResizeAnimation = void 0;
      var animation_1 = require_animation();
      var ResizeAnimation = class extends animation_1.Animation {
        constructor(model, elementResizes, context, reverse = false) {
          super(context);
          this.model = model;
          this.elementResizes = elementResizes;
          this.reverse = reverse;
        }
        tween(t) {
          this.elementResizes.forEach((elementResize) => {
            const element = elementResize.element;
            const newDimension = this.reverse ? {
              width: (1 - t) * elementResize.toDimension.width + t * elementResize.fromDimension.width,
              height: (1 - t) * elementResize.toDimension.height + t * elementResize.fromDimension.height
            } : {
              width: (1 - t) * elementResize.fromDimension.width + t * elementResize.toDimension.width,
              height: (1 - t) * elementResize.fromDimension.height + t * elementResize.toDimension.height
            };
            element.bounds = {
              x: element.bounds.x,
              y: element.bounds.y,
              width: newDimension.width,
              height: newDimension.height
            };
          });
          return this.model;
        }
      };
      exports.ResizeAnimation = ResizeAnimation;
    }
  });

  // node_modules/sprotty/lib/features/update/update-model.js
  var require_update_model = __commonJS({
    "node_modules/sprotty/lib/features/update/update-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UpdateModelCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var animation_1 = require_animation();
      var command_1 = require_command();
      var fade_1 = require_fade();
      var smodel_1 = require_smodel();
      var move_1 = require_move();
      var model_1 = require_model3();
      var model_2 = require_model8();
      var model_3 = require_model2();
      var viewport_root_1 = require_viewport_root();
      var model_4 = require_model6();
      var model_matching_1 = require_model_matching();
      var resize_1 = require_resize();
      var types_1 = require_types();
      var model_5 = require_model12();
      var routing_1 = require_routing();
      var model_6 = require_model9();
      var smodel_utils_1 = require_smodel_utils();
      var UpdateModelCommand = class UpdateModelCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          let newRoot;
          if (this.action.newRoot !== void 0) {
            newRoot = context.modelFactory.createRoot(this.action.newRoot);
          } else {
            newRoot = context.modelFactory.createRoot(context.root);
            if (this.action.matches !== void 0)
              this.applyMatches(newRoot, this.action.matches, context);
          }
          this.oldRoot = context.root;
          this.newRoot = newRoot;
          return this.performUpdate(this.oldRoot, this.newRoot, context);
        }
        performUpdate(oldRoot, newRoot, context) {
          if ((this.action.animate === void 0 || this.action.animate) && oldRoot.id === newRoot.id) {
            let matchResult;
            if (this.action.matches === void 0) {
              const matcher = new model_matching_1.ModelMatcher();
              matchResult = matcher.match(oldRoot, newRoot);
            } else {
              matchResult = this.convertToMatchResult(this.action.matches, oldRoot, newRoot);
            }
            const animationOrRoot = this.computeAnimation(newRoot, matchResult, context);
            if (animationOrRoot instanceof animation_1.Animation)
              return animationOrRoot.start();
            else
              return animationOrRoot;
          } else {
            if (oldRoot.type === newRoot.type && geometry_1.Dimension.isValid(oldRoot.canvasBounds))
              newRoot.canvasBounds = oldRoot.canvasBounds;
            if ((0, model_5.isViewport)(oldRoot) && (0, model_5.isViewport)(newRoot)) {
              newRoot.zoom = oldRoot.zoom;
              newRoot.scroll = oldRoot.scroll;
            }
            return newRoot;
          }
        }
        applyMatches(root, matches, context) {
          const index = root.index;
          for (const match of matches) {
            if (match.left !== void 0) {
              const element = index.getById(match.left.id);
              if (element instanceof smodel_1.SChildElementImpl)
                element.parent.remove(element);
            }
          }
          for (const match of matches) {
            if (match.right !== void 0) {
              const element = context.modelFactory.createElement(match.right);
              let parent;
              if (match.rightParentId !== void 0)
                parent = index.getById(match.rightParentId);
              if (parent instanceof smodel_1.SParentElementImpl)
                parent.add(element);
              else
                root.add(element);
            }
          }
        }
        convertToMatchResult(matches, leftRoot, rightRoot) {
          const result = {};
          for (const match of matches) {
            const converted = {};
            let id = void 0;
            if (match.left !== void 0) {
              id = match.left.id;
              converted.left = leftRoot.index.getById(id);
              converted.leftParentId = match.leftParentId;
            }
            if (match.right !== void 0) {
              id = match.right.id;
              converted.right = rightRoot.index.getById(id);
              converted.rightParentId = match.rightParentId;
            }
            if (id !== void 0)
              result[id] = converted;
          }
          return result;
        }
        computeAnimation(newRoot, matchResult, context) {
          const animationData = {
            fades: []
          };
          (0, model_matching_1.forEachMatch)(matchResult, (id, match) => {
            if (match.left !== void 0 && match.right !== void 0) {
              this.updateElement(match.left, match.right, animationData);
            } else if (match.right !== void 0) {
              const right = match.right;
              if ((0, model_1.isFadeable)(right)) {
                right.opacity = 0;
                animationData.fades.push({
                  element: right,
                  type: "in"
                });
              }
            } else if (match.left instanceof smodel_1.SChildElementImpl) {
              const left = match.left;
              if ((0, model_1.isFadeable)(left) && match.leftParentId !== void 0) {
                if (!(0, smodel_utils_1.containsSome)(newRoot, left)) {
                  const parent = newRoot.index.getById(match.leftParentId);
                  if (parent instanceof smodel_1.SParentElementImpl) {
                    const leftCopy = context.modelFactory.createElement(left);
                    parent.add(leftCopy);
                    animationData.fades.push({
                      element: leftCopy,
                      type: "out"
                    });
                  }
                }
              }
            }
          });
          const animations = this.createAnimations(animationData, newRoot, context);
          if (animations.length >= 2) {
            return new animation_1.CompoundAnimation(newRoot, context, animations);
          } else if (animations.length === 1) {
            return animations[0];
          } else {
            return newRoot;
          }
        }
        updateElement(left, right, animationData) {
          if ((0, model_2.isLocateable)(left) && (0, model_2.isLocateable)(right)) {
            const leftPos = left.position;
            const rightPos = right.position;
            if (!(0, geometry_1.almostEquals)(leftPos.x, rightPos.x) || !(0, geometry_1.almostEquals)(leftPos.y, rightPos.y)) {
              if (animationData.moves === void 0)
                animationData.moves = [];
              animationData.moves.push({
                element: right,
                fromPosition: leftPos,
                toPosition: rightPos
              });
              right.position = leftPos;
            }
          }
          if ((0, model_3.isSizeable)(left) && (0, model_3.isSizeable)(right)) {
            if (!geometry_1.Dimension.isValid(right.bounds)) {
              right.bounds = {
                x: right.bounds.x,
                y: right.bounds.y,
                width: left.bounds.width,
                height: left.bounds.height
              };
            } else if (!(0, geometry_1.almostEquals)(left.bounds.width, right.bounds.width) || !(0, geometry_1.almostEquals)(left.bounds.height, right.bounds.height)) {
              if (animationData.resizes === void 0)
                animationData.resizes = [];
              animationData.resizes.push({
                element: right,
                fromDimension: {
                  width: left.bounds.width,
                  height: left.bounds.height
                },
                toDimension: {
                  width: right.bounds.width,
                  height: right.bounds.height
                }
              });
            }
          }
          if (left instanceof model_6.SRoutableElementImpl && right instanceof model_6.SRoutableElementImpl && this.edgeRouterRegistry) {
            if (animationData.edgeMementi === void 0)
              animationData.edgeMementi = [];
            animationData.edgeMementi.push({
              edge: right,
              before: this.takeSnapshot(left),
              after: this.takeSnapshot(right)
            });
          }
          if ((0, model_4.isSelectable)(left) && (0, model_4.isSelectable)(right)) {
            right.selected = left.selected;
          }
          if (left instanceof smodel_1.SModelRootImpl && right instanceof smodel_1.SModelRootImpl) {
            right.canvasBounds = left.canvasBounds;
          }
          if (left instanceof viewport_root_1.ViewportRootElementImpl && right instanceof viewport_root_1.ViewportRootElementImpl) {
            right.scroll = left.scroll;
            right.zoom = left.zoom;
          }
        }
        takeSnapshot(edge) {
          const router = this.edgeRouterRegistry.get(edge.routerKind);
          return router.takeSnapshot(edge);
        }
        createAnimations(data, root, context) {
          const animations = [];
          if (data.fades.length > 0) {
            animations.push(new fade_1.FadeAnimation(root, data.fades, context, true));
          }
          if (data.moves !== void 0 && data.moves.length > 0) {
            const movesMap = /* @__PURE__ */ new Map();
            for (const move of data.moves) {
              movesMap.set(move.element.id, move);
            }
            animations.push(new move_1.MoveAnimation(root, movesMap, context, false));
          }
          if (data.resizes !== void 0 && data.resizes.length > 0) {
            const resizesMap = /* @__PURE__ */ new Map();
            for (const resize of data.resizes) {
              resizesMap.set(resize.element.id, resize);
            }
            animations.push(new resize_1.ResizeAnimation(root, resizesMap, context, false));
          }
          if (data.edgeMementi !== void 0 && data.edgeMementi.length > 0) {
            animations.push(new move_1.MorphEdgesAnimation(root, data.edgeMementi, context, false));
          }
          return animations;
        }
        undo(context) {
          return this.performUpdate(this.newRoot, this.oldRoot, context);
        }
        redo(context) {
          return this.performUpdate(this.oldRoot, this.newRoot, context);
        }
      };
      exports.UpdateModelCommand = UpdateModelCommand;
      UpdateModelCommand.KIND = actions_1.UpdateModelAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], UpdateModelCommand.prototype, "edgeRouterRegistry", void 0);
      exports.UpdateModelCommand = UpdateModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], UpdateModelCommand);
    }
  });

  // node_modules/sprotty/lib/features/viewport/viewport.js
  var require_viewport = __commonJS({
    "node_modules/sprotty/lib/features/viewport/viewport.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var SetViewportCommand_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportAnimation = exports.GetViewportCommand = exports.SetViewportCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var command_1 = require_command();
      var animation_1 = require_animation();
      var model_1 = require_model12();
      var types_1 = require_types();
      var request_command_1 = require_request_command();
      var SetViewportCommand = SetViewportCommand_1 = class SetViewportCommand extends command_1.MergeableCommand {
        constructor(action) {
          super();
          this.action = action;
          this.newViewport = action.newViewport;
        }
        execute(context) {
          const model = context.root;
          const element = model.index.getById(this.action.elementId);
          if (element && (0, model_1.isViewport)(element)) {
            this.element = element;
            this.oldViewport = {
              scroll: this.element.scroll,
              zoom: this.element.zoom
            };
            const { zoomLimits, horizontalScrollLimits, verticalScrollLimits } = this.viewerOptions;
            this.newViewport = (0, model_1.limitViewport)(this.newViewport, model.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
            return this.setViewport(element, this.oldViewport, this.newViewport, context);
          }
          return context.root;
        }
        setViewport(element, oldViewport, newViewport, context) {
          if (element && (0, model_1.isViewport)(element)) {
            if (this.action.animate) {
              return new ViewportAnimation(element, oldViewport, newViewport, context).start();
            } else {
              element.scroll = newViewport.scroll;
              element.zoom = newViewport.zoom;
            }
          }
          return context.root;
        }
        undo(context) {
          return this.setViewport(this.element, this.newViewport, this.oldViewport, context);
        }
        redo(context) {
          return this.setViewport(this.element, this.oldViewport, this.newViewport, context);
        }
        merge(command, context) {
          if (!this.action.animate && command instanceof SetViewportCommand_1 && this.element === command.element) {
            this.newViewport = command.newViewport;
            return true;
          }
          return false;
        }
      };
      exports.SetViewportCommand = SetViewportCommand;
      SetViewportCommand.KIND = actions_1.SetViewportAction.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], SetViewportCommand.prototype, "viewerOptions", void 0);
      exports.SetViewportCommand = SetViewportCommand = SetViewportCommand_1 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetViewportCommand);
      var GetViewportCommand = class GetViewportCommand extends request_command_1.ModelRequestCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        retrieveResult(context) {
          const elem = context.root;
          let viewport;
          if ((0, model_1.isViewport)(elem)) {
            viewport = { scroll: elem.scroll, zoom: elem.zoom };
          } else {
            viewport = { scroll: geometry_1.Point.ORIGIN, zoom: 1 };
          }
          return actions_1.ViewportResult.create(viewport, elem.canvasBounds, this.action.requestId);
        }
      };
      exports.GetViewportCommand = GetViewportCommand;
      GetViewportCommand.KIND = actions_1.GetViewportAction.KIND;
      exports.GetViewportCommand = GetViewportCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], GetViewportCommand);
      var ViewportAnimation = class extends animation_1.Animation {
        constructor(element, oldViewport, newViewport, context) {
          super(context);
          this.element = element;
          this.oldViewport = oldViewport;
          this.newViewport = newViewport;
          this.context = context;
          this.zoomFactor = Math.log(newViewport.zoom / oldViewport.zoom);
        }
        tween(t, context) {
          this.element.scroll = {
            x: (1 - t) * this.oldViewport.scroll.x + t * this.newViewport.scroll.x,
            y: (1 - t) * this.oldViewport.scroll.y + t * this.newViewport.scroll.y
          };
          this.element.zoom = this.oldViewport.zoom * Math.exp(t * this.zoomFactor);
          return context.root;
        }
      };
      exports.ViewportAnimation = ViewportAnimation;
    }
  });

  // node_modules/sprotty/lib/features/viewport/center-fit.js
  var require_center_fit = __commonJS({
    "node_modules/sprotty/lib/features/viewport/center-fit.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CenterKeyboardListener = exports.FitToScreenCommand = exports.CenterCommand = exports.BoundsAwareViewportCommand = void 0;
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var keyboard_1 = require_keyboard();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var key_tool_1 = require_key_tool();
      var model_1 = require_model2();
      var model_2 = require_model6();
      var viewport_1 = require_viewport();
      var model_3 = require_model12();
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var BoundsAwareViewportCommand = class BoundsAwareViewportCommand extends command_1.Command {
        constructor(animate) {
          super();
          this.animate = animate;
        }
        initialize(model) {
          if (!(0, model_3.isViewport)(model)) {
            return;
          }
          this.oldViewport = {
            scroll: model.scroll,
            zoom: model.zoom
          };
          const allBounds = [];
          this.getElementIds().forEach((id) => {
            const element = model.index.getById(id);
            if (element && (0, model_1.isBoundsAware)(element)) {
              allBounds.push(this.boundsInViewport(element, element.bounds, model));
            }
          });
          if (allBounds.length === 0) {
            model.index.all().forEach((element) => {
              if ((0, model_2.isSelectable)(element) && element.selected && (0, model_1.isBoundsAware)(element)) {
                allBounds.push(this.boundsInViewport(element, element.bounds, model));
              }
            });
          }
          if (allBounds.length === 0) {
            model.index.all().forEach((element) => {
              if ((0, model_1.isBoundsAware)(element)) {
                allBounds.push(this.boundsInViewport(element, element.bounds, model));
              }
            });
          }
          if (allBounds.length !== 0) {
            const bounds = allBounds.reduce((b0, b1) => geometry_1.Bounds.combine(b0, b1));
            if (geometry_1.Dimension.isValid(bounds)) {
              const newViewport = this.getNewViewport(bounds, model);
              if (newViewport) {
                const { zoomLimits, horizontalScrollLimits, verticalScrollLimits } = this.viewerOptions;
                this.newViewport = (0, model_3.limitViewport)(newViewport, model.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
              }
            }
          }
        }
        boundsInViewport(element, bounds, viewport) {
          if (element instanceof smodel_1.SChildElementImpl && element.parent !== viewport)
            return this.boundsInViewport(element.parent, element.parent.localToParent(bounds), viewport);
          else
            return bounds;
        }
        execute(context) {
          this.initialize(context.root);
          return this.redo(context);
        }
        undo(context) {
          const model = context.root;
          if ((0, model_3.isViewport)(model) && this.newViewport !== void 0 && !this.equal(this.newViewport, this.oldViewport)) {
            if (this.animate)
              return new viewport_1.ViewportAnimation(model, this.newViewport, this.oldViewport, context).start();
            else {
              model.scroll = this.oldViewport.scroll;
              model.zoom = this.oldViewport.zoom;
            }
          }
          return model;
        }
        redo(context) {
          const model = context.root;
          if ((0, model_3.isViewport)(model) && this.newViewport !== void 0 && !this.equal(this.newViewport, this.oldViewport)) {
            if (this.animate) {
              return new viewport_1.ViewportAnimation(model, this.oldViewport, this.newViewport, context).start();
            } else {
              model.scroll = this.newViewport.scroll;
              model.zoom = this.newViewport.zoom;
            }
          }
          return model;
        }
        equal(vp1, vp2) {
          return (0, geometry_1.almostEquals)(vp1.zoom, vp2.zoom) && (0, geometry_1.almostEquals)(vp1.scroll.x, vp2.scroll.x) && (0, geometry_1.almostEquals)(vp1.scroll.y, vp2.scroll.y);
        }
      };
      exports.BoundsAwareViewportCommand = BoundsAwareViewportCommand;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], BoundsAwareViewportCommand.prototype, "viewerOptions", void 0);
      exports.BoundsAwareViewportCommand = BoundsAwareViewportCommand = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [Boolean])
      ], BoundsAwareViewportCommand);
      var CenterCommand = class CenterCommand extends BoundsAwareViewportCommand {
        constructor(action) {
          super(action.animate);
          this.action = action;
        }
        getElementIds() {
          return this.action.elementIds;
        }
        getNewViewport(bounds, model) {
          if (!geometry_1.Dimension.isValid(model.canvasBounds)) {
            return void 0;
          }
          let zoom = 1;
          if (this.action.retainZoom && (0, model_3.isViewport)(model)) {
            zoom = model.zoom;
          } else if (this.action.zoomScale) {
            zoom = this.action.zoomScale;
          }
          const c = geometry_1.Bounds.center(bounds);
          return {
            scroll: {
              x: c.x - 0.5 * model.canvasBounds.width / zoom,
              y: c.y - 0.5 * model.canvasBounds.height / zoom
            },
            zoom
          };
        }
      };
      exports.CenterCommand = CenterCommand;
      CenterCommand.KIND = actions_1.CenterAction.KIND;
      exports.CenterCommand = CenterCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CenterCommand);
      var FitToScreenCommand = class FitToScreenCommand extends BoundsAwareViewportCommand {
        constructor(action) {
          super(action.animate);
          this.action = action;
        }
        getElementIds() {
          return this.action.elementIds;
        }
        getNewViewport(bounds, model) {
          if (!geometry_1.Dimension.isValid(model.canvasBounds)) {
            return void 0;
          }
          const c = geometry_1.Bounds.center(bounds);
          const delta = this.action.padding === void 0 ? 0 : 2 * this.action.padding;
          let zoom = Math.min(model.canvasBounds.width / (bounds.width + delta), model.canvasBounds.height / (bounds.height + delta));
          if (this.action.maxZoom !== void 0)
            zoom = Math.min(zoom, this.action.maxZoom);
          if (zoom === Infinity) {
            zoom = 1;
          }
          return {
            scroll: {
              x: c.x - 0.5 * model.canvasBounds.width / zoom,
              y: c.y - 0.5 * model.canvasBounds.height / zoom
            },
            zoom
          };
        }
      };
      exports.FitToScreenCommand = FitToScreenCommand;
      FitToScreenCommand.KIND = actions_1.FitToScreenAction.KIND;
      exports.FitToScreenCommand = FitToScreenCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], FitToScreenCommand);
      var CenterKeyboardListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyC", "ctrlCmd", "shift"))
            return [actions_1.CenterAction.create([])];
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyF", "ctrlCmd", "shift"))
            return [actions_1.FitToScreenAction.create([])];
          return [];
        }
      };
      exports.CenterKeyboardListener = CenterKeyboardListener;
    }
  });

  // node_modules/sprotty/lib/features/zorder/zorder.js
  var require_zorder = __commonJS({
    "node_modules/sprotty/lib/features/zorder/zorder.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BringToFrontCommand = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var model_1 = require_model9();
      var BringToFrontCommand = class BringToFrontCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.selected = [];
        }
        execute(context) {
          const model = context.root;
          this.action.elementIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof model_1.SRoutableElementImpl) {
              if (element.source)
                this.addToSelection(element.source);
              if (element.target)
                this.addToSelection(element.target);
            }
            if (element instanceof smodel_1.SChildElementImpl) {
              this.addToSelection(element);
            }
            this.includeConnectedEdges(element);
          });
          return this.redo(context);
        }
        includeConnectedEdges(element) {
          if (element instanceof model_1.SConnectableElementImpl) {
            element.incomingEdges.forEach((edge) => this.addToSelection(edge));
            element.outgoingEdges.forEach((edge) => this.addToSelection(edge));
          }
          if (element instanceof smodel_1.SParentElementImpl) {
            for (const child of element.children) {
              this.includeConnectedEdges(child);
            }
          }
        }
        addToSelection(element) {
          this.selected.push({
            element,
            index: element.parent.children.indexOf(element)
          });
        }
        undo(context) {
          for (let i = this.selected.length - 1; i >= 0; i--) {
            const selection = this.selected[i];
            const element = selection.element;
            element.parent.move(element, selection.index);
          }
          return context.root;
        }
        redo(context) {
          for (let i = 0; i < this.selected.length; i++) {
            this.bringToFront(this.selected[i]);
          }
          return context.root;
        }
        bringToFront(selection) {
          const element = selection.element;
          const childrenLength = element.parent.children.length;
          element.parent.move(element, childrenLength - 1);
        }
      };
      exports.BringToFrontCommand = BringToFrontCommand;
      BringToFrontCommand.KIND = actions_1.BringToFrontAction.KIND;
      exports.BringToFrontCommand = BringToFrontCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], BringToFrontCommand);
    }
  });

  // node_modules/sprotty/lib/features/bounds/di.config.js
  var require_di_config4 = __commonJS({
    "node_modules/sprotty/lib/features/bounds/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var bounds_manipulation_1 = require_bounds_manipulation();
      var hidden_bounds_updater_1 = require_hidden_bounds_updater();
      var layout_1 = require_layout();
      var command_registration_1 = require_command_registration();
      var hbox_layout_1 = require_hbox_layout();
      var vbox_layout_1 = require_vbox_layout();
      var stack_layout_1 = require_stack_layout();
      var boundsModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, bounds_manipulation_1.SetBoundsCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, bounds_manipulation_1.RequestBoundsCommand);
        bind(hidden_bounds_updater_1.HiddenBoundsUpdater).toSelf().inSingletonScope();
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(hidden_bounds_updater_1.HiddenBoundsUpdater);
        bind(types_1.TYPES.Layouter).to(layout_1.Layouter).inSingletonScope();
        bind(types_1.TYPES.LayoutRegistry).to(layout_1.LayoutRegistry).inSingletonScope();
        (0, layout_1.configureLayout)({ bind, isBound }, vbox_layout_1.VBoxLayouter.KIND, vbox_layout_1.VBoxLayouter);
        (0, layout_1.configureLayout)({ bind, isBound }, hbox_layout_1.HBoxLayouter.KIND, hbox_layout_1.HBoxLayouter);
        (0, layout_1.configureLayout)({ bind, isBound }, stack_layout_1.StackLayouter.KIND, stack_layout_1.StackLayouter);
      });
      exports.default = boundsModule;
    }
  });

  // node_modules/sprotty/lib/features/button/di.config.js
  var require_di_config5 = __commonJS({
    "node_modules/sprotty/lib/features/button/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var button_handler_1 = require_button_handler();
      var buttonModule = new inversify_1.ContainerModule((bind) => {
        bind(button_handler_1.ButtonHandlerRegistry).toSelf().inSingletonScope();
      });
      exports.default = buttonModule;
    }
  });

  // node_modules/sprotty/lib/features/command-palette/di.config.js
  var require_di_config6 = __commonJS({
    "node_modules/sprotty/lib/features/command-palette/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var action_providers_1 = require_action_providers();
      var command_palette_1 = require_command_palette();
      var commandPaletteModule = new inversify_1.ContainerModule((bind) => {
        bind(command_palette_1.CommandPalette).toSelf().inSingletonScope();
        bind(types_1.TYPES.IUIExtension).toService(command_palette_1.CommandPalette);
        bind(command_palette_1.CommandPaletteKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(command_palette_1.CommandPaletteKeyListener);
        bind(action_providers_1.CommandPaletteActionProviderRegistry).toSelf().inSingletonScope();
        bind(types_1.TYPES.ICommandPaletteActionProviderRegistry).toService(action_providers_1.CommandPaletteActionProviderRegistry);
      });
      exports.default = commandPaletteModule;
    }
  });

  // node_modules/sprotty/lib/features/context-menu/di.config.js
  var require_di_config7 = __commonJS({
    "node_modules/sprotty/lib/features/context-menu/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var menu_providers_1 = require_menu_providers();
      var mouse_listener_1 = require_mouse_listener();
      var types_1 = require_types();
      var contextMenuModule = new inversify_1.ContainerModule((bind) => {
        bind(types_1.TYPES.IContextMenuServiceProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve, reject) => {
              if (ctx.container.isBound(types_1.TYPES.IContextMenuService)) {
                resolve(ctx.container.get(types_1.TYPES.IContextMenuService));
              } else {
                reject();
              }
            });
          };
        });
        bind(mouse_listener_1.ContextMenuMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(mouse_listener_1.ContextMenuMouseListener);
        bind(types_1.TYPES.IContextMenuProviderRegistry).to(menu_providers_1.ContextMenuProviderRegistry);
      });
      exports.default = contextMenuModule;
    }
  });

  // node_modules/sprotty/lib/features/decoration/di.config.js
  var require_di_config8 = __commonJS({
    "node_modules/sprotty/lib/features/decoration/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var view_1 = require_view();
      var inversify_1 = require_inversify();
      var model_1 = require_model15();
      var views_1 = require_views3();
      var types_1 = require_types();
      var decoration_placer_1 = require_decoration_placer();
      var decorationModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, view_1.configureModelElement)({ bind, isBound }, "marker", model_1.SIssueMarker, views_1.IssueMarkerView);
        bind(decoration_placer_1.DecorationPlacer).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(decoration_placer_1.DecorationPlacer);
      });
      exports.default = decorationModule;
    }
  });

  // node_modules/sprotty/lib/features/edge-intersection/di.config.js
  var require_di_config9 = __commonJS({
    "node_modules/sprotty/lib/features/edge-intersection/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var intersection_finder_1 = require_intersection_finder();
      var edgeIntersectionModule2 = new inversify_1.ContainerModule((bind) => {
        bind(intersection_finder_1.IntersectionFinder).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRoutePostprocessor).toService(intersection_finder_1.IntersectionFinder);
      });
      exports.default = edgeIntersectionModule2;
    }
  });

  // node_modules/sprotty/lib/features/expand/di.config.js
  var require_di_config10 = __commonJS({
    "node_modules/sprotty/lib/features/expand/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var button_handler_1 = require_button_handler();
      var expand_1 = require_expand();
      var expandModule2 = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, button_handler_1.configureButtonHandler)({ bind, isBound }, expand_1.ExpandButtonHandler.TYPE, expand_1.ExpandButtonHandler);
      });
      exports.default = expandModule2;
    }
  });

  // node_modules/sprotty/lib/features/export/di.config.js
  var require_di_config11 = __commonJS({
    "node_modules/sprotty/lib/features/export/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var export_1 = require_export();
      var svg_exporter_1 = require_svg_exporter();
      var command_registration_1 = require_command_registration();
      var exportSvgModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(export_1.ExportSvgKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(export_1.ExportSvgKeyListener);
        bind(export_1.ExportSvgPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(export_1.ExportSvgPostprocessor);
        (0, command_registration_1.configureCommand)({ bind, isBound }, export_1.ExportSvgCommand);
        bind(types_1.TYPES.SvgExporter).to(svg_exporter_1.SvgExporter).inSingletonScope();
      });
      exports.default = exportSvgModule;
    }
  });

  // node_modules/sprotty/lib/features/fade/di.config.js
  var require_di_config12 = __commonJS({
    "node_modules/sprotty/lib/features/fade/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var fade_1 = require_fade();
      var fadeModule2 = new inversify_1.ContainerModule((bind) => {
        bind(fade_1.ElementFader).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(fade_1.ElementFader);
      });
      exports.default = fadeModule2;
    }
  });

  // node_modules/sprotty/lib/features/hover/popup-position-updater.js
  var require_popup_position_updater = __commonJS({
    "node_modules/sprotty/lib/features/hover/popup-position-updater.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PopupPositionUpdater = void 0;
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var PopupPositionUpdater = class PopupPositionUpdater {
        decorate(vnode, element) {
          return vnode;
        }
        postUpdate() {
          const popupDiv = document.getElementById(this.options.popupDiv);
          if (popupDiv !== null && typeof window !== "undefined") {
            const boundingClientRect = popupDiv.getBoundingClientRect();
            if (window.innerHeight < boundingClientRect.height + boundingClientRect.top) {
              popupDiv.style.top = window.pageYOffset + window.innerHeight - boundingClientRect.height - 5 + "px";
            }
            if (window.innerWidth < boundingClientRect.left + boundingClientRect.width) {
              popupDiv.style.left = window.pageXOffset + window.innerWidth - boundingClientRect.width - 5 + "px";
            }
            if (boundingClientRect.left < 0) {
              popupDiv.style.left = "0px";
            }
            if (boundingClientRect.top < 0) {
              popupDiv.style.top = "0px";
            }
          }
        }
      };
      exports.PopupPositionUpdater = PopupPositionUpdater;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], PopupPositionUpdater.prototype, "options", void 0);
      exports.PopupPositionUpdater = PopupPositionUpdater = __decorate([
        (0, inversify_1.injectable)()
      ], PopupPositionUpdater);
    }
  });

  // node_modules/sprotty/lib/features/hover/di.config.js
  var require_di_config13 = __commonJS({
    "node_modules/sprotty/lib/features/hover/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var hover_1 = require_hover();
      var popup_position_updater_1 = require_popup_position_updater();
      var command_registration_1 = require_command_registration();
      var action_handler_1 = require_action_handler();
      var center_fit_1 = require_center_fit();
      var viewport_1 = require_viewport();
      var move_1 = require_move();
      var hoverModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(popup_position_updater_1.PopupPositionUpdater).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(popup_position_updater_1.PopupPositionUpdater);
        bind(hover_1.HoverMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(hover_1.HoverMouseListener);
        bind(hover_1.PopupHoverMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupMouseListener).toService(hover_1.PopupHoverMouseListener);
        bind(hover_1.HoverKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(hover_1.HoverKeyListener);
        bind(types_1.TYPES.HoverState).toConstantValue({
          mouseOverTimer: void 0,
          mouseOutTimer: void 0,
          popupOpen: false,
          previousPopupElement: void 0
        });
        bind(hover_1.ClosePopupActionHandler).toSelf().inSingletonScope();
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, hover_1.HoverFeedbackCommand);
        (0, command_registration_1.configureCommand)(context, hover_1.SetPopupModelCommand);
        (0, action_handler_1.configureActionHandler)(context, hover_1.SetPopupModelCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, center_fit_1.FitToScreenCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, center_fit_1.CenterCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, viewport_1.SetViewportCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, move_1.MoveCommand.KIND, hover_1.ClosePopupActionHandler);
      });
      exports.default = hoverModule;
    }
  });

  // node_modules/sprotty/lib/features/move/di.config.js
  var require_di_config14 = __commonJS({
    "node_modules/sprotty/lib/features/move/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var move_1 = require_move();
      var command_registration_1 = require_command_registration();
      var moveModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(move_1.MoveMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(move_1.MoveMouseListener);
        (0, command_registration_1.configureCommand)({ bind, isBound }, move_1.MoveCommand);
        bind(move_1.LocationPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(move_1.LocationPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(move_1.LocationPostprocessor);
      });
      exports.default = moveModule;
    }
  });

  // node_modules/sprotty/lib/features/open/di.config.js
  var require_di_config15 = __commonJS({
    "node_modules/sprotty/lib/features/open/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var open_1 = require_open();
      var openModule = new inversify_1.ContainerModule((bind) => {
        bind(open_1.OpenMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(open_1.OpenMouseListener);
      });
      exports.default = openModule;
    }
  });

  // node_modules/sprotty/lib/features/routing/di.config.js
  var require_di_config16 = __commonJS({
    "node_modules/sprotty/lib/features/routing/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var manhattan_edge_router_1 = require_manhattan_edge_router();
      var polyline_edge_router_1 = require_polyline_edge_router();
      var manhattan_anchors_1 = require_manhattan_anchors();
      var polyline_anchors_1 = require_polyline_anchors();
      var anchor_1 = require_anchor();
      var routing_1 = require_routing();
      var bezier_edge_router_1 = require_bezier_edge_router();
      var bezier_anchors_1 = require_bezier_anchors();
      var command_registration_1 = require_command_registration();
      var routingModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(routing_1.EdgeRouterRegistry).toSelf().inSingletonScope();
        bind(anchor_1.AnchorComputerRegistry).toSelf().inSingletonScope();
        bind(manhattan_edge_router_1.ManhattanEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(manhattan_edge_router_1.ManhattanEdgeRouter);
        bind(manhattan_anchors_1.ManhattanEllipticAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanEllipticAnchor);
        bind(manhattan_anchors_1.ManhattanRectangularAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanRectangularAnchor);
        bind(manhattan_anchors_1.ManhattanDiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanDiamondAnchor);
        bind(polyline_edge_router_1.PolylineEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(polyline_edge_router_1.PolylineEdgeRouter);
        bind(polyline_anchors_1.EllipseAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.EllipseAnchor);
        bind(polyline_anchors_1.RectangleAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.RectangleAnchor);
        bind(polyline_anchors_1.DiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.DiamondAnchor);
        bind(bezier_edge_router_1.BezierEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(bezier_edge_router_1.BezierEdgeRouter);
        bind(bezier_anchors_1.BezierEllipseAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierEllipseAnchor);
        bind(bezier_anchors_1.BezierRectangleAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierRectangleAnchor);
        bind(bezier_anchors_1.BezierDiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierDiamondAnchor);
        (0, command_registration_1.configureCommand)({ bind, isBound }, bezier_edge_router_1.AddRemoveBezierSegmentCommand);
      });
      exports.default = routingModule;
    }
  });

  // node_modules/sprotty/lib/features/select/di.config.js
  var require_di_config17 = __commonJS({
    "node_modules/sprotty/lib/features/select/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var select_1 = require_select();
      var command_registration_1 = require_command_registration();
      var selectModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.SelectCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.SelectAllCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.GetSelectionCommand);
        bind(select_1.SelectKeyboardListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(select_1.SelectKeyboardListener);
        bind(select_1.SelectMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(select_1.SelectMouseListener);
      });
      exports.default = selectModule;
    }
  });

  // node_modules/sprotty/lib/features/undo-redo/di.config.js
  var require_di_config18 = __commonJS({
    "node_modules/sprotty/lib/features/undo-redo/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var undo_redo_1 = require_undo_redo();
      var undoRedoModule = new inversify_1.ContainerModule((bind) => {
        bind(undo_redo_1.UndoRedoKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(undo_redo_1.UndoRedoKeyListener);
      });
      exports.default = undoRedoModule;
    }
  });

  // node_modules/sprotty/lib/features/update/di.config.js
  var require_di_config19 = __commonJS({
    "node_modules/sprotty/lib/features/update/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var command_registration_1 = require_command_registration();
      var update_model_1 = require_update_model();
      var updateModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, update_model_1.UpdateModelCommand);
      });
      exports.default = updateModule;
    }
  });

  // node_modules/sprotty/lib/features/viewport/di.config.js
  var require_di_config20 = __commonJS({
    "node_modules/sprotty/lib/features/viewport/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var types_1 = require_types();
      var center_fit_1 = require_center_fit();
      var viewport_1 = require_viewport();
      var scroll_1 = require_scroll();
      var zoom_1 = require_zoom();
      var command_registration_1 = require_command_registration();
      var viewportModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, center_fit_1.CenterCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, center_fit_1.FitToScreenCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, viewport_1.SetViewportCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, viewport_1.GetViewportCommand);
        bind(center_fit_1.CenterKeyboardListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(center_fit_1.CenterKeyboardListener);
        bind(scroll_1.ScrollMouseListener).toSelf().inSingletonScope();
        bind(zoom_1.ZoomMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(scroll_1.ScrollMouseListener);
        bind(types_1.TYPES.MouseListener).toService(zoom_1.ZoomMouseListener);
      });
      exports.default = viewportModule;
    }
  });

  // node_modules/sprotty/lib/features/zorder/di.config.js
  var require_di_config21 = __commonJS({
    "node_modules/sprotty/lib/features/zorder/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var command_registration_1 = require_command_registration();
      var zorder_1 = require_zorder();
      var zorderModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, zorder_1.BringToFrontCommand);
      });
      exports.default = zorderModule;
    }
  });

  // node_modules/sprotty/lib/graph/views.js
  var require_views6 = __commonJS({
    "node_modules/sprotty/lib/graph/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SBezierControlHandleView = exports.SBezierCreateHandleView = exports.SCompartmentView = exports.SLabelView = exports.SRoutingHandleView = exports.BezierCurveEdgeView = exports.PolylineEdgeViewWithGapsOnIntersections = exports.JumpingPolylineEdgeView = exports.PolylineEdgeView = exports.SGraphView = void 0;
      var inversify_1 = require_inversify();
      var geometry_1 = require_geometry();
      var model_utils_1 = require_model_utils();
      var vnode_utils_1 = require_vnode_utils();
      var views_1 = require_views();
      var intersection_finder_1 = require_intersection_finder();
      var model_1 = require_model10();
      var model_2 = require_model9();
      var routing_1 = require_routing();
      var views_2 = require_views5();
      var jsx_1 = require_jsx();
      var geometry_2 = require_geometry2();
      var SGraphView2 = class SGraphView {
        render(model, context) {
          const edgeRouting = this.edgeRouterRegistry.routeAllChildren(model);
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          return (0, jsx_1.svg)(
            "svg",
            { "class-sprotty-graph": true },
            (0, jsx_1.svg)("g", { transform }, context.renderChildren(model, { edgeRouting }))
          );
        }
      };
      exports.SGraphView = SGraphView2;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SGraphView2.prototype, "edgeRouterRegistry", void 0);
      exports.SGraphView = SGraphView2 = __decorate([
        (0, inversify_1.injectable)()
      ], SGraphView2);
      var PolylineEdgeView2 = class PolylineEdgeView extends views_2.RoutableView {
        render(edge, context, args) {
          const route = this.edgeRouterRegistry.route(edge, args);
          if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
          }
          if (!this.isVisible(edge, route, context)) {
            if (edge.children.length === 0) {
              return void 0;
            }
            return (0, jsx_1.svg)("g", null, context.renderChildren(edge, { route }));
          }
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback },
            this.renderLine(edge, route, context, args),
            this.renderAdditionals(edge, route, context),
            context.renderChildren(edge, { route })
          );
        }
        renderLine(edge, segments, context, args) {
          const firstPoint = segments[0];
          let path = `M ${firstPoint.x},${firstPoint.y}`;
          for (let i = 1; i < segments.length; i++) {
            const p = segments[i];
            path += ` L ${p.x},${p.y}`;
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        renderAdditionals(edge, segments, context) {
          return [];
        }
        renderDanglingEdge(message, edge, context) {
          return (0, jsx_1.svg)("text", { "class-sprotty-edge-dangling": true, title: message }, "?");
        }
      };
      exports.PolylineEdgeView = PolylineEdgeView2;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], PolylineEdgeView2.prototype, "edgeRouterRegistry", void 0);
      exports.PolylineEdgeView = PolylineEdgeView2 = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeView2);
      var JumpingPolylineEdgeView = class JumpingPolylineEdgeView extends PolylineEdgeView2 {
        constructor() {
          super(...arguments);
          this.jumpOffsetBefore = 5;
          this.jumpOffsetAfter = 5;
          this.skipOffsetBefore = 3;
          this.skipOffsetAfter = 2;
        }
        renderLine(edge, segments, context, args) {
          let path = "";
          for (let i = 0; i < segments.length; i++) {
            const p = segments[i];
            if (i === 0) {
              path = `M ${p.x},${p.y}`;
            }
            if ((0, intersection_finder_1.isIntersectingRoutedPoint)(p)) {
              path += this.intersectionPath(edge, segments, p, args);
            }
            if (i !== 0) {
              path += ` L ${p.x},${p.y}`;
            }
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        /**
         * Returns a path that takes the intersections into account by drawing a line jump or a gap for intersections on that path.
         */
        intersectionPath(edge, segments, intersectingPoint, args) {
          if (intersectingPoint.intersections.length < 1) {
            return "";
          }
          const segment = this.getLineSegment(edge, intersectingPoint.intersections[0], args, segments);
          const intersections = this.getIntersectionsSortedBySegmentDirection(segment, intersectingPoint);
          let path = "";
          for (const intersection of intersections) {
            const otherLineSegment = this.getOtherLineSegment(edge, intersection, args);
            if (otherLineSegment === void 0) {
              continue;
            }
            const currentLineSegment = this.getLineSegment(edge, intersection, args, segments);
            const intersectionPoint = intersection.intersectionPoint;
            if (this.shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment)) {
              path += this.createJumpPath(intersectionPoint, currentLineSegment);
            } else if (this.shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment)) {
              path += this.createGapPath(intersectionPoint, currentLineSegment);
            }
          }
          return path;
        }
        /**
         * Returns the intersections sorted by the direction of the `lineSegment`.
         *
         * The coordinate system goes from left to right and top to bottom.
         * Thus, x increases to the right and y increases downwards.
         *
         * We need to draw the intersections in the order of the direction of the line segment.
         * To draw a line pointing north, we need to order intersections by Y in a descending order.
         * To draw a line pointing south, we need to order intersections by Y in an ascending order.
         */
        getIntersectionsSortedBySegmentDirection(lineSegment, intersectingPoint) {
          switch (lineSegment.direction) {
            case "north":
            case "north-east":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_DESCENDING_Y);
            case "south":
            case "south-east":
            case "east":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_Y);
            case "south-west":
            case "west":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_DESCENDING_X_THEN_Y);
            case "north-west":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_DESCENDING_X_THEN_DESCENDING_Y);
          }
        }
        /**
         * Whether or not to draw a line jump on an intersection for the `currentLineSegment`.
         * This should usually be inverse of `shouldDrawLineGapOnIntersection()`.
         */
        shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment) {
          return Math.abs(currentLineSegment.slopeOrMax) < Math.abs(otherLineSegment.slopeOrMax);
        }
        /**
         * Whether or not to draw a line gap on an intersection for the `currentLineSegment`.
         * This should usually be inverse of `shouldDrawLineJumpOnIntersection()`.
         */
        shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment) {
          return !this.shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment);
        }
        getLineSegment(edge, intersection, args, segments) {
          const route = segments ? segments : this.edgeRouterRegistry.route(edge, args);
          const index = intersection.routable1 === edge.id ? intersection.segmentIndex1 : intersection.segmentIndex2;
          return new geometry_2.PointToPointLine(route[index], route[index + 1]);
        }
        getOtherLineSegment(currentEdge, intersection, args) {
          const otherEdgeId = intersection.routable1 === currentEdge.id ? intersection.routable2 : intersection.routable1;
          const otherEdge = currentEdge.index.getById(otherEdgeId);
          if (!(otherEdge instanceof model_2.SRoutableElementImpl)) {
            return void 0;
          }
          return this.getLineSegment(otherEdge, intersection, args);
        }
        createJumpPath(intersectionPoint, lineSegment) {
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, this.jumpOffsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, this.jumpOffsetAfter);
          const rotation = lineSegment.p1.x < lineSegment.p2.x ? 1 : 0;
          return ` L ${anchorBefore.x},${anchorBefore.y} A 1,1 0,0 ${rotation} ${anchorAfter.x},${anchorAfter.y}`;
        }
        createGapPath(intersectionPoint, lineSegment) {
          let offsetBefore;
          let offsetAfter;
          if (intersectionPoint.y < lineSegment.p1.y) {
            offsetBefore = -this.skipOffsetBefore;
            offsetAfter = this.jumpOffsetAfter + this.skipOffsetAfter;
          } else {
            offsetBefore = this.jumpOffsetBefore + this.skipOffsetAfter;
            offsetAfter = -this.skipOffsetBefore;
          }
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, offsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, offsetAfter);
          return ` L ${anchorBefore.x},${anchorBefore.y} M ${anchorAfter.x},${anchorAfter.y}`;
        }
      };
      exports.JumpingPolylineEdgeView = JumpingPolylineEdgeView;
      exports.JumpingPolylineEdgeView = JumpingPolylineEdgeView = __decorate([
        (0, inversify_1.injectable)()
      ], JumpingPolylineEdgeView);
      var PolylineEdgeViewWithGapsOnIntersections2 = class PolylineEdgeViewWithGapsOnIntersections extends JumpingPolylineEdgeView {
        constructor() {
          super(...arguments);
          this.skipOffsetBefore = 3;
          this.skipOffsetAfter = 3;
        }
        shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment) {
          return false;
        }
        shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment) {
          return Math.abs(currentLineSegment.slopeOrMax) >= Math.abs(otherLineSegment.slopeOrMax);
        }
        createGapPath(intersectionPoint, lineSegment) {
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, this.skipOffsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, this.skipOffsetAfter);
          return ` L ${anchorBefore.x},${anchorBefore.y} M ${anchorAfter.x},${anchorAfter.y}`;
        }
      };
      exports.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections2;
      exports.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections2 = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeViewWithGapsOnIntersections2);
      var BezierCurveEdgeView = class BezierCurveEdgeView extends views_2.RoutableView {
        render(edge, context, args) {
          const route = this.edgeRouterRegistry.route(edge, args);
          if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
          }
          if (!this.isVisible(edge, route, context)) {
            if (edge.children.length === 0) {
              return void 0;
            }
            return (0, jsx_1.svg)("g", null, context.renderChildren(edge, { route }));
          }
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback },
            this.renderLine(edge, route, context, args),
            this.renderAdditionals(edge, route, context),
            context.renderChildren(edge, { route })
          );
        }
        renderLine(edge, segments, context, args) {
          let path = "";
          if (segments.length >= 4) {
            path += this.buildMainSegment(segments);
            const pointsLeft = segments.length - 4;
            if (pointsLeft > 0 && pointsLeft % 3 === 0) {
              for (let i = 4; i < segments.length; i += 3) {
                path += this.addSpline(segments, i);
              }
            }
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        buildMainSegment(segments) {
          const s = segments[0];
          const h1 = segments[1];
          const h2 = segments[2];
          const t = segments[3];
          return `M${s.x},${s.y} C${h1.x},${h1.y} ${h2.x},${h2.y} ${t.x},${t.y}`;
        }
        addSpline(segments, index) {
          const c = segments[index + 1];
          const p = segments[index + 2];
          return ` S${c.x},${c.y} ${p.x},${p.y}`;
        }
        renderAdditionals(edge, segments, context) {
          return [];
        }
        renderDanglingEdge(message, edge, context) {
          return (0, jsx_1.svg)("text", { "class-sprotty-edge-dangling": true, title: message }, "?");
        }
      };
      exports.BezierCurveEdgeView = BezierCurveEdgeView;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], BezierCurveEdgeView.prototype, "edgeRouterRegistry", void 0);
      exports.BezierCurveEdgeView = BezierCurveEdgeView = __decorate([
        (0, inversify_1.injectable)()
      ], BezierCurveEdgeView);
      var SRoutingHandleView2 = class SRoutingHandleView {
        constructor() {
          this.minimalPointDistance = 10;
        }
        render(handle, context, args) {
          if (args && args.route) {
            if (handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const theRoute = args.route === void 0 ? this.edgeRouterRegistry.route(handle.parent, args) : args.route;
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                const node = (0, jsx_1.svg)("circle", { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
        getRadius() {
          return 7;
        }
      };
      exports.SRoutingHandleView = SRoutingHandleView2;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SRoutingHandleView2.prototype, "edgeRouterRegistry", void 0);
      exports.SRoutingHandleView = SRoutingHandleView2 = __decorate([
        (0, inversify_1.injectable)()
      ], SRoutingHandleView2);
      var SLabelView2 = class SLabelView extends views_1.ShapeView {
        render(label, context) {
          if (!(0, model_1.isEdgeLayoutable)(label) && !this.isVisible(label, context)) {
            return void 0;
          }
          const vnode = (0, jsx_1.svg)("text", { "class-sprotty-label": true }, label.text);
          const subType = (0, model_utils_1.getSubType)(label);
          if (subType) {
            (0, vnode_utils_1.setAttr)(vnode, "class", subType);
          }
          return vnode;
        }
      };
      exports.SLabelView = SLabelView2;
      exports.SLabelView = SLabelView2 = __decorate([
        (0, inversify_1.injectable)()
      ], SLabelView2);
      var SCompartmentView2 = class SCompartmentView {
        render(compartment, context, args) {
          const translate = `translate(${compartment.bounds.x}, ${compartment.bounds.y})`;
          const vnode = (0, jsx_1.svg)("g", { transform: translate, "class-sprotty-comp": "{true}" }, context.renderChildren(compartment));
          const subType = (0, model_utils_1.getSubType)(compartment);
          if (subType)
            (0, vnode_utils_1.setAttr)(vnode, "class", subType);
          return vnode;
        }
      };
      exports.SCompartmentView = SCompartmentView2;
      exports.SCompartmentView = SCompartmentView2 = __decorate([
        (0, inversify_1.injectable)()
      ], SCompartmentView2);
      var SBezierCreateHandleView = class SBezierCreateHandleView extends SRoutingHandleView2 {
        render(handle, context, args) {
          if (args) {
            const theRoute = args.route;
            if (theRoute && handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                const translation = "translate(" + position.x + ", " + position.y + ")";
                const textOffsetX = -5.5;
                const textOffsetY = 5.5;
                const text = handle.kind === "bezier-add" ? "+" : "-";
                const node = (0, jsx_1.svg)(
                  "g",
                  { transform: translation, "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback },
                  (0, jsx_1.svg)("circle", { r: this.getRadius() }),
                  (0, jsx_1.svg)("text", { x: textOffsetX, y: textOffsetY, "attrs-text-align": "middle", "style-font-family": "monospace", "style-pointer-events": "none", "style-fill": "white" }, text)
                );
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.SBezierCreateHandleView = SBezierCreateHandleView;
      exports.SBezierCreateHandleView = SBezierCreateHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], SBezierCreateHandleView);
      var SBezierControlHandleView = class SBezierControlHandleView extends SRoutingHandleView2 {
        render(handle, context, args) {
          if (args) {
            const theRoute = args.route;
            if (theRoute && handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                let pathEndPos;
                for (let i = 0; i < theRoute.length; i++) {
                  const elem = theRoute[i];
                  if (elem.kind === position.kind && elem.pointIndex === position.pointIndex) {
                    if (handle.kind === "bezier-control-before") {
                      pathEndPos = theRoute[i + 1];
                    } else {
                      pathEndPos = theRoute[i - 1];
                    }
                    break;
                  }
                }
                let node;
                if (pathEndPos) {
                  const coords = `M ${position.x}, ${position.y} L ${pathEndPos.x}, ${pathEndPos.y}`;
                  node = (0, jsx_1.svg)(
                    "g",
                    { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback },
                    (0, jsx_1.svg)("path", { d: coords, stroke: "grey", "style-stroke-width": "2px" }),
                    (0, jsx_1.svg)("circle", { cx: position.x, cy: position.y, r: this.getRadius() })
                  );
                } else {
                  node = (0, jsx_1.svg)("circle", { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
                }
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.SBezierControlHandleView = SBezierControlHandleView;
      exports.SBezierControlHandleView = SBezierControlHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], SBezierControlHandleView);
    }
  });

  // node_modules/sprotty/lib/model-source/di.config.js
  var require_di_config22 = __commonJS({
    "node_modules/sprotty/lib/model-source/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_inversify();
      var command_registration_1 = require_command_registration();
      var types_1 = require_types();
      var commit_model_1 = require_commit_model();
      var model_source_1 = require_model_source();
      var modelSourceModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(types_1.TYPES.ModelSourceProvider).toProvider((context) => {
          return () => {
            return new Promise((resolve) => {
              resolve(context.container.get(types_1.TYPES.ModelSource));
            });
          };
        });
        (0, command_registration_1.configureCommand)({ bind, isBound }, commit_model_1.CommitModelCommand);
        bind(types_1.TYPES.IActionHandlerInitializer).toService(types_1.TYPES.ModelSource);
        bind(model_source_1.ComputedBoundsApplicator).toSelf().inSingletonScope();
      });
      exports.default = modelSourceModule;
    }
  });

  // node_modules/sprotty/lib/lib/modules.js
  var require_modules = __commonJS({
    "node_modules/sprotty/lib/lib/modules.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.loadDefaultModules = void 0;
      var di_config_1 = __importDefault(require_di_config());
      var di_config_2 = __importDefault(require_di_config22());
      var di_config_3 = __importDefault(require_di_config4());
      var di_config_4 = __importDefault(require_di_config5());
      var di_config_5 = __importDefault(require_di_config6());
      var di_config_6 = __importDefault(require_di_config7());
      var di_config_7 = __importDefault(require_di_config8());
      var di_config_8 = __importDefault(require_di_config2());
      var di_config_9 = require_di_config3();
      var di_config_10 = __importDefault(require_di_config10());
      var di_config_11 = __importDefault(require_di_config11());
      var di_config_12 = __importDefault(require_di_config12());
      var di_config_13 = __importDefault(require_di_config13());
      var di_config_14 = __importDefault(require_di_config14());
      var di_config_15 = __importDefault(require_di_config15());
      var di_config_16 = __importDefault(require_di_config16());
      var di_config_17 = __importDefault(require_di_config17());
      var di_config_18 = __importDefault(require_di_config18());
      var di_config_19 = __importDefault(require_di_config19());
      var di_config_20 = __importDefault(require_di_config20());
      var di_config_21 = __importDefault(require_di_config21());
      function loadDefaultModules2(container, options) {
        const modules = [
          di_config_1.default,
          di_config_2.default,
          di_config_3.default,
          di_config_4.default,
          di_config_5.default,
          di_config_6.default,
          di_config_7.default,
          di_config_9.edgeEditModule,
          di_config_8.default,
          di_config_10.default,
          di_config_11.default,
          di_config_12.default,
          di_config_13.default,
          di_config_9.labelEditModule,
          di_config_9.labelEditUiModule,
          di_config_14.default,
          di_config_15.default,
          di_config_16.default,
          di_config_17.default,
          di_config_18.default,
          di_config_19.default,
          di_config_20.default,
          di_config_21.default
        ];
        if (options && options.exclude) {
          for (const mod of options.exclude) {
            const index = modules.indexOf(mod);
            if (index >= 0)
              modules.splice(index, 1);
          }
        }
        container.load(...modules);
      }
      exports.loadDefaultModules = loadDefaultModules2;
    }
  });

  // node_modules/sprotty/lib/lib/virtualize.js
  var require_virtualize = __commonJS({
    "node_modules/sprotty/lib/lib/virtualize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var snabbdom_1 = require_snabbdom_cjs();
      function buildVNodeData(attrs) {
        const data = {};
        const addData = (memo, name) => {
          if (name !== "style" && name !== "class") {
            const val = unescapeEntities(attrs[name]);
            memo ? memo[name] = val : memo = { [name]: val };
          }
          return memo;
        };
        const _attrs = Object.keys(attrs).reduce(addData, null);
        if (_attrs) {
          data.attrs = _attrs;
        }
        const style = parseStyle(attrs);
        if (style) {
          data.style = style;
        }
        const classes = parseClass(attrs);
        if (classes) {
          data.class = classes;
        }
        return data;
      }
      function parseStyle(attrs) {
        const addStyle = (memo, styleProp) => {
          const res = styleProp.split(":");
          const name = transformName(res[0].trim());
          if (name) {
            const val = res[1].replace("!important", "").trim();
            memo ? memo[name] = val : memo = { [name]: val };
          }
          return memo;
        };
        try {
          return attrs.style.split(";").reduce(addStyle, null);
        } catch (e) {
          return null;
        }
      }
      function parseClass(attrs) {
        const addClass = (memo, className) => {
          className = className.trim();
          if (className) {
            memo ? memo[className] = true : memo = { [className]: true };
          }
          return memo;
        };
        try {
          return attrs.class.split(" ").reduce(addClass, null);
        } catch (e) {
          return null;
        }
      }
      function transformName(name) {
        name = name.replace(/-(\w)/g, function _replace($1, $2) {
          return $2.toUpperCase();
        });
        const firstChar = name.charAt(0).toLowerCase();
        return `${firstChar}${name.substring(1)}`;
      }
      var entityRegex = new RegExp("&[a-z0-9#]+;", "gi");
      var el = null;
      function unescapeEntities(text) {
        if (!el) {
          el = document.createElement("div");
        }
        return text.replace(entityRegex, (entity) => {
          if (el === null)
            return "";
          el.innerHTML = entity;
          return el.textContent === null ? "" : el.textContent;
        });
      }
      function recurse(doc, func) {
        let node = doc;
        let parent = null;
        const stack = [];
        const setChild = (n) => {
          const child = n.firstChild;
          if (child !== null) {
            parent = n;
          }
          node = child;
        };
        func(node, parent);
        setChild(node);
        while (true) {
          while (node) {
            stack.push(node);
            func(node, parent);
            setChild(node);
          }
          const _node = stack.pop();
          node = _node ? _node : null;
          if (!stack.length)
            break;
          parent = stack[stack.length - 1];
          if (node) {
            const sibling = node.nextSibling;
            if (sibling == null) {
              parent = stack[stack.length - 1];
            }
            node = sibling;
          }
        }
      }
      var vdom = null;
      var vnodeMap = /* @__PURE__ */ new Map();
      var delimited = false;
      function toVNode(node, parent) {
        let current;
        if (parent !== null) {
          current = vnodeMap.get(parent);
        }
        switch (node === null || node === void 0 ? void 0 : node.nodeType) {
          case 1: {
            if (current === void 0)
              return;
            current.children = current.children ? current.children : [];
            const children = current.children;
            const attributes = node.attributes;
            const attrs = {};
            for (let i = 0; i < attributes.length; i++) {
              const attr = attributes.item(i);
              if (attr) {
                attrs[attr.name] = attr.value;
              }
            }
            const vn = (0, snabbdom_1.h)(node.nodeName, buildVNodeData(attrs));
            children.push(vn);
            vnodeMap.set(node, vn);
            break;
          }
          case 3: {
            const text = node.textContent;
            if (text !== null && current !== void 0) {
              current.children = current.children ? current.children : [];
              const children = current.children;
              const lastData = children.length > 0 ? children[children.length - 1] : null;
              if (!delimited && typeof lastData !== "string" && lastData !== null && lastData.sel === void 0) {
                lastData.text = lastData.text + text;
              } else {
                children.push((0, snabbdom_1.vnode)(void 0, void 0, void 0, text, void 0));
              }
              delimited = false;
            }
            break;
          }
          case 8: {
            delimited = true;
            break;
          }
          case 9: {
            vdom = (0, snabbdom_1.vnode)(void 0, void 0, [], void 0, void 0);
            vnodeMap.set(node, vdom);
            break;
          }
          default:
            break;
        }
      }
      function stripVNode(vnodes) {
        const children = vnodes === null || vnodes === void 0 ? void 0 : vnodes.children;
        if (typeof children === "undefined")
          return null;
        if (children.length === 1 && typeof children[0] !== "string")
          return children[0];
        return null;
      }
      function virtualizeString(html) {
        var _a, _b;
        const parser = new window.DOMParser();
        if (parser === void 0 || html === void 0 || html === "")
          return null;
        const doc = parser.parseFromString(html, "application/xml");
        if (((_a = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _a === void 0 ? void 0 : _a.nodeName) === "parsererror") {
          const error = `${(_b = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _b === void 0 ? void 0 : _b.textContent}`;
          return (0, snabbdom_1.h)("parsererror", [error]);
        }
        delimited = false;
        vdom = null;
        recurse(doc, toVNode);
        if (vdom === null)
          return null;
        return stripVNode(vdom);
      }
      exports.default = virtualizeString;
    }
  });

  // node_modules/sprotty/lib/lib/model.js
  var require_model18 = __commonJS({
    "node_modules/sprotty/lib/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForeignObjectElement = exports.ForeignObjectElementImpl = exports.ShapedPreRenderedElement = exports.ShapedPreRenderedElementImpl = exports.PreRenderedElement = exports.PreRenderedElementImpl = exports.HtmlRoot = exports.HtmlRootImpl = exports.RectangularPort = exports.CircularPort = exports.DiamondNode = exports.RectangularNode = exports.CircularNode = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model8();
      var model_3 = require_model6();
      var sgraph_1 = require_sgraph();
      var anchor_1 = require_anchor();
      var CircularNode = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.CircularNode = CircularNode;
      var RectangularNode2 = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.RectangularNode = RectangularNode2;
      var DiamondNode = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.DIAMOND_ANCHOR_KIND;
        }
      };
      exports.DiamondNode = DiamondNode;
      var CircularPort = class extends sgraph_1.SPortImpl {
        get anchorKind() {
          return anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.CircularPort = CircularPort;
      var RectangularPort = class extends sgraph_1.SPortImpl {
        get anchorKind() {
          return anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.RectangularPort = RectangularPort;
      var HtmlRootImpl = class extends smodel_1.SModelRootImpl {
        constructor() {
          super(...arguments);
          this.classes = [];
        }
      };
      exports.HtmlRootImpl = HtmlRootImpl;
      exports.HtmlRoot = HtmlRootImpl;
      var PreRenderedElementImpl = class extends smodel_1.SChildElementImpl {
      };
      exports.PreRenderedElementImpl = PreRenderedElementImpl;
      exports.PreRenderedElement = PreRenderedElementImpl;
      var ShapedPreRenderedElementImpl = class extends PreRenderedElementImpl {
        constructor() {
          super(...arguments);
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
          this.selected = false;
          this.alignment = geometry_1.Point.ORIGIN;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
      };
      exports.ShapedPreRenderedElementImpl = ShapedPreRenderedElementImpl;
      ShapedPreRenderedElementImpl.DEFAULT_FEATURES = [model_2.moveFeature, model_1.boundsFeature, model_3.selectFeature, model_1.alignFeature];
      exports.ShapedPreRenderedElement = ShapedPreRenderedElementImpl;
      var ForeignObjectElementImpl = class extends ShapedPreRenderedElementImpl {
        get bounds() {
          if (geometry_1.Dimension.isValid(this.size)) {
            return {
              x: this.position.x,
              y: this.position.y,
              width: this.size.width,
              height: this.size.height
            };
          } else if ((0, model_1.isBoundsAware)(this.parent)) {
            return {
              x: this.position.x,
              y: this.position.y,
              width: this.parent.bounds.width,
              height: this.parent.bounds.height
            };
          }
          return geometry_1.Bounds.EMPTY;
        }
      };
      exports.ForeignObjectElementImpl = ForeignObjectElementImpl;
      exports.ForeignObjectElement = ForeignObjectElementImpl;
    }
  });

  // node_modules/sprotty/lib/lib/generic-views.js
  var require_generic_views = __commonJS({
    "node_modules/sprotty/lib/lib/generic-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForeignObjectView = exports.PreRenderedView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_inversify();
      var virtualize_1 = __importDefault(require_virtualize());
      var vnode_utils_1 = require_vnode_utils();
      var views_1 = require_views();
      var model_1 = require_model18();
      var PreRenderedView = class PreRenderedView extends views_1.ShapeView {
        render(model, context) {
          if (model instanceof model_1.ShapedPreRenderedElementImpl && !this.isVisible(model, context)) {
            return void 0;
          }
          const node = (0, virtualize_1.default)(model.code);
          if (node === null)
            return void 0;
          this.correctNamespace(node);
          return node;
        }
        correctNamespace(node) {
          if (node.sel === "svg" || node.sel === "g")
            (0, vnode_utils_1.setNamespace)(node, "http://www.w3.org/2000/svg");
        }
      };
      exports.PreRenderedView = PreRenderedView;
      exports.PreRenderedView = PreRenderedView = __decorate([
        (0, inversify_1.injectable)()
      ], PreRenderedView);
      var ForeignObjectView = class ForeignObjectView {
        render(model, context) {
          const foreignObjectContents = (0, virtualize_1.default)(model.code);
          if (foreignObjectContents === null)
            return void 0;
          const node = (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("foreignObject", { requiredFeatures: "http://www.w3.org/TR/SVG11/feature#Extensibility", height: model.bounds.height, width: model.bounds.width, x: 0, y: 0 }, foreignObjectContents),
            context.renderChildren(model)
          );
          (0, vnode_utils_1.setAttr)(node, "class", model.type);
          (0, vnode_utils_1.setNamespace)(foreignObjectContents, model.namespace);
          return node;
        }
      };
      exports.ForeignObjectView = ForeignObjectView;
      exports.ForeignObjectView = ForeignObjectView = __decorate([
        (0, inversify_1.injectable)()
      ], ForeignObjectView);
    }
  });

  // node_modules/sprotty/lib/lib/html-views.js
  var require_html_views = __commonJS({
    "node_modules/sprotty/lib/lib/html-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HtmlRootView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_inversify();
      var vnode_utils_1 = require_vnode_utils();
      var HtmlRootView = class HtmlRootView {
        render(model, context) {
          const root = (0, jsx_1.html)("div", null, context.renderChildren(model));
          for (const c of model.classes) {
            (0, vnode_utils_1.setClass)(root, c, true);
          }
          return root;
        }
      };
      exports.HtmlRootView = HtmlRootView;
      exports.HtmlRootView = HtmlRootView = __decorate([
        (0, inversify_1.injectable)()
      ], HtmlRootView);
    }
  });

  // node_modules/file-saver/dist/FileSaver.min.js
  var require_FileSaver_min = __commonJS({
    "node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
      (function(a, b) {
        if ("function" == typeof define && define.amd)
          define([], b);
        else if ("undefined" != typeof exports)
          b();
        else {
          b(), a.FileSaver = { exports: {} }.exports;
        }
      })(exports, function() {
        "use strict";
        function b(a2, b2) {
          return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
        }
        function c(a2, b2, c2) {
          var d2 = new XMLHttpRequest();
          d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
            g(d2.response, b2, c2);
          }, d2.onerror = function() {
            console.error("could not download file");
          }, d2.send();
        }
        function d(a2) {
          var b2 = new XMLHttpRequest();
          b2.open("HEAD", a2, false);
          try {
            b2.send();
          } catch (a3) {
          }
          return 200 <= b2.status && 299 >= b2.status;
        }
        function e(a2) {
          try {
            a2.dispatchEvent(new MouseEvent("click"));
          } catch (c2) {
            var b2 = document.createEvent("MouseEvents");
            b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
          }
        }
        var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
          var i = f.URL || f.webkitURL, j = document.createElement("a");
          g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
            i.revokeObjectURL(j.href);
          }, 4e4), setTimeout(function() {
            e(j);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
          if (g2 = g2 || f2.name || "download", "string" != typeof f2)
            navigator.msSaveOrOpenBlob(b(f2, h), g2);
          else if (d(f2))
            c(f2, g2, h);
          else {
            var i = document.createElement("a");
            i.href = f2, i.target = "_blank", setTimeout(function() {
              e(i);
            });
          }
        } : function(b2, d2, e2, g2) {
          if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
            return c(b2, d2, e2);
          var h = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j || h && i || a) && "undefined" != typeof FileReader) {
            var k = new FileReader();
            k.onloadend = function() {
              var a2 = k.result;
              a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
            }, k.readAsDataURL(b2);
          } else {
            var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
            g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
              l.revokeObjectURL(m);
            }, 4e4);
          }
        });
        f.saveAs = g.saveAs = g, "undefined" != typeof module && (module.exports = g);
      });
    }
  });

  // node_modules/sprotty/lib/model-source/diagram-server.js
  var require_diagram_server2 = __commonJS({
    "node_modules/sprotty/lib/model-source/diagram-server.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramServerProxy = exports.ServerStatusAction = void 0;
      var file_saver_1 = require_FileSaver_min();
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var set_model_1 = require_set_model();
      var types_1 = require_types();
      var bounds_manipulation_1 = require_bounds_manipulation();
      var svg_exporter_1 = require_svg_exporter();
      var update_model_1 = require_update_model();
      var model_source_1 = require_model_source();
      var ServerStatusAction = class {
        constructor() {
          this.kind = ServerStatusAction.KIND;
        }
      };
      exports.ServerStatusAction = ServerStatusAction;
      ServerStatusAction.KIND = "serverStatus";
      var receivedFromServerProperty = "__receivedFromServer";
      var DiagramServerProxy = class DiagramServerProxy extends model_source_1.ModelSource {
        constructor() {
          super(...arguments);
          this.currentRoot = {
            type: "NONE",
            id: "ROOT"
          };
        }
        get model() {
          return this.currentRoot;
        }
        initialize(registry) {
          super.initialize(registry);
          registry.register(actions_1.ComputedBoundsAction.KIND, this);
          registry.register(bounds_manipulation_1.RequestBoundsCommand.KIND, this);
          registry.register(actions_1.RequestPopupModelAction.KIND, this);
          registry.register(actions_1.CollapseExpandAction.KIND, this);
          registry.register(actions_1.CollapseExpandAllAction.KIND, this);
          registry.register(actions_1.OpenAction.KIND, this);
          registry.register(ServerStatusAction.KIND, this);
          if (!this.clientId) {
            this.clientId = this.viewerOptions.baseDiv;
          }
        }
        handle(action) {
          const forwardToServer = this.handleLocally(action);
          if (forwardToServer) {
            this.forwardToServer(action);
          }
        }
        forwardToServer(action) {
          const message = {
            clientId: this.clientId,
            action
          };
          this.logger.log(this, "sending", message);
          this.sendMessage(message);
        }
        /**
         * Called when a message is received from the remote diagram server.
         */
        messageReceived(data) {
          const object = typeof data === "string" ? JSON.parse(data) : data;
          if ((0, actions_1.isActionMessage)(object) && object.action) {
            if (!object.clientId || object.clientId === this.clientId) {
              object.action[receivedFromServerProperty] = true;
              this.logger.log(this, "receiving", object);
              this.actionDispatcher.dispatch(object.action).then(() => {
                this.storeNewModel(object.action);
              });
            }
          } else {
            this.logger.error(this, "received data is not an action message", object);
          }
        }
        /**
         * Check whether the given action should be handled locally. Returns true if the action should
         * still be sent to the server, and false if it's only handled locally.
         */
        handleLocally(action) {
          this.storeNewModel(action);
          switch (action.kind) {
            case actions_1.ComputedBoundsAction.KIND:
              return this.handleComputedBounds(action);
            case actions_1.RequestModelAction.KIND:
              return this.handleRequestModel(action);
            case bounds_manipulation_1.RequestBoundsCommand.KIND:
              return false;
            case svg_exporter_1.ExportSvgAction.KIND:
              return this.handleExportSvgAction(action);
            case ServerStatusAction.KIND:
              return this.handleServerStateAction(action);
          }
          return !action[receivedFromServerProperty];
        }
        /**
         * Put the new model contained in the given action into the model storage, if there is any.
         */
        storeNewModel(action) {
          if (action.kind === set_model_1.SetModelCommand.KIND || action.kind === update_model_1.UpdateModelCommand.KIND || action.kind === bounds_manipulation_1.RequestBoundsCommand.KIND) {
            const newRoot = action.newRoot;
            if (newRoot) {
              this.currentRoot = newRoot;
              if (action.kind === set_model_1.SetModelCommand.KIND || action.kind === update_model_1.UpdateModelCommand.KIND) {
                this.lastSubmittedModelType = newRoot.type;
              }
            }
          }
        }
        handleRequestModel(action) {
          const newOptions = Object.assign({ needsClientLayout: this.viewerOptions.needsClientLayout, needsServerLayout: this.viewerOptions.needsServerLayout }, action.options);
          const newAction = Object.assign(Object.assign({}, action), { options: newOptions });
          this.forwardToServer(newAction);
          return false;
        }
        /**
         * If the server requires to compute a layout, the computed bounds are forwarded. Otherwise they
         * are applied to the current model locally and a model update is triggered.
         */
        handleComputedBounds(action) {
          if (this.viewerOptions.needsServerLayout) {
            return true;
          } else {
            const root = this.currentRoot;
            this.computedBoundsApplicator.apply(root, action);
            if (root.type === this.lastSubmittedModelType) {
              this.actionDispatcher.dispatch(actions_1.UpdateModelAction.create(root));
            } else {
              this.actionDispatcher.dispatch(actions_1.SetModelAction.create(root));
            }
            this.lastSubmittedModelType = root.type;
            return false;
          }
        }
        handleExportSvgAction(action) {
          const blob = new Blob([action.svg], { type: "text/plain;charset=utf-8" });
          (0, file_saver_1.saveAs)(blob, "diagram.svg");
          return false;
        }
        handleServerStateAction(action) {
          return false;
        }
        commitModel(newRoot) {
          const previousRoot = this.currentRoot;
          this.currentRoot = newRoot;
          return previousRoot;
        }
      };
      exports.DiagramServerProxy = DiagramServerProxy;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], DiagramServerProxy.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(model_source_1.ComputedBoundsApplicator),
        __metadata("design:type", model_source_1.ComputedBoundsApplicator)
      ], DiagramServerProxy.prototype, "computedBoundsApplicator", void 0);
      exports.DiagramServerProxy = DiagramServerProxy = __decorate([
        (0, inversify_1.injectable)()
      ], DiagramServerProxy);
    }
  });

  // node_modules/sprotty/lib/model-source/local-model-source.js
  var require_local_model_source = __commonJS({
    "node_modules/sprotty/lib/model-source/local-model-source.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalModelSource = void 0;
      var file_saver_1 = require_FileSaver_min();
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var sprotty_protocol_1 = require_lib();
      var model_utils_1 = require_model_utils();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var svg_exporter_1 = require_svg_exporter();
      var model_matching_1 = require_model_matching();
      var model_source_1 = require_model_source();
      var LocalModelSource4 = class LocalModelSource extends model_source_1.ModelSource {
        constructor() {
          super(...arguments);
          this.currentRoot = smodel_factory_1.EMPTY_ROOT;
        }
        get model() {
          return this.currentRoot;
        }
        set model(root) {
          this.setModel(root);
        }
        initialize(registry) {
          super.initialize(registry);
          registry.register(actions_1.ComputedBoundsAction.KIND, this);
          registry.register(actions_1.RequestPopupModelAction.KIND, this);
        }
        /**
         * Set the model without incremental update.
         */
        setModel(newRoot) {
          this.currentRoot = newRoot;
          return this.submitModel(newRoot, false);
        }
        commitModel(newRoot) {
          const previousRoot = this.currentRoot;
          this.currentRoot = newRoot;
          return previousRoot;
        }
        /**
         * Apply an incremental update to the model with an animation showing the transition to
         * the new state. If `newRoot` is undefined, the current root is submitted; in that case
         * it is assumed that it has been modified before.
         */
        updateModel(newRoot) {
          if (newRoot === void 0) {
            return this.submitModel(this.currentRoot, true);
          } else {
            this.currentRoot = newRoot;
            return this.submitModel(newRoot, true);
          }
        }
        /**
         * Get the current selection from the model.
         */
        async getSelection() {
          const res = await this.actionDispatcher.request(sprotty_protocol_1.GetSelectionAction.create());
          const result = [];
          this.gatherSelectedElements(this.currentRoot, new Set(res.selectedElementsIDs), result);
          return result;
        }
        gatherSelectedElements(element, selected, result) {
          if (selected.has(element.id)) {
            result.push(element);
          }
          if (element.children) {
            for (const child of element.children) {
              this.gatherSelectedElements(child, selected, result);
            }
          }
        }
        /**
         * Get the current viewport from the model.
         */
        async getViewport() {
          const res = await this.actionDispatcher.request(sprotty_protocol_1.GetViewportAction.create());
          return {
            scroll: res.viewport.scroll,
            zoom: res.viewport.zoom,
            canvasBounds: res.canvasBounds
          };
        }
        /**
         * If client layout is active, run a `RequestBoundsAction` and wait for the resulting
         * `ComputedBoundsAction`, otherwise call `doSubmitModel(…)` directly.
         */
        async submitModel(newRoot, update, cause) {
          if (this.viewerOptions.needsClientLayout) {
            const computedBounds = await this.actionDispatcher.request(actions_1.RequestBoundsAction.create(newRoot));
            const index = this.computedBoundsApplicator.apply(this.currentRoot, computedBounds);
            await this.doSubmitModel(newRoot, true, cause, index);
          } else {
            await this.doSubmitModel(newRoot, update, cause);
          }
        }
        /**
         * Submit the given model with an `UpdateModelAction` or a `SetModelAction` depending on the
         * `update` argument. If available, the model layout engine is invoked first.
         */
        async doSubmitModel(newRoot, update, cause, index) {
          if (this.layoutEngine !== void 0) {
            try {
              const layoutResult = this.layoutEngine.layout(newRoot, index);
              if (layoutResult instanceof Promise)
                newRoot = await layoutResult;
              else if (layoutResult !== void 0)
                newRoot = layoutResult;
            } catch (error) {
              this.logger.error(this, error.toString(), error.stack);
            }
          }
          const lastSubmittedModelType = this.lastSubmittedModelType;
          this.lastSubmittedModelType = newRoot.type;
          if (cause && cause.kind === actions_1.RequestModelAction.KIND && cause.requestId) {
            const request = cause;
            await this.actionDispatcher.dispatch(actions_1.SetModelAction.create(newRoot, request.requestId));
          } else if (update && newRoot.type === lastSubmittedModelType) {
            const input = Array.isArray(update) ? update : newRoot;
            await this.actionDispatcher.dispatch(actions_1.UpdateModelAction.create(input, { animate: true, cause }));
          } else {
            await this.actionDispatcher.dispatch(actions_1.SetModelAction.create(newRoot));
          }
        }
        /**
         * Modify the current model with an array of matches.
         */
        applyMatches(matches) {
          const root = this.currentRoot;
          (0, model_matching_1.applyMatches)(root, matches);
          return this.submitModel(root, matches);
        }
        /**
         * Modify the current model by adding new elements.
         */
        addElements(elements) {
          const matches = [];
          for (const e of elements) {
            const anye = e;
            if (typeof anye.element === "object" && typeof anye.parentId === "string") {
              matches.push({
                right: anye.element,
                rightParentId: anye.parentId
              });
            } else if (typeof anye.id === "string") {
              matches.push({
                right: anye,
                rightParentId: this.currentRoot.id
              });
            }
          }
          return this.applyMatches(matches);
        }
        /**
         * Modify the current model by removing elements.
         */
        removeElements(elements) {
          const matches = [];
          const index = new model_utils_1.SModelIndex();
          index.add(this.currentRoot);
          for (const e of elements) {
            const anye = e;
            if (anye.elementId !== void 0 && anye.parentId !== void 0) {
              const element = index.getById(anye.elementId);
              if (element !== void 0) {
                matches.push({
                  left: element,
                  leftParentId: anye.parentId
                });
              }
            } else {
              const element = index.getById(anye);
              if (element !== void 0) {
                matches.push({
                  left: element,
                  leftParentId: this.currentRoot.id
                });
              }
            }
          }
          return this.applyMatches(matches);
        }
        // ----- Methods for handling incoming actions ----------------------------
        handle(action) {
          switch (action.kind) {
            case actions_1.RequestModelAction.KIND:
              this.handleRequestModel(action);
              break;
            case actions_1.ComputedBoundsAction.KIND:
              this.computedBoundsApplicator.apply(this.currentRoot, action);
              break;
            case actions_1.RequestPopupModelAction.KIND:
              this.handleRequestPopupModel(action);
              break;
            case svg_exporter_1.ExportSvgAction.KIND:
              this.handleExportSvgAction(action);
              break;
          }
        }
        handleRequestModel(action) {
          this.submitModel(this.currentRoot, false, action);
        }
        handleRequestPopupModel(action) {
          if (this.popupModelProvider !== void 0) {
            const element = (0, model_utils_1.findElement)(this.currentRoot, action.elementId);
            const popupRoot = this.popupModelProvider.getPopupModel(action, element);
            if (popupRoot !== void 0) {
              popupRoot.canvasBounds = action.bounds;
              this.actionDispatcher.dispatch(actions_1.SetPopupModelAction.create(popupRoot, action.requestId));
            }
          }
        }
        handleExportSvgAction(action) {
          const blob = new Blob([action.svg], { type: "text/plain;charset=utf-8" });
          (0, file_saver_1.saveAs)(blob, "diagram.svg");
        }
      };
      exports.LocalModelSource = LocalModelSource4;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], LocalModelSource4.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(model_source_1.ComputedBoundsApplicator),
        __metadata("design:type", model_source_1.ComputedBoundsApplicator)
      ], LocalModelSource4.prototype, "computedBoundsApplicator", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IPopupModelProvider),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], LocalModelSource4.prototype, "popupModelProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IModelLayoutEngine),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], LocalModelSource4.prototype, "layoutEngine", void 0);
      exports.LocalModelSource = LocalModelSource4 = __decorate([
        (0, inversify_1.injectable)()
      ], LocalModelSource4);
    }
  });

  // node_modules/sprotty/lib/model-source/logging.js
  var require_logging2 = __commonJS({
    "node_modules/sprotty/lib/model-source/logging.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForwardingLogger = void 0;
      var inversify_1 = require_inversify();
      var actions_1 = require_actions();
      var logging_1 = require_logging();
      var types_1 = require_types();
      var ForwardingLogger = class ForwardingLogger {
        error(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.error)
            this.forward(thisArg, message, logging_1.LogLevel.error, params);
        }
        warn(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.warn)
            this.forward(thisArg, message, logging_1.LogLevel.warn, params);
        }
        info(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.info)
            this.forward(thisArg, message, logging_1.LogLevel.info, params);
        }
        log(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.log) {
            try {
              const caller = typeof thisArg === "object" ? thisArg.constructor.name : String(thisArg);
              console.log.apply(thisArg, [caller + ": " + message, ...params]);
            } catch (error) {
            }
          }
        }
        forward(thisArg, message, logLevel, params) {
          const date = /* @__PURE__ */ new Date();
          const action = actions_1.LoggingAction.create({
            message,
            severity: logging_1.LogLevel[logLevel],
            time: date.toLocaleTimeString(),
            caller: typeof thisArg === "object" ? thisArg.constructor.name : String(thisArg),
            params: params.map((p) => JSON.stringify(p))
          });
          this.modelSourceProvider().then((modelSource) => {
            try {
              modelSource.handle(action);
            } catch (error) {
              try {
                console.log.apply(thisArg, [message, action, error]);
              } catch (e) {
              }
            }
          });
        }
      };
      exports.ForwardingLogger = ForwardingLogger;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ModelSourceProvider),
        __metadata("design:type", Function)
      ], ForwardingLogger.prototype, "modelSourceProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LogLevel),
        __metadata("design:type", Number)
      ], ForwardingLogger.prototype, "logLevel", void 0);
      exports.ForwardingLogger = ForwardingLogger = __decorate([
        (0, inversify_1.injectable)()
      ], ForwardingLogger);
    }
  });

  // node_modules/sprotty/lib/model-source/websocket.js
  var require_websocket = __commonJS({
    "node_modules/sprotty/lib/model-source/websocket.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WebSocketDiagramServerProxy = void 0;
      var inversify_1 = require_inversify();
      var diagram_server_1 = require_diagram_server2();
      var WebSocketDiagramServerProxy = class WebSocketDiagramServerProxy extends diagram_server_1.DiagramServerProxy {
        listen(webSocket) {
          webSocket.addEventListener("message", (event) => {
            this.messageReceived(event.data);
          });
          webSocket.addEventListener("error", (event) => {
            this.logger.error(this, "error event received", event);
          });
          this.webSocket = webSocket;
        }
        disconnect() {
          if (this.webSocket) {
            this.webSocket.close();
            this.webSocket = void 0;
          }
        }
        sendMessage(message) {
          if (this.webSocket) {
            this.webSocket.send(JSON.stringify(message));
          } else {
            throw new Error("WebSocket is not connected");
          }
        }
      };
      exports.WebSocketDiagramServerProxy = WebSocketDiagramServerProxy;
      exports.WebSocketDiagramServerProxy = WebSocketDiagramServerProxy = __decorate([
        (0, inversify_1.injectable)()
      ], WebSocketDiagramServerProxy);
    }
  });

  // node_modules/sprotty/lib/utils/color.js
  var require_color = __commonJS({
    "node_modules/sprotty/lib/utils/color.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ColorMap = exports.toSVG = exports.rgb = void 0;
      function rgb(red, green, blue) {
        return {
          red,
          green,
          blue
        };
      }
      exports.rgb = rgb;
      function toSVG(c) {
        return "rgb(" + c.red + "," + c.green + "," + c.blue + ")";
      }
      exports.toSVG = toSVG;
      var ColorMap = class {
        constructor(stops) {
          this.stops = stops;
        }
        getColor(t) {
          t = Math.max(0, Math.min(0.99999999, t));
          const i = Math.floor(t * this.stops.length);
          return this.stops[i];
        }
      };
      exports.ColorMap = ColorMap;
    }
  });

  // node_modules/sprotty/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/sprotty/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.modelSourceModule = exports.zorderModule = exports.viewportModule = exports.updateModule = exports.undoRedoModule = exports.selectModule = exports.routingModule = exports.openModule = exports.moveModule = exports.hoverModule = exports.fadeModule = exports.exportModule = exports.expandModule = exports.edgeLayoutModule = exports.edgeIntersectionModule = exports.decorationModule = exports.contextMenuModule = exports.commandPaletteModule = exports.buttonModule = exports.boundsModule = exports.defaultModule = void 0;
      __exportStar(require_action(), exports);
      __exportStar(require_action_dispatcher(), exports);
      __exportStar(require_action_handler(), exports);
      __exportStar(require_diagram_locker(), exports);
      __exportStar(require_animation_frame_syncer(), exports);
      __exportStar(require_animation(), exports);
      __exportStar(require_easing(), exports);
      __exportStar(require_command(), exports);
      __exportStar(require_command_registration(), exports);
      __exportStar(require_command_stack_options(), exports);
      __exportStar(require_command_stack(), exports);
      __exportStar(require_initialize_canvas(), exports);
      __exportStar(require_set_model(), exports);
      __exportStar(require_smodel_factory(), exports);
      __exportStar(require_smodel_utils(), exports);
      __exportStar(require_smodel(), exports);
      __exportStar(require_ui_extension_registry(), exports);
      __exportStar(require_ui_extension(), exports);
      __exportStar(require_key_tool(), exports);
      __exportStar(require_mouse_tool(), exports);
      __exportStar(require_thunk_view(), exports);
      __exportStar(require_view(), exports);
      __exportStar(require_viewer_cache(), exports);
      __exportStar(require_viewer_options(), exports);
      __exportStar(require_viewer(), exports);
      __exportStar(require_vnode_postprocessor(), exports);
      __exportStar(require_vnode_utils(), exports);
      __exportStar(require_types(), exports);
      var di_config_1 = __importDefault(require_di_config());
      exports.defaultModule = di_config_1.default;
      __exportStar(require_bounds_manipulation(), exports);
      __exportStar(require_hidden_bounds_updater(), exports);
      __exportStar(require_layout(), exports);
      __exportStar(require_model2(), exports);
      __exportStar(require_vbox_layout(), exports);
      __exportStar(require_hbox_layout(), exports);
      __exportStar(require_stack_layout(), exports);
      __exportStar(require_views(), exports);
      __exportStar(require_button_handler(), exports);
      __exportStar(require_model4(), exports);
      __exportStar(require_action_providers(), exports);
      __exportStar(require_command_palette(), exports);
      __exportStar(require_context_menu_service(), exports);
      __exportStar(require_menu_providers(), exports);
      __exportStar(require_mouse_listener(), exports);
      __exportStar(require_di_config2(), exports);
      __exportStar(require_edge_layout(), exports);
      __exportStar(require_model10(), exports);
      __exportStar(require_create(), exports);
      __exportStar(require_create_on_drag(), exports);
      __exportStar(require_di_config3(), exports);
      __exportStar(require_delete(), exports);
      __exportStar(require_edit_label(), exports);
      __exportStar(require_edit_label_ui(), exports);
      __exportStar(require_edit_routing(), exports);
      __exportStar(require_model11(), exports);
      __exportStar(require_reconnect(), exports);
      __exportStar(require_expand(), exports);
      __exportStar(require_model14(), exports);
      __exportStar(require_views2(), exports);
      __exportStar(require_export(), exports);
      __exportStar(require_model13(), exports);
      __exportStar(require_svg_exporter(), exports);
      __exportStar(require_fade(), exports);
      __exportStar(require_model3(), exports);
      __exportStar(require_hover(), exports);
      __exportStar(require_model7(), exports);
      __exportStar(require_model15(), exports);
      __exportStar(require_views3(), exports);
      __exportStar(require_decoration_placer(), exports);
      __exportStar(require_intersection_finder(), exports);
      __exportStar(require_sweepline(), exports);
      __exportStar(require_model8(), exports);
      __exportStar(require_move(), exports);
      __exportStar(require_snap(), exports);
      __exportStar(require_model5(), exports);
      __exportStar(require_open(), exports);
      __exportStar(require_model16(), exports);
      __exportStar(require_model17(), exports);
      __exportStar(require_views4(), exports);
      __exportStar(require_anchor(), exports);
      __exportStar(require_abstract_edge_router(), exports);
      __exportStar(require_bezier_anchors(), exports);
      __exportStar(require_bezier_edge_router(), exports);
      __exportStar(require_manhattan_anchors(), exports);
      __exportStar(require_manhattan_edge_router(), exports);
      __exportStar(require_model9(), exports);
      __exportStar(require_polyline_anchors(), exports);
      __exportStar(require_polyline_edge_router(), exports);
      __exportStar(require_routing(), exports);
      __exportStar(require_views5(), exports);
      __exportStar(require_model6(), exports);
      __exportStar(require_select(), exports);
      __exportStar(require_undo_redo(), exports);
      __exportStar(require_model_matching(), exports);
      __exportStar(require_update_model(), exports);
      __exportStar(require_center_fit(), exports);
      __exportStar(require_model12(), exports);
      __exportStar(require_scroll(), exports);
      __exportStar(require_viewport_root(), exports);
      __exportStar(require_viewport(), exports);
      __exportStar(require_zoom(), exports);
      __exportStar(require_zorder(), exports);
      var di_config_2 = __importDefault(require_di_config4());
      exports.boundsModule = di_config_2.default;
      var di_config_3 = __importDefault(require_di_config5());
      exports.buttonModule = di_config_3.default;
      var di_config_4 = __importDefault(require_di_config6());
      exports.commandPaletteModule = di_config_4.default;
      var di_config_5 = __importDefault(require_di_config7());
      exports.contextMenuModule = di_config_5.default;
      var di_config_6 = __importDefault(require_di_config8());
      exports.decorationModule = di_config_6.default;
      var di_config_7 = __importDefault(require_di_config9());
      exports.edgeIntersectionModule = di_config_7.default;
      var di_config_8 = __importDefault(require_di_config2());
      exports.edgeLayoutModule = di_config_8.default;
      var di_config_9 = __importDefault(require_di_config10());
      exports.expandModule = di_config_9.default;
      var di_config_10 = __importDefault(require_di_config11());
      exports.exportModule = di_config_10.default;
      var di_config_11 = __importDefault(require_di_config12());
      exports.fadeModule = di_config_11.default;
      var di_config_12 = __importDefault(require_di_config13());
      exports.hoverModule = di_config_12.default;
      var di_config_13 = __importDefault(require_di_config14());
      exports.moveModule = di_config_13.default;
      var di_config_14 = __importDefault(require_di_config15());
      exports.openModule = di_config_14.default;
      var di_config_15 = __importDefault(require_di_config16());
      exports.routingModule = di_config_15.default;
      var di_config_16 = __importDefault(require_di_config17());
      exports.selectModule = di_config_16.default;
      var di_config_17 = __importDefault(require_di_config18());
      exports.undoRedoModule = di_config_17.default;
      var di_config_18 = __importDefault(require_di_config19());
      exports.updateModule = di_config_18.default;
      var di_config_19 = __importDefault(require_di_config20());
      exports.viewportModule = di_config_19.default;
      var di_config_20 = __importDefault(require_di_config21());
      exports.zorderModule = di_config_20.default;
      __exportStar(require_sgraph(), exports);
      __exportStar(require_views6(), exports);
      __exportStar(require_modules(), exports);
      __exportStar(require_generic_views(), exports);
      __exportStar(require_html_views(), exports);
      __exportStar(require_jsx(), exports);
      __exportStar(require_model18(), exports);
      __exportStar(require_svg_views(), exports);
      __exportStar(require_commit_model(), exports);
      __exportStar(require_diagram_server2(), exports);
      __exportStar(require_local_model_source(), exports);
      __exportStar(require_logging2(), exports);
      __exportStar(require_model_source(), exports);
      __exportStar(require_websocket(), exports);
      var di_config_21 = __importDefault(require_di_config22());
      exports.modelSourceModule = di_config_21.default;
      __exportStar(require_browser(), exports);
      __exportStar(require_codicon(), exports);
      __exportStar(require_color(), exports);
      __exportStar(require_geometry2(), exports);
      __exportStar(require_inversify2(), exports);
      __exportStar(require_logging(), exports);
      __exportStar(require_registry(), exports);
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/async.js
  var require_async3 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Deferred = void 0;
      var Deferred = class {
        constructor() {
          this._state = "unresolved";
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
          this.promise.then((res) => this._state = "resolved", (rej) => this._state = "rejected");
        }
        set state(state) {
          if (this._state === "unresolved") {
            this._state = state;
          }
        }
        get state() {
          return this._state;
        }
      };
      exports.Deferred = Deferred;
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/object.js
  var require_object2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/object.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.safeAssign = exports.hasOwnProperty = exports.isObject = void 0;
      function isObject(data) {
        return typeof data === "object" && data !== null;
      }
      exports.isObject = isObject;
      function hasOwnProperty(arg, key, type) {
        if (!isObject(arg)) {
          return false;
        }
        if (Array.isArray(key)) {
          for (const k of key) {
            if (!Object.prototype.hasOwnProperty.call(arg, k)) {
              return false;
            }
            if (typeof type === "string" && typeof arg[k] !== type) {
              return false;
            } else if (typeof type === "function" && !type(arg[k])) {
              return false;
            }
          }
        } else {
          if (!Object.prototype.hasOwnProperty.call(arg, key)) {
            return false;
          }
          if (typeof type === "string") {
            return typeof arg[key] === type;
          }
          if (typeof type === "function") {
            return type(arg[key]);
          }
        }
        return true;
      }
      exports.hasOwnProperty = hasOwnProperty;
      function safeAssign(target, partial) {
        return Object.assign(target, partial);
      }
      exports.safeAssign = safeAssign;
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/geometry.js
  var require_geometry3 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/geometry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.almostEquals = exports.toRadians = exports.toDegrees = exports.Bounds = exports.isBounds = exports.Dimension = exports.centerOfLine = exports.angleBetweenPoints = exports.angleOfPoint = exports.Point = void 0;
      var object_1 = require_object2();
      var Point5;
      (function(Point6) {
        Point6.ORIGIN = Object.freeze({
          x: 0,
          y: 0
        });
        function add(p1, p2) {
          return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
          };
        }
        Point6.add = add;
        function subtract(p1, p2) {
          return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
          };
        }
        Point6.subtract = subtract;
        function equals(point1, point2) {
          return point1.x === point2.x && point1.y === point2.y;
        }
        Point6.equals = equals;
        function shiftTowards(point, refPoint, distance) {
          const diff = subtract(refPoint, point);
          const normalized = normalize(diff);
          const shift = { x: normalized.x * distance, y: normalized.y * distance };
          return add(point, shift);
        }
        Point6.shiftTowards = shiftTowards;
        function normalize(point) {
          const mag = magnitude(point);
          if (mag === 0 || mag === 1) {
            return Point6.ORIGIN;
          }
          return {
            x: point.x / mag,
            y: point.y / mag
          };
        }
        Point6.normalize = normalize;
        function magnitude(point) {
          return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }
        Point6.magnitude = magnitude;
        function linear(p0, p1, lambda) {
          return {
            x: (1 - lambda) * p0.x + lambda * p1.x,
            y: (1 - lambda) * p0.y + lambda * p1.y
          };
        }
        Point6.linear = linear;
        function euclideanDistance(a, b) {
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          return Math.sqrt(dx * dx + dy * dy);
        }
        Point6.euclideanDistance = euclideanDistance;
        function manhattanDistance(a, b) {
          return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);
        }
        Point6.manhattanDistance = manhattanDistance;
        function maxDistance(a, b) {
          return Math.max(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
        }
        Point6.maxDistance = maxDistance;
      })(Point5 || (exports.Point = Point5 = {}));
      function angleOfPoint2(p) {
        return Math.atan2(p.y, p.x);
      }
      exports.angleOfPoint = angleOfPoint2;
      function angleBetweenPoints(a, b) {
        const lengthProduct = Math.sqrt((a.x * a.x + a.y * a.y) * (b.x * b.x + b.y * b.y));
        if (isNaN(lengthProduct) || lengthProduct === 0)
          return NaN;
        const dotProduct = a.x * b.x + a.y * b.y;
        return Math.acos(dotProduct / lengthProduct);
      }
      exports.angleBetweenPoints = angleBetweenPoints;
      function centerOfLine(s, e) {
        const b = {
          x: s.x > e.x ? e.x : s.x,
          y: s.y > e.y ? e.y : s.y,
          width: Math.abs(e.x - s.x),
          height: Math.abs(e.y - s.y)
        };
        return Bounds2.center(b);
      }
      exports.centerOfLine = centerOfLine;
      var Dimension;
      (function(Dimension2) {
        Dimension2.EMPTY = Object.freeze({
          width: -1,
          height: -1
        });
        function isValid(d) {
          return d.width >= 0 && d.height >= 0;
        }
        Dimension2.isValid = isValid;
      })(Dimension || (exports.Dimension = Dimension = {}));
      function isBounds(element) {
        return (0, object_1.hasOwnProperty)(element, ["x", "y", "width", "height"]);
      }
      exports.isBounds = isBounds;
      var Bounds2;
      (function(Bounds3) {
        Bounds3.EMPTY = Object.freeze({
          x: 0,
          y: 0,
          width: -1,
          height: -1
        });
        function combine(b0, b1) {
          if (!Dimension.isValid(b0))
            return Dimension.isValid(b1) ? b1 : Bounds3.EMPTY;
          if (!Dimension.isValid(b1))
            return b0;
          const minX = Math.min(b0.x, b1.x);
          const minY = Math.min(b0.y, b1.y);
          const maxX = Math.max(b0.x + (b0.width >= 0 ? b0.width : 0), b1.x + (b1.width >= 0 ? b1.width : 0));
          const maxY = Math.max(b0.y + (b0.height >= 0 ? b0.height : 0), b1.y + (b1.height >= 0 ? b1.height : 0));
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        }
        Bounds3.combine = combine;
        function translate(b, p) {
          return {
            x: b.x + p.x,
            y: b.y + p.y,
            width: b.width,
            height: b.height
          };
        }
        Bounds3.translate = translate;
        function center(b) {
          return {
            x: b.x + (b.width >= 0 ? 0.5 * b.width : 0),
            y: b.y + (b.height >= 0 ? 0.5 * b.height : 0)
          };
        }
        Bounds3.center = center;
        function includes(b, p) {
          return p.x >= b.x && p.x <= b.x + b.width && p.y >= b.y && p.y <= b.y + b.height;
        }
        Bounds3.includes = includes;
      })(Bounds2 || (exports.Bounds = Bounds2 = {}));
      function toDegrees2(a) {
        return a * 180 / Math.PI;
      }
      exports.toDegrees = toDegrees2;
      function toRadians(a) {
        return a * Math.PI / 180;
      }
      exports.toRadians = toRadians;
      function almostEquals(a, b) {
        return Math.abs(a - b) < 1e-3;
      }
      exports.almostEquals = almostEquals;
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/json.js
  var require_json2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/json.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/model-utils.js
  var require_model_utils2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/utils/model-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SModelIndex = exports.findElement = exports.getSubType = exports.getBasicType = exports.applyBounds = exports.cloneModel = void 0;
      function cloneModel(model) {
        return JSON.parse(JSON.stringify(model));
      }
      exports.cloneModel = cloneModel;
      function applyBounds(root, action) {
        const index = new SModelIndex();
        index.add(root);
        for (const b of action.bounds) {
          const element = index.getById(b.elementId);
          if (element) {
            const bae = element;
            if (b.newPosition) {
              bae.position = { x: b.newPosition.x, y: b.newPosition.y };
            }
            if (b.newSize) {
              bae.size = { width: b.newSize.width, height: b.newSize.height };
            }
          }
        }
        if (action.alignments) {
          for (const a of action.alignments) {
            const element = index.getById(a.elementId);
            if (element) {
              const alignable = element;
              alignable.alignment = { x: a.newAlignment.x, y: a.newAlignment.y };
            }
          }
        }
      }
      exports.applyBounds = applyBounds;
      function getBasicType(element) {
        if (!element.type) {
          return "";
        }
        const colonIndex = element.type.indexOf(":");
        return colonIndex >= 0 ? element.type.substring(0, colonIndex) : element.type;
      }
      exports.getBasicType = getBasicType;
      function getSubType(schema) {
        if (!schema.type) {
          return "";
        }
        const colonIndex = schema.type.indexOf(":");
        return colonIndex >= 0 ? schema.type.substring(colonIndex + 1) : schema.type;
      }
      exports.getSubType = getSubType;
      function findElement(parent, elementId) {
        if (parent.id === elementId)
          return parent;
        if (parent.children !== void 0) {
          for (const child of parent.children) {
            const result = findElement(child, elementId);
            if (result !== void 0)
              return result;
          }
        }
        return void 0;
      }
      exports.findElement = findElement;
      var SModelIndex = class {
        constructor() {
          this.id2element = /* @__PURE__ */ new Map();
          this.id2parent = /* @__PURE__ */ new Map();
        }
        add(element) {
          if (!element.id) {
            throw new Error("Model element has no ID.");
          } else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
          }
          this.id2element.set(element.id, element);
          if (Array.isArray(element.children)) {
            for (const child of element.children) {
              this.add(child);
              this.id2parent.set(child.id, element);
            }
          }
        }
        remove(element) {
          this.id2element.delete(element.id);
          if (Array.isArray(element.children)) {
            for (const child of element.children) {
              this.id2parent.delete(child.id);
              this.remove(child);
            }
          }
        }
        contains(element) {
          return this.id2element.has(element.id);
        }
        getById(id) {
          return this.id2element.get(id);
        }
        getParent(id) {
          return this.id2parent.get(id);
        }
        getRoot(element) {
          let current = element;
          while (current) {
            const parent = this.id2parent.get(current.id);
            if (parent === void 0) {
              return current;
            }
            current = parent;
          }
          throw new Error("Element has no root");
        }
      };
      exports.SModelIndex = SModelIndex;
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/actions.js
  var require_actions2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReconnectAction = exports.ApplyLabelEditAction = exports.DeleteElementAction = exports.CreateElementAction = exports.HoverFeedbackAction = exports.MoveAction = exports.RedoAction = exports.UndoAction = exports.BringToFrontAction = exports.ViewportResult = exports.GetViewportAction = exports.SetViewportAction = exports.FitToScreenAction = exports.CenterAction = exports.LayoutAction = exports.OpenAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.SelectionResult = exports.GetSelectionAction = exports.SelectAllAction = exports.SelectAction = exports.LoggingAction = exports.ComputedBoundsAction = exports.RequestBoundsAction = exports.SetBoundsAction = exports.SetPopupModelAction = exports.RequestPopupModelAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = exports.RejectAction = exports.isResponseAction = exports.setRequestContext = exports.generateRequestId = exports.isRequestAction = exports.isAction = exports.isActionMessage = void 0;
      var object_1 = require_object2();
      function isActionMessage(object) {
        return (0, object_1.hasOwnProperty)(object, "action");
      }
      exports.isActionMessage = isActionMessage;
      function isAction(object) {
        return (0, object_1.hasOwnProperty)(object, "kind", "string");
      }
      exports.isAction = isAction;
      function isRequestAction(object) {
        return (0, object_1.hasOwnProperty)(object, "requestId", "string");
      }
      exports.isRequestAction = isRequestAction;
      var requestContext = "";
      var nextRequestId = 1;
      function generateRequestId() {
        return `${requestContext}_${nextRequestId++}`;
      }
      exports.generateRequestId = generateRequestId;
      function setRequestContext(context) {
        requestContext = context;
      }
      exports.setRequestContext = setRequestContext;
      function isResponseAction(object) {
        return (0, object_1.hasOwnProperty)(object, "responseId", "string") && object.responseId !== "";
      }
      exports.isResponseAction = isResponseAction;
      var RejectAction;
      (function(RejectAction2) {
        RejectAction2.KIND = "rejectRequest";
        function create(options) {
          return {
            kind: RejectAction2.KIND,
            message: options.message,
            detail: options.detail,
            responseId: options.requestId
          };
        }
        RejectAction2.create = create;
      })(RejectAction || (exports.RejectAction = RejectAction = {}));
      var RequestModelAction2;
      (function(RequestModelAction3) {
        RequestModelAction3.KIND = "requestModel";
        function create(options) {
          return {
            kind: RequestModelAction3.KIND,
            options,
            requestId: generateRequestId()
          };
        }
        RequestModelAction3.create = create;
      })(RequestModelAction2 || (exports.RequestModelAction = RequestModelAction2 = {}));
      var SetModelAction;
      (function(SetModelAction2) {
        SetModelAction2.KIND = "setModel";
        function create(newRoot, requestId = "") {
          return {
            kind: SetModelAction2.KIND,
            newRoot,
            responseId: requestId
          };
        }
        SetModelAction2.create = create;
      })(SetModelAction || (exports.SetModelAction = SetModelAction = {}));
      var UpdateModelAction;
      (function(UpdateModelAction2) {
        UpdateModelAction2.KIND = "updateModel";
        function create(input, options = {}) {
          if (Array.isArray(input)) {
            return {
              kind: UpdateModelAction2.KIND,
              matches: input,
              animate: options.animate,
              cause: options.cause
            };
          } else {
            return {
              kind: UpdateModelAction2.KIND,
              newRoot: input,
              animate: options.animate,
              cause: options.cause
            };
          }
        }
        UpdateModelAction2.create = create;
      })(UpdateModelAction || (exports.UpdateModelAction = UpdateModelAction = {}));
      var RequestPopupModelAction;
      (function(RequestPopupModelAction2) {
        RequestPopupModelAction2.KIND = "requestPopupModel";
        function create(options) {
          return {
            kind: RequestPopupModelAction2.KIND,
            elementId: options.elementId,
            bounds: options.bounds,
            requestId: generateRequestId()
          };
        }
        RequestPopupModelAction2.create = create;
      })(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
      var SetPopupModelAction;
      (function(SetPopupModelAction2) {
        SetPopupModelAction2.KIND = "setPopupModel";
        function create(newRoot, requestId = "") {
          return {
            kind: SetPopupModelAction2.KIND,
            newRoot,
            responseId: requestId
          };
        }
        SetPopupModelAction2.create = create;
      })(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));
      var SetBoundsAction;
      (function(SetBoundsAction2) {
        SetBoundsAction2.KIND = "setBounds";
        function create(bounds) {
          return {
            kind: SetBoundsAction2.KIND,
            bounds
          };
        }
        SetBoundsAction2.create = create;
      })(SetBoundsAction || (exports.SetBoundsAction = SetBoundsAction = {}));
      var RequestBoundsAction;
      (function(RequestBoundsAction2) {
        RequestBoundsAction2.KIND = "requestBounds";
        function create(newRoot) {
          return {
            kind: RequestBoundsAction2.KIND,
            newRoot,
            requestId: generateRequestId()
          };
        }
        RequestBoundsAction2.create = create;
      })(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
      var ComputedBoundsAction;
      (function(ComputedBoundsAction2) {
        ComputedBoundsAction2.KIND = "computedBounds";
        function create(bounds, options = {}) {
          var _a;
          return {
            kind: ComputedBoundsAction2.KIND,
            bounds,
            revision: options.revision,
            alignments: options.alignments,
            responseId: (_a = options.requestId) !== null && _a !== void 0 ? _a : ""
          };
        }
        ComputedBoundsAction2.create = create;
      })(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
      var LoggingAction;
      (function(LoggingAction2) {
        LoggingAction2.KIND = "logging";
        function create(options) {
          return Object.assign({ kind: LoggingAction2.KIND }, options);
        }
        LoggingAction2.create = create;
      })(LoggingAction || (exports.LoggingAction = LoggingAction = {}));
      var SelectAction;
      (function(SelectAction2) {
        SelectAction2.KIND = "elementSelected";
        function create(options) {
          var _a, _b;
          return {
            kind: SelectAction2.KIND,
            selectedElementsIDs: (_a = options.selectedElementsIDs) !== null && _a !== void 0 ? _a : [],
            deselectedElementsIDs: (_b = options.deselectedElementsIDs) !== null && _b !== void 0 ? _b : []
          };
        }
        SelectAction2.create = create;
      })(SelectAction || (exports.SelectAction = SelectAction = {}));
      var SelectAllAction;
      (function(SelectAllAction2) {
        SelectAllAction2.KIND = "allSelected";
        function create(options = {}) {
          var _a;
          return {
            kind: SelectAllAction2.KIND,
            select: (_a = options.select) !== null && _a !== void 0 ? _a : true
          };
        }
        SelectAllAction2.create = create;
      })(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));
      var GetSelectionAction;
      (function(GetSelectionAction2) {
        GetSelectionAction2.KIND = "getSelection";
        function create() {
          return {
            kind: GetSelectionAction2.KIND,
            requestId: generateRequestId()
          };
        }
        GetSelectionAction2.create = create;
      })(GetSelectionAction || (exports.GetSelectionAction = GetSelectionAction = {}));
      var SelectionResult;
      (function(SelectionResult2) {
        SelectionResult2.KIND = "selectionResult";
        function create(selectedElementsIDs, requestId) {
          return {
            kind: SelectionResult2.KIND,
            selectedElementsIDs,
            responseId: requestId
          };
        }
        SelectionResult2.create = create;
      })(SelectionResult || (exports.SelectionResult = SelectionResult = {}));
      var CollapseExpandAction;
      (function(CollapseExpandAction2) {
        CollapseExpandAction2.KIND = "collapseExpand";
        function create(options) {
          var _a, _b;
          return {
            kind: CollapseExpandAction2.KIND,
            expandIds: (_a = options.expandIds) !== null && _a !== void 0 ? _a : [],
            collapseIds: (_b = options.collapseIds) !== null && _b !== void 0 ? _b : []
          };
        }
        CollapseExpandAction2.create = create;
      })(CollapseExpandAction || (exports.CollapseExpandAction = CollapseExpandAction = {}));
      var CollapseExpandAllAction;
      (function(CollapseExpandAllAction2) {
        CollapseExpandAllAction2.KIND = "collapseExpandAll";
        function create(options = {}) {
          var _a;
          return {
            kind: CollapseExpandAllAction2.KIND,
            expand: (_a = options.expand) !== null && _a !== void 0 ? _a : true
          };
        }
        CollapseExpandAllAction2.create = create;
      })(CollapseExpandAllAction || (exports.CollapseExpandAllAction = CollapseExpandAllAction = {}));
      var OpenAction;
      (function(OpenAction2) {
        OpenAction2.KIND = "open";
        function create(elementId) {
          return {
            kind: OpenAction2.KIND,
            elementId
          };
        }
        OpenAction2.create = create;
      })(OpenAction || (exports.OpenAction = OpenAction = {}));
      var LayoutAction;
      (function(LayoutAction2) {
        LayoutAction2.KIND = "layout";
        function create(options = {}) {
          return {
            kind: LayoutAction2.KIND,
            layoutType: options.layoutType,
            elementIds: options.elementIds
          };
        }
        LayoutAction2.create = create;
      })(LayoutAction || (exports.LayoutAction = LayoutAction = {}));
      var CenterAction;
      (function(CenterAction2) {
        CenterAction2.KIND = "center";
        function create(elementIds, options = {}) {
          var _a, _b;
          return {
            kind: CenterAction2.KIND,
            elementIds,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
            retainZoom: (_b = options.retainZoom) !== null && _b !== void 0 ? _b : false,
            zoomScale: options.zoomScale
          };
        }
        CenterAction2.create = create;
      })(CenterAction || (exports.CenterAction = CenterAction = {}));
      var FitToScreenAction;
      (function(FitToScreenAction2) {
        FitToScreenAction2.KIND = "fit";
        function create(elementIds, options = {}) {
          var _a;
          return {
            kind: FitToScreenAction2.KIND,
            elementIds,
            padding: options.padding,
            maxZoom: options.maxZoom,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
          };
        }
        FitToScreenAction2.create = create;
      })(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));
      var SetViewportAction;
      (function(SetViewportAction2) {
        SetViewportAction2.KIND = "viewport";
        function create(elementId, newViewport, options = {}) {
          var _a;
          return {
            kind: SetViewportAction2.KIND,
            elementId,
            newViewport,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
          };
        }
        SetViewportAction2.create = create;
      })(SetViewportAction || (exports.SetViewportAction = SetViewportAction = {}));
      var GetViewportAction;
      (function(GetViewportAction2) {
        GetViewportAction2.KIND = "getViewport";
        function create() {
          return {
            kind: GetViewportAction2.KIND,
            requestId: generateRequestId()
          };
        }
        GetViewportAction2.create = create;
      })(GetViewportAction || (exports.GetViewportAction = GetViewportAction = {}));
      var ViewportResult;
      (function(ViewportResult2) {
        ViewportResult2.KIND = "viewportResult";
        function create(viewport, canvasBounds, requestId) {
          return {
            kind: ViewportResult2.KIND,
            viewport,
            canvasBounds,
            responseId: requestId
          };
        }
        ViewportResult2.create = create;
      })(ViewportResult || (exports.ViewportResult = ViewportResult = {}));
      var BringToFrontAction;
      (function(BringToFrontAction2) {
        BringToFrontAction2.KIND = "bringToFront";
        function create(elementIDs) {
          return {
            kind: BringToFrontAction2.KIND,
            elementIDs
          };
        }
        BringToFrontAction2.create = create;
      })(BringToFrontAction || (exports.BringToFrontAction = BringToFrontAction = {}));
      var UndoAction;
      (function(UndoAction2) {
        UndoAction2.KIND = "undo";
        function create() {
          return {
            kind: UndoAction2.KIND
          };
        }
        UndoAction2.create = create;
      })(UndoAction || (exports.UndoAction = UndoAction = {}));
      var RedoAction;
      (function(RedoAction2) {
        RedoAction2.KIND = "redo";
        function create() {
          return {
            kind: RedoAction2.KIND
          };
        }
        RedoAction2.create = create;
      })(RedoAction || (exports.RedoAction = RedoAction = {}));
      var MoveAction2;
      (function(MoveAction3) {
        MoveAction3.KIND = "move";
        function create(moves, options = {}) {
          var _a, _b;
          return {
            kind: MoveAction3.KIND,
            moves,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
            finished: (_b = options.finished) !== null && _b !== void 0 ? _b : false
          };
        }
        MoveAction3.create = create;
      })(MoveAction2 || (exports.MoveAction = MoveAction2 = {}));
      var HoverFeedbackAction;
      (function(HoverFeedbackAction2) {
        HoverFeedbackAction2.KIND = "hoverFeedback";
        function create(options) {
          return {
            kind: HoverFeedbackAction2.KIND,
            mouseoverElement: options.mouseoverElement,
            mouseIsOver: options.mouseIsOver
          };
        }
        HoverFeedbackAction2.create = create;
      })(HoverFeedbackAction || (exports.HoverFeedbackAction = HoverFeedbackAction = {}));
      var CreateElementAction;
      (function(CreateElementAction2) {
        CreateElementAction2.KIND = "createElement";
        function create(elementSchema, options) {
          return {
            kind: CreateElementAction2.KIND,
            elementSchema,
            containerId: options.containerId
          };
        }
        CreateElementAction2.create = create;
      })(CreateElementAction || (exports.CreateElementAction = CreateElementAction = {}));
      var DeleteElementAction;
      (function(DeleteElementAction2) {
        DeleteElementAction2.KIND = "delete";
        function create(elementIds) {
          return {
            kind: DeleteElementAction2.KIND,
            elementIds
          };
        }
        DeleteElementAction2.create = create;
      })(DeleteElementAction || (exports.DeleteElementAction = DeleteElementAction = {}));
      var ApplyLabelEditAction;
      (function(ApplyLabelEditAction2) {
        ApplyLabelEditAction2.KIND = "applyLabelEdit";
        function create(labelId, text) {
          return {
            kind: ApplyLabelEditAction2.KIND,
            labelId,
            text
          };
        }
        ApplyLabelEditAction2.create = create;
      })(ApplyLabelEditAction || (exports.ApplyLabelEditAction = ApplyLabelEditAction = {}));
      var ReconnectAction;
      (function(ReconnectAction2) {
        ReconnectAction2.KIND = "reconnect";
        function create(options) {
          return {
            kind: ReconnectAction2.KIND,
            routableId: options.routableId,
            newSourceId: options.newSourceId,
            newTargetId: options.newTargetId
          };
        }
        ReconnectAction2.create = create;
      })(ReconnectAction || (exports.ReconnectAction = ReconnectAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js
  var require_type_util = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasArrayProp = exports.hasFunctionProp = exports.hasObjectProp = exports.hasNumberProp = exports.hasBooleanProp = exports.hasStringProp = exports.toTypeGuard = exports.AnyObject = void 0;
      var AnyObject;
      (function(AnyObject2) {
        function is(object) {
          return object !== null && typeof object === "object";
        }
        AnyObject2.is = is;
      })(AnyObject || (exports.AnyObject = AnyObject = {}));
      function toTypeGuard(constructor) {
        return (element) => element instanceof constructor;
      }
      exports.toTypeGuard = toTypeGuard;
      function hasStringProp(object, propertyKey, optional2 = false) {
        const property = object[propertyKey];
        return property !== void 0 ? typeof property === "string" : optional2;
      }
      exports.hasStringProp = hasStringProp;
      function hasBooleanProp(object, propertyKey, optional2 = false) {
        const property = object[propertyKey];
        return property !== void 0 ? typeof property === "boolean" : optional2;
      }
      exports.hasBooleanProp = hasBooleanProp;
      function hasNumberProp(object, propertyKey, optional2 = false) {
        const property = object[propertyKey];
        return property !== void 0 ? typeof property === "number" : optional2;
      }
      exports.hasNumberProp = hasNumberProp;
      function hasObjectProp(object, propertyKey, optional2 = false) {
        const property = object[propertyKey];
        return property !== void 0 ? AnyObject.is(property) : optional2;
      }
      exports.hasObjectProp = hasObjectProp;
      function hasFunctionProp(object, propertyKey, optional2 = false) {
        const property = object[propertyKey];
        return property !== void 0 ? typeof property === "function" : optional2;
      }
      exports.hasFunctionProp = hasFunctionProp;
      function hasArrayProp(object, propertyKey, optional2 = false) {
        const property = object[propertyKey];
        return property !== void 0 ? Array.isArray(property) : optional2;
      }
      exports.hasArrayProp = hasArrayProp;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js
  var require_base_protocol = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompoundOperation = exports.Operation = exports.RejectAction = exports.ResponseAction = exports.RequestAction = exports.ActionMessage = exports.Action = void 0;
      var sprotty = require_actions2();
      var type_util_1 = require_type_util();
      var Action3;
      (function(Action4) {
        function is(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "kind");
        }
        Action4.is = is;
        function hasKind(object, kind) {
          return Action4.is(object) && object.kind === kind;
        }
        Action4.hasKind = hasKind;
      })(Action3 || (exports.Action = Action3 = {}));
      var ActionMessage;
      (function(ActionMessage2) {
        function is(object, typeguard) {
          const actionGuard = typeguard !== null && typeguard !== void 0 ? typeguard : Action3.is;
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "clientId") && "action" in object && actionGuard(object.action);
        }
        ActionMessage2.is = is;
      })(ActionMessage || (exports.ActionMessage = ActionMessage = {}));
      var RequestAction;
      (function(RequestAction2) {
        function is(object) {
          return Action3.is(object) && (0, type_util_1.hasStringProp)(object, "requestId");
        }
        RequestAction2.is = is;
        function hasKind(object, kind) {
          return RequestAction2.is(object) && object.kind === kind;
        }
        RequestAction2.hasKind = hasKind;
        function generateRequestId() {
          return sprotty.generateRequestId();
        }
        RequestAction2.generateRequestId = generateRequestId;
      })(RequestAction || (exports.RequestAction = RequestAction = {}));
      var ResponseAction;
      (function(ResponseAction2) {
        function is(object) {
          return Action3.is(object) && (0, type_util_1.hasStringProp)(object, "responseId");
        }
        ResponseAction2.is = is;
        function hasValidResponseId(object) {
          return ResponseAction2.is(object) && object.responseId !== "";
        }
        ResponseAction2.hasValidResponseId = hasValidResponseId;
      })(ResponseAction || (exports.ResponseAction = ResponseAction = {}));
      var RejectAction;
      (function(RejectAction2) {
        RejectAction2.KIND = "rejectRequest";
        function is(object) {
          return Action3.hasKind(object, RejectAction2.KIND) && (0, type_util_1.hasStringProp)(object, "message");
        }
        RejectAction2.is = is;
        function create(message, options = {}) {
          return Object.assign({ kind: RejectAction2.KIND, responseId: "", message }, options);
        }
        RejectAction2.create = create;
      })(RejectAction || (exports.RejectAction = RejectAction = {}));
      var Operation;
      (function(Operation2) {
        function is(object) {
          return Action3.is(object) && "isOperation" in object && object.isOperation === true;
        }
        Operation2.is = is;
        function hasKind(object, kind) {
          return Operation2.is(object) && object.kind === kind;
        }
        Operation2.hasKind = hasKind;
      })(Operation || (exports.Operation = Operation = {}));
      var CompoundOperation;
      (function(CompoundOperation2) {
        CompoundOperation2.KIND = "compound";
        function is(object) {
          return Operation.hasKind(object, CompoundOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "operationList");
        }
        CompoundOperation2.is = is;
        function create(operationList) {
          return {
            kind: CompoundOperation2.KIND,
            isOperation: true,
            operationList
          };
        }
        CompoundOperation2.create = create;
      })(CompoundOperation || (exports.CompoundOperation = CompoundOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/client-notification.js
  var require_client_notification = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/client-notification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EndProgressAction = exports.UpdateProgressAction = exports.StartProgressAction = exports.MessageAction = exports.StatusAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var StatusAction;
      (function(StatusAction2) {
        StatusAction2.KIND = "status";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, StatusAction2.KIND) && (0, type_util_1.hasStringProp)(object, "severity") && (0, type_util_1.hasStringProp)(object, "message");
        }
        StatusAction2.is = is;
        function create(message, options = {}) {
          return Object.assign({ kind: StatusAction2.KIND, severity: "INFO", message }, options);
        }
        StatusAction2.create = create;
      })(StatusAction || (exports.StatusAction = StatusAction = {}));
      var MessageAction;
      (function(MessageAction2) {
        MessageAction2.KIND = "message";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, MessageAction2.KIND) && (0, type_util_1.hasStringProp)(object, "message") && (0, type_util_1.hasStringProp)(object, "severity");
        }
        MessageAction2.is = is;
        function create(message, options = {}) {
          return Object.assign({ kind: MessageAction2.KIND, message, severity: "INFO" }, options);
        }
        MessageAction2.create = create;
      })(MessageAction || (exports.MessageAction = MessageAction = {}));
      var StartProgressAction;
      (function(StartProgressAction2) {
        StartProgressAction2.KIND = "startProgress";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, StartProgressAction2.KIND) && (0, type_util_1.hasStringProp)(object, "progressId") && (0, type_util_1.hasStringProp)(object, "title");
        }
        StartProgressAction2.is = is;
        function create(options) {
          return Object.assign({ kind: StartProgressAction2.KIND }, options);
        }
        StartProgressAction2.create = create;
      })(StartProgressAction || (exports.StartProgressAction = StartProgressAction = {}));
      var UpdateProgressAction;
      (function(UpdateProgressAction2) {
        UpdateProgressAction2.KIND = "updateProgress";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, UpdateProgressAction2.KIND) && (0, type_util_1.hasStringProp)(object, "progressId");
        }
        UpdateProgressAction2.is = is;
        function create(progressId, options = {}) {
          return Object.assign({ kind: UpdateProgressAction2.KIND, progressId }, options);
        }
        UpdateProgressAction2.create = create;
      })(UpdateProgressAction || (exports.UpdateProgressAction = UpdateProgressAction = {}));
      var EndProgressAction;
      (function(EndProgressAction2) {
        EndProgressAction2.KIND = "endProgress";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, EndProgressAction2.KIND) && (0, type_util_1.hasStringProp)(object, "progressId");
        }
        EndProgressAction2.is = is;
        function create(progressId, message) {
          return {
            kind: EndProgressAction2.KIND,
            progressId,
            message
          };
        }
        EndProgressAction2.create = create;
      })(EndProgressAction || (exports.EndProgressAction = EndProgressAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/clipboard.js
  var require_clipboard = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/clipboard.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PasteOperation = exports.CutOperation = exports.SetClipboardDataAction = exports.RequestClipboardDataAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestClipboardDataAction;
      (function(RequestClipboardDataAction2) {
        RequestClipboardDataAction2.KIND = "requestClipboardData";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestClipboardDataAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        RequestClipboardDataAction2.is = is;
        function create(editorContext, options = {}) {
          return Object.assign({ kind: RequestClipboardDataAction2.KIND, requestId: "", editorContext }, options);
        }
        RequestClipboardDataAction2.create = create;
      })(RequestClipboardDataAction || (exports.RequestClipboardDataAction = RequestClipboardDataAction = {}));
      var SetClipboardDataAction;
      (function(SetClipboardDataAction2) {
        SetClipboardDataAction2.KIND = "setClipboardData";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetClipboardDataAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "clipboardData");
        }
        SetClipboardDataAction2.is = is;
        function create(clipboardData, options = {}) {
          return Object.assign({ kind: SetClipboardDataAction2.KIND, responseId: "", clipboardData }, options);
        }
        SetClipboardDataAction2.create = create;
      })(SetClipboardDataAction || (exports.SetClipboardDataAction = SetClipboardDataAction = {}));
      var CutOperation;
      (function(CutOperation2) {
        CutOperation2.KIND = "cut";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, CutOperation2.KIND) && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        CutOperation2.is = is;
        function create(editorContext) {
          return {
            kind: CutOperation2.KIND,
            isOperation: true,
            editorContext
          };
        }
        CutOperation2.create = create;
      })(CutOperation || (exports.CutOperation = CutOperation = {}));
      var PasteOperation;
      (function(PasteOperation2) {
        PasteOperation2.KIND = "paste";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, PasteOperation2.KIND) && (0, type_util_1.hasObjectProp)(object, "clipboardData") && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        PasteOperation2.is = is;
        function create(options) {
          return Object.assign({ kind: PasteOperation2.KIND, isOperation: true }, options);
        }
        PasteOperation2.create = create;
      })(PasteOperation || (exports.PasteOperation = PasteOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/contexts.js
  var require_contexts = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/contexts.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetContextActions = exports.RequestContextActions = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestContextActions;
      (function(RequestContextActions2) {
        RequestContextActions2.KIND = "requestContextActions";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestContextActions2.KIND) && (0, type_util_1.hasStringProp)(object, "contextId") && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        RequestContextActions2.is = is;
        function create(options) {
          return Object.assign({ kind: RequestContextActions2.KIND, requestId: "" }, options);
        }
        RequestContextActions2.create = create;
      })(RequestContextActions || (exports.RequestContextActions = RequestContextActions = {}));
      var SetContextActions;
      (function(SetContextActions2) {
        SetContextActions2.KIND = "setContextActions";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetContextActions2.KIND) && (0, type_util_1.hasArrayProp)(object, "actions");
        }
        SetContextActions2.is = is;
        function create(actions, options = {}) {
          return Object.assign({ kind: SetContextActions2.KIND, responseId: "", actions }, options);
        }
        SetContextActions2.create = create;
      })(SetContextActions || (exports.SetContextActions = SetContextActions = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/edge-modification.js
  var require_edge_modification = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/edge-modification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChangeRoutingPointsOperation = exports.ReconnectEdgeOperation = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var ReconnectEdgeOperation;
      (function(ReconnectEdgeOperation2) {
        ReconnectEdgeOperation2.KIND = "reconnectEdge";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ReconnectEdgeOperation2.KIND) && (0, type_util_1.hasStringProp)(object, "edgeElementId") && (0, type_util_1.hasStringProp)(object, "sourceElementId") && (0, type_util_1.hasStringProp)(object, "targetElementId");
        }
        ReconnectEdgeOperation2.is = is;
        function create(options) {
          return Object.assign({ kind: ReconnectEdgeOperation2.KIND, isOperation: true }, options);
        }
        ReconnectEdgeOperation2.create = create;
      })(ReconnectEdgeOperation || (exports.ReconnectEdgeOperation = ReconnectEdgeOperation = {}));
      var ChangeRoutingPointsOperation;
      (function(ChangeRoutingPointsOperation2) {
        ChangeRoutingPointsOperation2.KIND = "changeRoutingPoints";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ChangeRoutingPointsOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "newRoutingPoints");
        }
        ChangeRoutingPointsOperation2.is = is;
        function create(newRoutingPoints) {
          return {
            kind: ChangeRoutingPointsOperation2.KIND,
            isOperation: true,
            newRoutingPoints
          };
        }
        ChangeRoutingPointsOperation2.create = create;
      })(ChangeRoutingPointsOperation || (exports.ChangeRoutingPointsOperation = ChangeRoutingPointsOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-creation.js
  var require_element_creation = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-creation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteElementOperation = exports.CreateEdgeOperation = exports.CreateNodeOperation = exports.CreateOperation = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var CreateOperation;
      (function(CreateOperation2) {
        function is(object) {
          return base_protocol_1.Operation.is(object) && (0, type_util_1.hasStringProp)(object, "elementTypeId");
        }
        CreateOperation2.is = is;
        function hasKind(object, kind) {
          return CreateOperation2.is(object) && object.kind === kind;
        }
        CreateOperation2.hasKind = hasKind;
      })(CreateOperation || (exports.CreateOperation = CreateOperation = {}));
      var CreateNodeOperation;
      (function(CreateNodeOperation2) {
        CreateNodeOperation2.KIND = "createNode";
        function is(object) {
          return CreateOperation.hasKind(object, CreateNodeOperation2.KIND);
        }
        CreateNodeOperation2.is = is;
        function create(elementTypeId, options = {}) {
          return Object.assign({ kind: CreateNodeOperation2.KIND, isOperation: true, elementTypeId }, options);
        }
        CreateNodeOperation2.create = create;
      })(CreateNodeOperation || (exports.CreateNodeOperation = CreateNodeOperation = {}));
      var CreateEdgeOperation2;
      (function(CreateEdgeOperation3) {
        CreateEdgeOperation3.KIND = "createEdge";
        function is(object) {
          return CreateOperation.hasKind(object, CreateEdgeOperation3.KIND) && (0, type_util_1.hasStringProp)(object, "sourceElementId") && (0, type_util_1.hasStringProp)(object, "targetElementId");
        }
        CreateEdgeOperation3.is = is;
        function create(options) {
          return Object.assign({ kind: CreateEdgeOperation3.KIND, isOperation: true }, options);
        }
        CreateEdgeOperation3.create = create;
      })(CreateEdgeOperation2 || (exports.CreateEdgeOperation = CreateEdgeOperation2 = {}));
      var DeleteElementOperation;
      (function(DeleteElementOperation2) {
        DeleteElementOperation2.KIND = "deleteElement";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, DeleteElementOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementIds");
        }
        DeleteElementOperation2.is = is;
        function create(elementIds) {
          return {
            kind: DeleteElementOperation2.KIND,
            isOperation: true,
            elementIds
          };
        }
        DeleteElementOperation2.create = create;
      })(DeleteElementOperation || (exports.DeleteElementOperation = DeleteElementOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-hover.js
  var require_element_hover = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-hover.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetPopupModelAction = exports.RequestPopupModelAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestPopupModelAction;
      (function(RequestPopupModelAction2) {
        RequestPopupModelAction2.KIND = "requestPopupModel";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestPopupModelAction2.KIND) && (0, type_util_1.hasStringProp)(object, "elementId") && (0, type_util_1.hasObjectProp)(object, "bounds");
        }
        RequestPopupModelAction2.is = is;
        function create(options) {
          return Object.assign({ kind: RequestPopupModelAction2.KIND, requestId: "" }, options);
        }
        RequestPopupModelAction2.create = create;
      })(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
      var SetPopupModelAction;
      (function(SetPopupModelAction2) {
        SetPopupModelAction2.KIND = "setPopupModel";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetPopupModelAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "newRoot");
        }
        SetPopupModelAction2.is = is;
        function create(newRoot, options = {}) {
          return Object.assign({ kind: SetPopupModelAction2.KIND, responseId: "", newRoot }, options);
        }
        SetPopupModelAction2.create = create;
      })(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-navigation.js
  var require_element_navigation = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-navigation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NavigateToExternalTargetAction = exports.SetResolvedNavigationTargetAction = exports.ResolveNavigationTargetAction = exports.NavigateToTargetAction = exports.SetNavigationTargetsAction = exports.RequestNavigationTargetsAction = exports.NavigationTarget = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var NavigationTarget;
      (function(NavigationTarget2) {
        function is(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "uri");
        }
        NavigationTarget2.is = is;
        NavigationTarget2.ELEMENT_IDS = "elementIds";
        NavigationTarget2.ELEMENT_IDS_SEPARATOR = "&";
        NavigationTarget2.TEXT_LINE = "line";
        NavigationTarget2.TEXT_COLUMN = "column";
        function hasArguments(target) {
          return target.args !== void 0 && Object.keys(target.args).length > 0;
        }
        NavigationTarget2.hasArguments = hasArguments;
        function addArgument(target, key, value) {
          if (!target.args) {
            target.args = {};
          }
          target.args[key] = value;
        }
        NavigationTarget2.addArgument = addArgument;
        function getElementIds(target) {
          var _a;
          if (!((_a = target === null || target === void 0 ? void 0 : target.args) === null || _a === void 0 ? void 0 : _a[NavigationTarget2.ELEMENT_IDS])) {
            return [];
          }
          const elementIdsValue = target.args[NavigationTarget2.ELEMENT_IDS].toString();
          return elementIdsValue.split(NavigationTarget2.ELEMENT_IDS_SEPARATOR);
        }
        NavigationTarget2.getElementIds = getElementIds;
        function setElementIds(target, ...elementIds) {
          if (target.args === void 0) {
            target.args = {};
          }
          return target.args[NavigationTarget2.ELEMENT_IDS] = elementIds.join(NavigationTarget2.ELEMENT_IDS_SEPARATOR);
        }
        NavigationTarget2.setElementIds = setElementIds;
        function setTextPosition(target, position) {
          if (position) {
            if (target.args === void 0) {
              target.args = {};
            }
            target.args[NavigationTarget2.TEXT_LINE] = position.line;
            target.args[NavigationTarget2.TEXT_COLUMN] = position.character;
          }
        }
        NavigationTarget2.setTextPosition = setTextPosition;
        function getTextPosition(target) {
          if (!target.args || !target.args[NavigationTarget2.TEXT_LINE] || !target.args[NavigationTarget2.TEXT_COLUMN]) {
            return void 0;
          }
          return {
            line: Number(target.args[NavigationTarget2.TEXT_LINE]),
            character: Number(target.args[NavigationTarget2.TEXT_COLUMN])
          };
        }
        NavigationTarget2.getTextPosition = getTextPosition;
      })(NavigationTarget || (exports.NavigationTarget = NavigationTarget = {}));
      var RequestNavigationTargetsAction;
      (function(RequestNavigationTargetsAction2) {
        RequestNavigationTargetsAction2.KIND = "requestNavigationTargets";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestNavigationTargetsAction2.KIND) && (0, type_util_1.hasStringProp)(object, "targetTypeId") && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        RequestNavigationTargetsAction2.is = is;
        function create(options) {
          return Object.assign({ kind: RequestNavigationTargetsAction2.KIND, requestId: "" }, options);
        }
        RequestNavigationTargetsAction2.create = create;
      })(RequestNavigationTargetsAction || (exports.RequestNavigationTargetsAction = RequestNavigationTargetsAction = {}));
      var SetNavigationTargetsAction;
      (function(SetNavigationTargetsAction2) {
        SetNavigationTargetsAction2.KIND = "setNavigationTargets";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetNavigationTargetsAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "targets");
        }
        SetNavigationTargetsAction2.is = is;
        function create(targets, options = {}) {
          return Object.assign({ kind: SetNavigationTargetsAction2.KIND, responseId: "", targets }, options);
        }
        SetNavigationTargetsAction2.create = create;
      })(SetNavigationTargetsAction || (exports.SetNavigationTargetsAction = SetNavigationTargetsAction = {}));
      var NavigateToTargetAction;
      (function(NavigateToTargetAction2) {
        NavigateToTargetAction2.KIND = "navigateToTarget";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, NavigateToTargetAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "target");
        }
        NavigateToTargetAction2.is = is;
        function create(target) {
          return {
            kind: NavigateToTargetAction2.KIND,
            target
          };
        }
        NavigateToTargetAction2.create = create;
      })(NavigateToTargetAction || (exports.NavigateToTargetAction = NavigateToTargetAction = {}));
      var ResolveNavigationTargetAction;
      (function(ResolveNavigationTargetAction2) {
        ResolveNavigationTargetAction2.KIND = "resolveNavigationTarget";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, ResolveNavigationTargetAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "navigationTarget");
        }
        ResolveNavigationTargetAction2.is = is;
        function create(navigationTarget, options = {}) {
          return Object.assign({ kind: ResolveNavigationTargetAction2.KIND, requestId: "", navigationTarget }, options);
        }
        ResolveNavigationTargetAction2.create = create;
      })(ResolveNavigationTargetAction || (exports.ResolveNavigationTargetAction = ResolveNavigationTargetAction = {}));
      var SetResolvedNavigationTargetAction;
      (function(SetResolvedNavigationTargetAction2) {
        SetResolvedNavigationTargetAction2.KIND = "setResolvedNavigationTarget";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetResolvedNavigationTargetAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementIds");
        }
        SetResolvedNavigationTargetAction2.is = is;
        function create(elementIds, options = {}) {
          return Object.assign({ kind: SetResolvedNavigationTargetAction2.KIND, responseId: "", elementIds }, options);
        }
        SetResolvedNavigationTargetAction2.create = create;
      })(SetResolvedNavigationTargetAction || (exports.SetResolvedNavigationTargetAction = SetResolvedNavigationTargetAction = {}));
      var NavigateToExternalTargetAction;
      (function(NavigateToExternalTargetAction2) {
        NavigateToExternalTargetAction2.KIND = "navigateToExternalTarget";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, NavigateToExternalTargetAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "target");
        }
        NavigateToExternalTargetAction2.is = is;
        function create(target) {
          return {
            kind: NavigateToExternalTargetAction2.KIND,
            target
          };
        }
        NavigateToExternalTargetAction2.create = create;
      })(NavigateToExternalTargetAction || (exports.NavigateToExternalTargetAction = NavigateToExternalTargetAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js
  var require_array_util = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isArrayMatching = exports.isStringArray = exports.isArrayOfPrimitive = exports.isArrayOfClass = exports.isArrayOfType = exports.distinctAdd = exports.asArray = exports.flatPush = exports.remove = exports.pluck = exports.last = exports.first = void 0;
      function first(array, n) {
        if (n) {
          return array.filter((_, index) => index < n);
        }
        return array[0];
      }
      exports.first = first;
      function last(array, n) {
        if (n) {
          return array.filter((_, index) => array.length - index <= n);
        }
        return array[array.length - 1];
      }
      exports.last = last;
      function pluck(array, key) {
        return array.map((element) => element[key]);
      }
      exports.pluck = pluck;
      function remove(array, ...values) {
        values.forEach((value) => {
          const index = array.indexOf(value);
          if (index >= 0) {
            array.splice(index, 1);
          }
        });
      }
      exports.remove = remove;
      function flatPush(array, toPush) {
        toPush.forEach((value) => Array.isArray(value) ? array.push(...value) : array.push(value));
      }
      exports.flatPush = flatPush;
      function asArray(maybe) {
        if (Array.isArray(maybe)) {
          return maybe;
        }
        return [maybe];
      }
      exports.asArray = asArray;
      function distinctAdd(array, ...values) {
        values.forEach((value) => {
          if (!array.includes(value)) {
            array.push(value);
          }
        });
      }
      exports.distinctAdd = distinctAdd;
      function isArrayOfType(object, typeGuard, supportEmpty = false) {
        return isArrayMatching(object, (element) => typeGuard(element), supportEmpty);
      }
      exports.isArrayOfType = isArrayOfType;
      function isArrayOfClass(object, constructor, supportEmpty = false) {
        return isArrayMatching(object, (element) => element instanceof constructor, supportEmpty);
      }
      exports.isArrayOfClass = isArrayOfClass;
      function isArrayOfPrimitive(object, primitiveType, supportEmpty = false) {
        return isArrayMatching(object, (element) => typeof element === primitiveType, supportEmpty);
      }
      exports.isArrayOfPrimitive = isArrayOfPrimitive;
      function isStringArray(object, supportEmpty = false) {
        return isArrayOfPrimitive(object, "string", supportEmpty);
      }
      exports.isStringArray = isStringArray;
      function isArrayMatching(object, predicate, supportEmpty = false) {
        return Array.isArray(object) && object.every(predicate) && (supportEmpty || object.length > 0);
      }
      exports.isArrayMatching = isArrayMatching;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-selection.js
  var require_element_selection = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-selection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectAllAction = exports.SelectAction = void 0;
      var array_util_1 = require_array_util();
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var SelectAction;
      (function(SelectAction2) {
        SelectAction2.KIND = "elementSelected";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SelectAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "selectedElementsIDs") && (0, type_util_1.hasArrayProp)(object, "deselectedElementsIDs");
        }
        SelectAction2.is = is;
        function create(options = {}) {
          var _a, _b;
          const deselectedElementsIDs = (_a = options.deselectedElementsIDs) !== null && _a !== void 0 ? _a : [];
          return {
            kind: SelectAction2.KIND,
            selectedElementsIDs: (_b = options.selectedElementsIDs) !== null && _b !== void 0 ? _b : [],
            deselectedElementsIDs: (0, array_util_1.isStringArray)(deselectedElementsIDs, true) ? deselectedElementsIDs : [],
            deselectAll: typeof deselectedElementsIDs === "boolean" ? deselectedElementsIDs : false
          };
        }
        SelectAction2.create = create;
        function addSelection(selectedElementsIDs) {
          return create({ selectedElementsIDs });
        }
        SelectAction2.addSelection = addSelection;
        function removeSelection(deselectedElementsIDs) {
          return create({ deselectedElementsIDs });
        }
        SelectAction2.removeSelection = removeSelection;
        function setSelection(selectedElementsIDs) {
          return create({ selectedElementsIDs, deselectedElementsIDs: true });
        }
        SelectAction2.setSelection = setSelection;
      })(SelectAction || (exports.SelectAction = SelectAction = {}));
      var SelectAllAction;
      (function(SelectAllAction2) {
        SelectAllAction2.KIND = "allSelected";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SelectAllAction2.KIND) && (0, type_util_1.hasBooleanProp)(object, "select");
        }
        SelectAllAction2.is = is;
        function create(select = true) {
          return {
            kind: SelectAllAction2.KIND,
            select
          };
        }
        SelectAllAction2.create = create;
      })(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-text-editing.js
  var require_element_text_editing = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-text-editing.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValidationStatus = exports.ApplyLabelEditOperation = exports.SetEditValidationResultAction = exports.RequestEditValidationAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestEditValidationAction;
      (function(RequestEditValidationAction2) {
        RequestEditValidationAction2.KIND = "requestEditValidation";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestEditValidationAction2.KIND) && (0, type_util_1.hasStringProp)(object, "contextId") && (0, type_util_1.hasStringProp)(object, "modelElementId") && (0, type_util_1.hasStringProp)(object, "text");
        }
        RequestEditValidationAction2.is = is;
        function create(options) {
          return Object.assign({ kind: RequestEditValidationAction2.KIND, requestId: "" }, options);
        }
        RequestEditValidationAction2.create = create;
      })(RequestEditValidationAction || (exports.RequestEditValidationAction = RequestEditValidationAction = {}));
      var SetEditValidationResultAction;
      (function(SetEditValidationResultAction2) {
        SetEditValidationResultAction2.KIND = "setEditValidationResult";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetEditValidationResultAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "status");
        }
        SetEditValidationResultAction2.is = is;
        function create(status, options = {}) {
          return Object.assign({ kind: SetEditValidationResultAction2.KIND, responseId: "", status }, options);
        }
        SetEditValidationResultAction2.create = create;
      })(SetEditValidationResultAction || (exports.SetEditValidationResultAction = SetEditValidationResultAction = {}));
      var ApplyLabelEditOperation;
      (function(ApplyLabelEditOperation2) {
        ApplyLabelEditOperation2.KIND = "applyLabelEdit";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ApplyLabelEditOperation2.KIND) && (0, type_util_1.hasStringProp)(object, "labelId") && (0, type_util_1.hasStringProp)(object, "text");
        }
        ApplyLabelEditOperation2.is = is;
        function create(options) {
          return Object.assign({ kind: ApplyLabelEditOperation2.KIND, isOperation: true }, options);
        }
        ApplyLabelEditOperation2.create = create;
      })(ApplyLabelEditOperation || (exports.ApplyLabelEditOperation = ApplyLabelEditOperation = {}));
      var ValidationStatus;
      (function(ValidationStatus2) {
        let Severity;
        (function(Severity2) {
          Severity2[Severity2["FATAL"] = 0] = "FATAL";
          Severity2[Severity2["ERROR"] = 1] = "ERROR";
          Severity2[Severity2["WARNING"] = 2] = "WARNING";
          Severity2[Severity2["INFO"] = 3] = "INFO";
          Severity2[Severity2["OK"] = 4] = "OK";
          Severity2[Severity2["NONE"] = 5] = "NONE";
        })(Severity = ValidationStatus2.Severity || (ValidationStatus2.Severity = {}));
        ValidationStatus2.NONE = {
          severity: Severity.NONE,
          message: "",
          error: { code: -1, message: "", data: {} }
        };
        function isOk(validationStatus) {
          return validationStatus.severity === Severity.OK || validationStatus.severity === Severity.INFO || validationStatus.severity === Severity.NONE;
        }
        ValidationStatus2.isOk = isOk;
        function isWarning(validationStatus) {
          return validationStatus.severity === Severity.WARNING;
        }
        ValidationStatus2.isWarning = isWarning;
        function isError(validationStatus) {
          return validationStatus.severity === Severity.ERROR || validationStatus.severity === Severity.FATAL;
        }
        ValidationStatus2.isError = isError;
      })(ValidationStatus || (exports.ValidationStatus = ValidationStatus = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-type-hints.js
  var require_element_type_hints = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-type-hints.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CheckEdgeResultAction = exports.RequestCheckEdgeAction = exports.SetTypeHintsAction = exports.RequestTypeHintsAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestTypeHintsAction;
      (function(RequestTypeHintsAction2) {
        RequestTypeHintsAction2.KIND = "requestTypeHints";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestTypeHintsAction2.KIND);
        }
        RequestTypeHintsAction2.is = is;
        function create(options = {}) {
          return Object.assign({ kind: RequestTypeHintsAction2.KIND, requestId: "" }, options);
        }
        RequestTypeHintsAction2.create = create;
      })(RequestTypeHintsAction || (exports.RequestTypeHintsAction = RequestTypeHintsAction = {}));
      var SetTypeHintsAction;
      (function(SetTypeHintsAction2) {
        SetTypeHintsAction2.KIND = "setTypeHints";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetTypeHintsAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "shapeHints") && (0, type_util_1.hasArrayProp)(object, "edgeHints");
        }
        SetTypeHintsAction2.is = is;
        function create(options) {
          return Object.assign({ kind: SetTypeHintsAction2.KIND, responseId: "" }, options);
        }
        SetTypeHintsAction2.create = create;
      })(SetTypeHintsAction || (exports.SetTypeHintsAction = SetTypeHintsAction = {}));
      var RequestCheckEdgeAction;
      (function(RequestCheckEdgeAction2) {
        RequestCheckEdgeAction2.KIND = "requestCheckEdge";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, RequestCheckEdgeAction2.KIND) && (0, type_util_1.hasStringProp)(object, "edgeType") && (0, type_util_1.hasStringProp)(object, "sourceElementId") && (0, type_util_1.hasStringProp)(object, "targetElementId", true);
        }
        RequestCheckEdgeAction2.is = is;
        function create(options) {
          var _a;
          return {
            kind: RequestCheckEdgeAction2.KIND,
            edgeType: options.edgeType,
            sourceElementId: getElementTypeId(options.sourceElement),
            targetElementId: options.targetElement ? getElementTypeId(options.targetElement) : void 0,
            requestId: (_a = options.requestId) !== null && _a !== void 0 ? _a : ""
          };
        }
        RequestCheckEdgeAction2.create = create;
      })(RequestCheckEdgeAction || (exports.RequestCheckEdgeAction = RequestCheckEdgeAction = {}));
      function getElementTypeId(element) {
        if (typeof element === "string") {
          return element;
        }
        return element.id;
      }
      var CheckEdgeResultAction;
      (function(CheckEdgeResultAction2) {
        CheckEdgeResultAction2.KIND = "checkEdgeTargetResult";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, CheckEdgeResultAction2.KIND) && (0, type_util_1.hasBooleanProp)(object, "isValid") && (0, type_util_1.hasStringProp)(object, "edgeType") && (0, type_util_1.hasStringProp)(object, "sourceElementId") && (0, type_util_1.hasStringProp)(object, "targetElementId", true);
        }
        CheckEdgeResultAction2.is = is;
        function create(options) {
          return Object.assign({ kind: CheckEdgeResultAction2.KIND, responseId: "" }, options);
        }
        CheckEdgeResultAction2.create = create;
      })(CheckEdgeResultAction || (exports.CheckEdgeResultAction = CheckEdgeResultAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-validation.js
  var require_element_validation = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-validation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteMarkersAction = exports.SetMarkersAction = exports.RequestMarkersAction = exports.MarkersReason = exports.MarkerKind = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var MarkerKind;
      (function(MarkerKind2) {
        MarkerKind2.INFO = "info";
        MarkerKind2.WARNING = "warning";
        MarkerKind2.ERROR = "error";
      })(MarkerKind || (exports.MarkerKind = MarkerKind = {}));
      var MarkersReason;
      (function(MarkersReason2) {
        MarkersReason2.BATCH = "batch";
        MarkersReason2.LIVE = "live";
      })(MarkersReason || (exports.MarkersReason = MarkersReason = {}));
      var RequestMarkersAction;
      (function(RequestMarkersAction2) {
        RequestMarkersAction2.KIND = "requestMarkers";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestMarkersAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementsIDs");
        }
        RequestMarkersAction2.is = is;
        function create(elementsIDs, options = {}) {
          return Object.assign({ kind: RequestMarkersAction2.KIND, requestId: "", elementsIDs, reason: MarkersReason.BATCH }, options);
        }
        RequestMarkersAction2.create = create;
      })(RequestMarkersAction || (exports.RequestMarkersAction = RequestMarkersAction = {}));
      var SetMarkersAction;
      (function(SetMarkersAction2) {
        SetMarkersAction2.KIND = "setMarkers";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetMarkersAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "markers");
        }
        SetMarkersAction2.is = is;
        function create(markers, options = {}) {
          return Object.assign({ kind: SetMarkersAction2.KIND, responseId: "", markers, reason: MarkersReason.BATCH }, options);
        }
        SetMarkersAction2.create = create;
      })(SetMarkersAction || (exports.SetMarkersAction = SetMarkersAction = {}));
      var DeleteMarkersAction;
      (function(DeleteMarkersAction2) {
        DeleteMarkersAction2.KIND = "deleteMarkers";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, DeleteMarkersAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "markers");
        }
        DeleteMarkersAction2.is = is;
        function create(markers) {
          return {
            kind: DeleteMarkersAction2.KIND,
            markers
          };
        }
        DeleteMarkersAction2.create = create;
      })(DeleteMarkersAction || (exports.DeleteMarkersAction = DeleteMarkersAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-data.js
  var require_model_data = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-data.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SourceModelChangedAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestModelAction2;
      (function(RequestModelAction3) {
        RequestModelAction3.KIND = "requestModel";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestModelAction3.KIND);
        }
        RequestModelAction3.is = is;
        function create(options = {}) {
          return Object.assign({ kind: RequestModelAction3.KIND, requestId: "" }, options);
        }
        RequestModelAction3.create = create;
      })(RequestModelAction2 || (exports.RequestModelAction = RequestModelAction2 = {}));
      var SetModelAction;
      (function(SetModelAction2) {
        SetModelAction2.KIND = "setModel";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetModelAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "newRoot");
        }
        SetModelAction2.is = is;
        function create(newRoot, options = {}) {
          return Object.assign({ kind: SetModelAction2.KIND, responseId: "", newRoot }, options);
        }
        SetModelAction2.create = create;
      })(SetModelAction || (exports.SetModelAction = SetModelAction = {}));
      var UpdateModelAction;
      (function(UpdateModelAction2) {
        UpdateModelAction2.KIND = "updateModel";
        function is(action) {
          return base_protocol_1.Action.hasKind(action, UpdateModelAction2.KIND) && (0, type_util_1.hasObjectProp)(action, "newRoot");
        }
        UpdateModelAction2.is = is;
        function create(newRoot, options = {}) {
          return Object.assign({ kind: UpdateModelAction2.KIND, newRoot, animate: true }, options);
        }
        UpdateModelAction2.create = create;
      })(UpdateModelAction || (exports.UpdateModelAction = UpdateModelAction = {}));
      var SourceModelChangedAction;
      (function(SourceModelChangedAction2) {
        SourceModelChangedAction2.KIND = "sourceModelChanged";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SourceModelChangedAction2.KIND) && (0, type_util_1.hasStringProp)(object, "sourceModelName");
        }
        SourceModelChangedAction2.is = is;
        function create(sourceModelName) {
          return {
            kind: SourceModelChangedAction2.KIND,
            sourceModelName
          };
        }
        SourceModelChangedAction2.create = create;
      })(SourceModelChangedAction || (exports.SourceModelChangedAction = SourceModelChangedAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-edit-mode.js
  var require_model_edit_mode = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-edit-mode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EditMode = exports.SetEditModeAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var SetEditModeAction;
      (function(SetEditModeAction2) {
        SetEditModeAction2.KIND = "setEditMode";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetEditModeAction2.KIND) && (0, type_util_1.hasStringProp)(object, "editMode");
        }
        SetEditModeAction2.is = is;
        function create(editMode) {
          return {
            kind: SetEditModeAction2.KIND,
            editMode
          };
        }
        SetEditModeAction2.create = create;
      })(SetEditModeAction || (exports.SetEditModeAction = SetEditModeAction = {}));
      var EditMode;
      (function(EditMode2) {
        EditMode2.READONLY = "readonly";
        EditMode2.EDITABLE = "editable";
      })(EditMode || (exports.EditMode = EditMode = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-layout.js
  var require_model_layout = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-layout.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LayoutOperation = exports.ComputedBoundsAction = exports.RequestBoundsAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestBoundsAction;
      (function(RequestBoundsAction2) {
        RequestBoundsAction2.KIND = "requestBounds";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestBoundsAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "newRoot");
        }
        RequestBoundsAction2.is = is;
        function create(newRoot, options = {}) {
          return Object.assign({ kind: RequestBoundsAction2.KIND, requestId: "", newRoot }, options);
        }
        RequestBoundsAction2.create = create;
      })(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
      var ComputedBoundsAction;
      (function(ComputedBoundsAction2) {
        ComputedBoundsAction2.KIND = "computedBounds";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, ComputedBoundsAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "bounds");
        }
        ComputedBoundsAction2.is = is;
        function create(bounds, options = {}) {
          return Object.assign({ kind: ComputedBoundsAction2.KIND, responseId: "", bounds }, options);
        }
        ComputedBoundsAction2.create = create;
      })(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
      var LayoutOperation;
      (function(LayoutOperation2) {
        LayoutOperation2.KIND = "layout";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, LayoutOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementIds");
        }
        LayoutOperation2.is = is;
        function create(elementIds) {
          return {
            kind: LayoutOperation2.KIND,
            isOperation: true,
            elementIds
          };
        }
        LayoutOperation2.create = create;
      })(LayoutOperation || (exports.LayoutOperation = LayoutOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-saving.js
  var require_model_saving = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-saving.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExportSvgAction = exports.RequestExportSvgAction = exports.SetDirtyStateAction = exports.SaveModelAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var SaveModelAction;
      (function(SaveModelAction2) {
        SaveModelAction2.KIND = "saveModel";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SaveModelAction2.KIND);
        }
        SaveModelAction2.is = is;
        function create(options = {}) {
          return Object.assign({ kind: SaveModelAction2.KIND }, options);
        }
        SaveModelAction2.create = create;
      })(SaveModelAction || (exports.SaveModelAction = SaveModelAction = {}));
      var SetDirtyStateAction;
      (function(SetDirtyStateAction2) {
        SetDirtyStateAction2.KIND = "setDirtyState";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetDirtyStateAction2.KIND) && (0, type_util_1.hasBooleanProp)(object, "isDirty");
        }
        SetDirtyStateAction2.is = is;
        function create(isDirty, options = {}) {
          return Object.assign({ kind: SetDirtyStateAction2.KIND, isDirty }, options);
        }
        SetDirtyStateAction2.create = create;
      })(SetDirtyStateAction || (exports.SetDirtyStateAction = SetDirtyStateAction = {}));
      var RequestExportSvgAction;
      (function(RequestExportSvgAction2) {
        RequestExportSvgAction2.KIND = "requestExportSvg";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestExportSvgAction2.KIND);
        }
        RequestExportSvgAction2.is = is;
        function create(options = {}) {
          return Object.assign({ kind: RequestExportSvgAction2.KIND, requestId: "" }, options);
        }
        RequestExportSvgAction2.create = create;
      })(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
      var ExportSvgAction;
      (function(ExportSvgAction2) {
        ExportSvgAction2.KIND = "exportSvg";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, ExportSvgAction2.KIND) && (0, type_util_1.hasStringProp)(object, "svg");
        }
        ExportSvgAction2.is = is;
        function create(svg3, options = {}) {
          return Object.assign({ kind: ExportSvgAction2.KIND, svg: svg3, responseId: "" }, options);
        }
        ExportSvgAction2.create = create;
      })(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/node-modification.js
  var require_node_modification = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/node-modification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChangeContainerOperation = exports.ChangeBoundsOperation = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var ChangeBoundsOperation;
      (function(ChangeBoundsOperation2) {
        ChangeBoundsOperation2.KIND = "changeBounds";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ChangeBoundsOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "newBounds");
        }
        ChangeBoundsOperation2.is = is;
        function create(newBounds) {
          return {
            kind: ChangeBoundsOperation2.KIND,
            isOperation: true,
            newBounds
          };
        }
        ChangeBoundsOperation2.create = create;
      })(ChangeBoundsOperation || (exports.ChangeBoundsOperation = ChangeBoundsOperation = {}));
      var ChangeContainerOperation;
      (function(ChangeContainerOperation2) {
        ChangeContainerOperation2.KIND = "changeContainer";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ChangeContainerOperation2.KIND) && (0, type_util_1.hasStringProp)(object, "elementId") && (0, type_util_1.hasStringProp)(object, "targetContainerId");
        }
        ChangeContainerOperation2.is = is;
        function create(options) {
          return Object.assign({ kind: ChangeContainerOperation2.KIND, isOperation: true }, options);
        }
        ChangeContainerOperation2.create = create;
      })(ChangeContainerOperation || (exports.ChangeContainerOperation = ChangeContainerOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/tool-palette.js
  var require_tool_palette = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/tool-palette.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TriggerEdgeCreationAction = exports.TriggerNodeCreationAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var TriggerNodeCreationAction;
      (function(TriggerNodeCreationAction2) {
        TriggerNodeCreationAction2.KIND = "triggerNodeCreation";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, TriggerNodeCreationAction2.KIND) && (0, type_util_1.hasStringProp)(object, "elementTypeId");
        }
        TriggerNodeCreationAction2.is = is;
        function create(elementTypeId, options = {}) {
          return Object.assign({ kind: TriggerNodeCreationAction2.KIND, elementTypeId }, options);
        }
        TriggerNodeCreationAction2.create = create;
      })(TriggerNodeCreationAction || (exports.TriggerNodeCreationAction = TriggerNodeCreationAction = {}));
      var TriggerEdgeCreationAction;
      (function(TriggerEdgeCreationAction2) {
        TriggerEdgeCreationAction2.KIND = "triggerEdgeCreation";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, TriggerEdgeCreationAction2.KIND) && (0, type_util_1.hasStringProp)(object, "elementTypeId");
        }
        TriggerEdgeCreationAction2.is = is;
        function create(elementTypeId, options = {}) {
          return Object.assign({ kind: TriggerEdgeCreationAction2.KIND, elementTypeId }, options);
        }
        TriggerEdgeCreationAction2.create = create;
      })(TriggerEdgeCreationAction || (exports.TriggerEdgeCreationAction = TriggerEdgeCreationAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/types.js
  var require_types2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MenuItem = exports.PaletteItem = exports.LabeledAction = exports.EditorContext = void 0;
      var type_util_1 = require_type_util();
      var tool_palette_1 = require_tool_palette();
      var EditorContext;
      (function(EditorContext2) {
        function is(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasArrayProp)(object, "selectedElementIds");
        }
        EditorContext2.is = is;
      })(EditorContext || (exports.EditorContext = EditorContext = {}));
      var LabeledAction;
      (function(LabeledAction2) {
        function is(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "label") && (0, type_util_1.hasArrayProp)(object, "actions");
        }
        LabeledAction2.is = is;
        function toActionArray(input) {
          if (Array.isArray(input)) {
            return input;
          } else if (LabeledAction2.is(input)) {
            return input.actions;
          }
          return [input];
        }
        LabeledAction2.toActionArray = toActionArray;
      })(LabeledAction || (exports.LabeledAction = LabeledAction = {}));
      var PaletteItem;
      (function(PaletteItem2) {
        function is(object) {
          return LabeledAction.is(object) && (0, type_util_1.hasStringProp)(object, "id") && (0, type_util_1.hasStringProp)(object, "sortString");
        }
        PaletteItem2.is = is;
        function getTriggerAction(item) {
          if (item) {
            const initialActions = item.actions.filter((a) => isTriggerElementCreationAction(a)).map((action) => action);
            return initialActions.length > 0 ? initialActions[0] : void 0;
          }
          return void 0;
        }
        PaletteItem2.getTriggerAction = getTriggerAction;
        function isTriggerElementCreationAction(object) {
          return tool_palette_1.TriggerNodeCreationAction.is(object) || tool_palette_1.TriggerEdgeCreationAction.is(object);
        }
        PaletteItem2.isTriggerElementCreationAction = isTriggerElementCreationAction;
      })(PaletteItem || (exports.PaletteItem = PaletteItem = {}));
      var MenuItem;
      (function(MenuItem2) {
        function is(object) {
          return LabeledAction.is(object) && (0, type_util_1.hasStringProp)(object, "id");
        }
        MenuItem2.is = is;
      })(MenuItem || (exports.MenuItem = MenuItem = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/undo-redo.js
  var require_undo_redo2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/undo-redo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RedoAction = exports.UndoAction = void 0;
      var base_protocol_1 = require_base_protocol();
      var UndoAction;
      (function(UndoAction2) {
        UndoAction2.KIND = "glspUndo";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, UndoAction2.KIND);
        }
        UndoAction2.is = is;
        function create() {
          return {
            kind: UndoAction2.KIND
          };
        }
        UndoAction2.create = create;
      })(UndoAction || (exports.UndoAction = UndoAction = {}));
      var RedoAction;
      (function(RedoAction2) {
        RedoAction2.KIND = "glspRedo";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, RedoAction2.KIND);
        }
        RedoAction2.is = is;
        function create() {
          return {
            kind: RedoAction2.KIND
          };
        }
        RedoAction2.create = create;
      })(RedoAction || (exports.RedoAction = RedoAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/viewport.js
  var require_viewport2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/viewport.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FitToScreenAction = exports.CenterAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var CenterAction;
      (function(CenterAction2) {
        CenterAction2.KIND = "center";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, CenterAction2.KIND) && (0, type_util_1.hasBooleanProp)(object, "animate") && (0, type_util_1.hasBooleanProp)(object, "retainZoom");
        }
        CenterAction2.is = is;
        function create(elementIds, options = {}) {
          return Object.assign({ kind: CenterAction2.KIND, animate: true, retainZoom: false, elementIds }, options);
        }
        CenterAction2.create = create;
      })(CenterAction || (exports.CenterAction = CenterAction = {}));
      var FitToScreenAction;
      (function(FitToScreenAction2) {
        FitToScreenAction2.KIND = "fit";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, FitToScreenAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementIds") && (0, type_util_1.hasBooleanProp)(object, "animate");
        }
        FitToScreenAction2.is = is;
        function create(elementIds, options = {}) {
          return Object.assign({ kind: FitToScreenAction2.KIND, animate: true, elementIds }, options);
        }
        FitToScreenAction2.create = create;
      })(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/index.js
  var require_action_protocol = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_base_protocol(), exports);
      __exportStar(require_client_notification(), exports);
      __exportStar(require_clipboard(), exports);
      __exportStar(require_contexts(), exports);
      __exportStar(require_edge_modification(), exports);
      __exportStar(require_element_creation(), exports);
      __exportStar(require_element_hover(), exports);
      __exportStar(require_element_navigation(), exports);
      __exportStar(require_element_selection(), exports);
      __exportStar(require_element_text_editing(), exports);
      __exportStar(require_element_type_hints(), exports);
      __exportStar(require_element_validation(), exports);
      __exportStar(require_model_data(), exports);
      __exportStar(require_model_edit_mode(), exports);
      __exportStar(require_model_layout(), exports);
      __exportStar(require_model_saving(), exports);
      __exportStar(require_node_modification(), exports);
      __exportStar(require_tool_palette(), exports);
      __exportStar(require_types2(), exports);
      __exportStar(require_undo_redo2(), exports);
      __exportStar(require_viewport2(), exports);
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/diagram-server.js
  var require_diagram_server3 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/diagram-server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramServer = void 0;
      var actions_1 = require_actions2();
      var async_1 = require_async3();
      var model_utils_1 = require_model_utils2();
      var DiagramServer = class {
        constructor(dispatch, services) {
          this.state = {
            currentRoot: {
              type: "NONE",
              id: "ROOT"
            },
            revision: 0
          };
          this.requests = /* @__PURE__ */ new Map();
          this.dispatch = dispatch;
          this.diagramGenerator = services.DiagramGenerator;
          this.layoutEngine = services.ModelLayoutEngine;
          this.actionHandlerRegistry = services.ServerActionHandlerRegistry;
        }
        /**
         * Set the model and submit it to the client.
         */
        setModel(newRoot) {
          newRoot.revision = ++this.state.revision;
          this.state.currentRoot = newRoot;
          return this.submitModel(newRoot, false);
        }
        /**
         * Update the model to a new state and submit it to the client.
         */
        updateModel(newRoot) {
          newRoot.revision = ++this.state.revision;
          this.state.currentRoot = newRoot;
          return this.submitModel(newRoot, true);
        }
        /**
         * Whether the client needs to compute the layout of parts of the model. This affects the behavior
         * of `submitModel`.
         *
         * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
         * from the client. If the client does not specify whether it needs client layout, the default value
         * is `true`.
         */
        get needsClientLayout() {
          if (this.state.options && this.state.options.needsClientLayout !== void 0) {
            return !!this.state.options.needsClientLayout;
          }
          return true;
        }
        /**
         * Whether the server needs to compute the layout of parts of the model. This affects the behavior
         * of `submitModel`.
         *
         * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
         * from the client. If the client does not specify whether it needs server layout, the default value
         * is `false`.
         */
        get needsServerLayout() {
          if (this.state.options && this.state.options.needsServerLayout !== void 0) {
            return !!this.state.options.needsServerLayout;
          }
          return false;
        }
        /**
         * Called when an action is received from the client.
         */
        accept(action) {
          if ((0, actions_1.isResponseAction)(action)) {
            const id = action.responseId;
            const future = this.requests.get(id);
            if (future) {
              this.requests.delete(id);
              if (action.kind === actions_1.RejectAction.KIND) {
                const rejectAction = action;
                future.reject(new Error(rejectAction.message));
                console.warn(`Request with id ${action.responseId} failed: ${rejectAction.message}`, rejectAction.detail);
              } else {
                future.resolve(action);
              }
              return Promise.resolve();
            }
            console.info("No matching request for response:", action);
          }
          return this.handleAction(action);
        }
        /**
         * Send a request action to the client. The resulting promise is resolved when a matching
         * response is received and rejected when a `RejectAction` is received.
         */
        request(action) {
          if (!action.requestId) {
            action.requestId = "server_" + (0, actions_1.generateRequestId)();
          }
          const future = new async_1.Deferred();
          this.requests.set(action.requestId, future);
          this.dispatch(action).catch((err) => {
            this.requests.delete(action.requestId);
            future.reject(err);
          });
          return future.promise;
        }
        /**
         * Send a `RejectAction` to the client to notify that a request could not be fulfilled.
         */
        rejectRemoteRequest(action, error) {
          if (action && (0, actions_1.isRequestAction)(action)) {
            this.dispatch({
              kind: actions_1.RejectAction.KIND,
              responseId: action.requestId,
              message: error.message,
              detail: error.stack
            });
          }
        }
        handleAction(action) {
          var _a;
          const handlers = (_a = this.actionHandlerRegistry) === null || _a === void 0 ? void 0 : _a.getHandler(action.kind);
          if (handlers && handlers.length === 1) {
            return handlers[0](action, this.state, this);
          } else if (handlers && handlers.length > 1) {
            return Promise.all(handlers.map((h) => h(action, this.state, this)));
          }
          switch (action.kind) {
            case actions_1.RequestModelAction.KIND:
              return this.handleRequestModel(action);
            case actions_1.ComputedBoundsAction.KIND:
              return this.handleComputedBounds(action);
            case actions_1.LayoutAction.KIND:
              return this.handleLayout(action);
          }
          console.warn(`Unhandled action from client: ${action.kind}`);
          return Promise.resolve();
        }
        async handleRequestModel(action) {
          var _a;
          this.state.options = action.options;
          try {
            const newRoot = await this.diagramGenerator.generate({
              options: (_a = this.state.options) !== null && _a !== void 0 ? _a : {},
              state: this.state
            });
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
            await this.submitModel(this.state.currentRoot, false, action);
          } catch (err) {
            this.rejectRemoteRequest(action, err);
            console.error("Failed to generate diagram:", err);
          }
        }
        /**
         * Submit a model to the client after it has been updated in the server state.
         */
        async submitModel(newRoot, update, cause) {
          if (this.needsClientLayout) {
            if (!this.needsServerLayout) {
              this.dispatch({ kind: actions_1.RequestBoundsAction.KIND, newRoot });
            } else {
              const request = actions_1.RequestBoundsAction.create(newRoot);
              const response = await this.request(request);
              const currentRoot = this.state.currentRoot;
              if (response.revision === currentRoot.revision) {
                (0, model_utils_1.applyBounds)(currentRoot, response);
                await this.doSubmitModel(currentRoot, update, cause);
              } else {
                this.rejectRemoteRequest(cause, new Error(`Model revision does not match: ${response.revision}`));
              }
            }
          } else {
            await this.doSubmitModel(newRoot, update, cause);
          }
        }
        async doSubmitModel(newRoot, update, cause) {
          if (newRoot.revision !== this.state.revision) {
            return;
          }
          if (this.needsServerLayout && this.layoutEngine) {
            newRoot = await this.layoutEngine.layout(newRoot);
          }
          const modelType = newRoot.type;
          if (cause && cause.kind === actions_1.RequestModelAction.KIND) {
            const requestId = cause.requestId;
            const response = actions_1.SetModelAction.create(newRoot, requestId);
            await this.dispatch(response);
          } else if (update && modelType === this.state.lastSubmittedModelType) {
            await this.dispatch({ kind: actions_1.UpdateModelAction.KIND, newRoot, cause });
          } else {
            await this.dispatch({ kind: actions_1.SetModelAction.KIND, newRoot });
          }
          this.state.lastSubmittedModelType = modelType;
        }
        handleComputedBounds(action) {
          if (action.revision !== this.state.currentRoot.revision) {
            return Promise.reject();
          }
          (0, model_utils_1.applyBounds)(this.state.currentRoot, action);
          return Promise.resolve();
        }
        async handleLayout(action) {
          if (!this.layoutEngine) {
            return;
          }
          if (!this.needsServerLayout) {
            let newRoot = (0, model_utils_1.cloneModel)(this.state.currentRoot);
            newRoot = await this.layoutEngine.layout(newRoot);
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
          }
          await this.doSubmitModel(this.state.currentRoot, true, action);
        }
      };
      exports.DiagramServer = DiagramServer;
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/diagram-services.js
  var require_diagram_services2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/diagram-services.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/model.js
  var require_model19 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isZoomable = exports.isScrollable = void 0;
      var object_1 = require_object2();
      function isScrollable(element) {
        return (0, object_1.hasOwnProperty)(element, "scroll");
      }
      exports.isScrollable = isScrollable;
      function isZoomable(element) {
        return (0, object_1.hasOwnProperty)(element, "zoom");
      }
      exports.isZoomable = isZoomable;
    }
  });

  // node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/node_modules/sprotty-protocol/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_actions2(), exports);
      __exportStar(require_diagram_server3(), exports);
      __exportStar(require_diagram_services2(), exports);
      __exportStar(require_model19(), exports);
      __exportStar(require_async3(), exports);
      __exportStar(require_geometry3(), exports);
      __exportStar(require_json2(), exports);
      __exportStar(require_model_utils2(), exports);
      __exportStar(require_object2(), exports);
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
      var is = require_is();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
      var ResponseError = class extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports.ResponseError = ResponseError;
      var ParameterStructures = class {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.NotificationType9 = NotificationType9;
      var Message;
      (function(Message2) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message2.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message2.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message2.isResponse = isResponse;
      })(Message || (exports.Message = Message = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
      "use strict";
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch || (exports.Touch = Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports.LRUCache = LRUCache;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Disposable = void 0;
      var Disposable;
      (function(Disposable2) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable2.create = create;
      })(Disposable || (exports.Disposable = Disposable = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports.default = RAL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Emitter = exports.Event = void 0;
      var ral_1 = require_ral();
      var Event2;
      (function(Event3) {
        const _disposable = { dispose() {
        } };
        Event3.None = function() {
          return _disposable;
        };
      })(Event2 || (exports.Event = Event2 = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter = class {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports.Emitter = Emitter;
      Emitter._noop = function() {
      };
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CancellationTokenSource = exports.CancellationToken = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var events_1 = require_events();
      var CancellationToken;
      (function(CancellationToken2) {
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken2.is = is;
      })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports.CancellationTokenSource = CancellationTokenSource;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
  var require_sharedArrayCancellation = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
      var cancellation_1 = require_cancellation();
      var CancellationState;
      (function(CancellationState2) {
        CancellationState2.Continue = 0;
        CancellationState2.Cancelled = 1;
      })(CancellationState || (CancellationState = {}));
      var SharedArraySenderStrategy = class {
        constructor() {
          this.buffers = /* @__PURE__ */ new Map();
        }
        enableCancellation(request) {
          if (request.id === null) {
            return;
          }
          const buffer = new SharedArrayBuffer(4);
          const data = new Int32Array(buffer, 0, 1);
          data[0] = CancellationState.Continue;
          this.buffers.set(request.id, buffer);
          request.$cancellationData = buffer;
        }
        async sendCancellation(_conn, id) {
          const buffer = this.buffers.get(id);
          if (buffer === void 0) {
            return;
          }
          const data = new Int32Array(buffer, 0, 1);
          Atomics.store(data, 0, CancellationState.Cancelled);
        }
        cleanup(id) {
          this.buffers.delete(id);
        }
        dispose() {
          this.buffers.clear();
        }
      };
      exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
      var SharedArrayBufferCancellationToken = class {
        constructor(buffer) {
          this.data = new Int32Array(buffer, 0, 1);
        }
        get isCancellationRequested() {
          return Atomics.load(this.data, 0) === CancellationState.Cancelled;
        }
        get onCancellationRequested() {
          throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
        }
      };
      var SharedArrayBufferCancellationTokenSource = class {
        constructor(buffer) {
          this.token = new SharedArrayBufferCancellationToken(buffer);
        }
        cancel() {
        }
        dispose() {
        }
      };
      var SharedArrayReceiverStrategy = class {
        constructor() {
          this.kind = "request";
        }
        createCancellationTokenSource(request) {
          const buffer = request.$cancellationData;
          if (buffer === void 0) {
            return new cancellation_1.CancellationTokenSource();
          }
          return new SharedArrayBufferCancellationTokenSource(buffer);
        }
      };
      exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Semaphore = void 0;
      var ral_1 = require_ral();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports.Semaphore = Semaphore;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var events_1 = require_events();
      var semaphore_1 = require_semaphore();
      var MessageReader;
      (function(MessageReader2) {
        function is(value) {
          let candidate = value;
          return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
        }
        MessageReader2.is = is;
      })(MessageReader || (exports.MessageReader = MessageReader = {}));
      var AbstractMessageReader = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageReader = AbstractMessageReader;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.readSemaphore = new semaphore_1.Semaphore(1);
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          try {
            this.buffer.append(data);
            while (true) {
              if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders(true);
                if (!headers) {
                  return;
                }
                const contentLength = headers.get("content-length");
                if (!contentLength) {
                  this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                  return;
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                  this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                  return;
                }
                this.nextMessageLength = length;
              }
              const body = this.buffer.tryReadBody(this.nextMessageLength);
              if (body === void 0) {
                this.setPartialMessageTimer();
                return;
              }
              this.clearPartialMessageTimer();
              this.nextMessageLength = -1;
              this.readSemaphore.lock(async () => {
                const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                this.callback(message);
              }).catch((error) => {
                this.fireError(error);
              });
            }
          } catch (error) {
            this.fireError(error);
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var semaphore_1 = require_semaphore();
      var events_1 = require_events();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter;
      (function(MessageWriter2) {
        function is(value) {
          let candidate = value;
          return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
        }
        MessageWriter2.is = is;
      })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
      var AbstractMessageWriter = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageWriter = AbstractMessageWriter;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders(lowerCaseKeys = false) {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row:
            while (chunkIndex < this._chunks.length) {
              const chunk = this._chunks[chunkIndex];
              offset = 0;
              column:
                while (offset < chunk.length) {
                  const value = chunk[offset];
                  switch (value) {
                    case CR:
                      switch (state) {
                        case 0:
                          state = 1;
                          break;
                        case 2:
                          state = 3;
                          break;
                        default:
                          state = 0;
                      }
                      break;
                    case LF:
                      switch (state) {
                        case 1:
                          state = 2;
                          break;
                        case 3:
                          state = 4;
                          offset++;
                          break row;
                        default:
                          state = 0;
                      }
                      break;
                    default:
                      state = 0;
                  }
                  offset++;
                }
              chunkBytesRead += chunk.byteLength;
              chunkIndex++;
            }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error(`Message header must separate key and value using ':'
${header}`);
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var messages_1 = require_messages();
      var linkedMap_1 = require_linkedMap();
      var events_1 = require_events();
      var cancellation_1 = require_cancellation();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace || (exports.Trace = Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues || (exports.TraceValues = TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString;
      })(Trace || (exports.Trace = Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
      var ConnectionError = class extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, ConnectionError.prototype);
        }
      };
      exports.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
      var IdCancellationReceiverStrategy;
      (function(IdCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
        }
        IdCancellationReceiverStrategy2.is = is;
      })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
      var RequestCancellationReceiverStrategy;
      (function(RequestCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
        }
        RequestCancellationReceiverStrategy2.is = is;
      })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
      var MessageStrategy;
      (function(MessageStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.handleMessage);
        }
        MessageStrategy2.is = is;
      })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection(messageReader, messageWriter, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader.onClose(closeHandler);
        messageReader.onError(readErrorHandler);
        messageWriter.onClose(closeHandler);
        messageWriter.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer || messageQueue.size === 0) {
            return;
          }
          timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = void 0;
            processMessageQueue();
          });
        }
        function handleMessage(message) {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
              messageStrategy.handleMessage(message, handleMessage);
            } else {
              handleMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
              method = type;
              const first = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch((error) => {
              logger.error(`Sending notification failed.`);
              throw error;
            });
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is.string(type)) {
              method = type;
              const first = args[0];
              const last = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last)) {
                paramEnd = paramEnd - 1;
                token = last;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === "function") {
              cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              try {
                await messageWriter.write(requestMessage);
                responsePromises.set(id, responsePromise);
              } catch (error) {
                logger.error(`Sending request failed.`);
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
                throw error;
              }
            });
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is.func(messageWriter.dispose)) {
              messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
              messageReader.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection;
      }
      exports.createMessageConnection = createMessageConnection;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
      exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
      var messages_1 = require_messages();
      Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap();
      Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable();
      Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events();
      Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation();
      Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var sharedArrayCancellation_1 = require_sharedArrayCancellation();
      Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArraySenderStrategy;
      } });
      Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
      } });
      var messageReader_1 = require_messageReader();
      Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter();
      Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var messageBuffer_1 = require_messageBuffer();
      Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
        return messageBuffer_1.AbstractMessageBuffer;
      } });
      var connection_1 = require_connection();
      Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
        return connection_1.MessageStrategy;
      } });
      var ral_1 = require_ral();
      exports.RAL = ral_1.default;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var api_1 = require_api();
      var MessageBuffer = class extends api_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          api_1.RAL.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports.default = RIL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
      var ril_1 = require_ril();
      ril_1.default.install();
      var api_1 = require_api();
      __exportStar(require_api(), exports);
      var BrowserMessageReader = class extends api_1.AbstractMessageReader {
        constructor(port) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          port.addEventListener("error", (event) => this.fireError(event));
          port.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports.BrowserMessageReader = BrowserMessageReader;
      var BrowserMessageWriter = class extends api_1.AbstractMessageWriter {
        constructor(port) {
          super();
          this.port = port;
          this.errorCount = 0;
          port.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.port.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports.BrowserMessageWriter = BrowserMessageWriter;
      function createMessageConnection(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports.createMessageConnection = createMessageConnection;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/event.js
  var require_event = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/event.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Emitter = void 0;
      var jsonrpc = require_main();
      var Emitter = class extends jsonrpc.Emitter {
        constructor(options = {}) {
          super(options);
        }
        /**
         * The even that is managed by this emitter.
         * Intended for the public to allow to subscribe to the emitter`s events.
         */
        get event() {
          return super.event;
        }
        /**
         * Fires and event and notifies all registered listeners
         */
        fire(event) {
          super.fire(event);
        }
      };
      exports.Emitter = Emitter;
    }
  });

  // node_modules/uuid/dist/rng-browser.js
  var require_rng_browser = __commonJS({
    "node_modules/uuid/dist/rng-browser.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = rng;
      var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
      var rnds8 = new Uint8Array(16);
      function rng() {
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
        return getRandomValues(rnds8);
      }
      module.exports = exports.default;
    }
  });

  // node_modules/uuid/dist/bytesToUuid.js
  var require_bytesToUuid = __commonJS({
    "node_modules/uuid/dist/bytesToUuid.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var byteToHex = [];
      for (i = 0; i < 256; ++i) {
        byteToHex[i] = (i + 256).toString(16).substr(1);
      }
      var i;
      function bytesToUuid(buf, offset) {
        var i2 = offset || 0;
        var bth = byteToHex;
        return [bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]]].join("");
      }
      var _default = bytesToUuid;
      exports.default = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/uuid/dist/v1.js
  var require_v1 = __commonJS({
    "node_modules/uuid/dist/v1.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _rng = _interopRequireDefault(require_rng_browser());
      var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _nodeId;
      var _clockseq;
      var _lastMSecs = 0;
      var _lastNSecs = 0;
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || [];
        options = options || {};
        var node = options.node || _nodeId;
        var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
        if (node == null || clockseq == null) {
          var seedBytes = options.random || (options.rng || _rng.default)();
          if (node == null) {
            node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
          }
          if (clockseq == null) {
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
          }
        }
        var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
        var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
        var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt < 0 && options.clockseq === void 0) {
          clockseq = clockseq + 1 & 16383;
        }
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
          nsecs = 0;
        }
        if (nsecs >= 1e4) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
        b[i++] = tl >>> 24 & 255;
        b[i++] = tl >>> 16 & 255;
        b[i++] = tl >>> 8 & 255;
        b[i++] = tl & 255;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b[i++] = tmh >>> 8 & 255;
        b[i++] = tmh & 255;
        b[i++] = tmh >>> 24 & 15 | 16;
        b[i++] = tmh >>> 16 & 255;
        b[i++] = clockseq >>> 8 | 128;
        b[i++] = clockseq & 255;
        for (var n = 0; n < 6; ++n) {
          b[i + n] = node[n];
        }
        return buf ? buf : (0, _bytesToUuid.default)(b);
      }
      var _default = v1;
      exports.default = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/uuid/dist/v35.js
  var require_v35 = __commonJS({
    "node_modules/uuid/dist/v35.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = _default;
      exports.URL = exports.DNS = void 0;
      var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function uuidToBytes(uuid) {
        var bytes = [];
        uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
          bytes.push(parseInt(hex, 16));
        });
        return bytes;
      }
      function stringToBytes(str) {
        str = unescape(encodeURIComponent(str));
        var bytes = new Array(str.length);
        for (var i = 0; i < str.length; i++) {
          bytes[i] = str.charCodeAt(i);
        }
        return bytes;
      }
      var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      exports.DNS = DNS;
      var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
      exports.URL = URL;
      function _default(name, version, hashfunc) {
        var generateUUID = function(value, namespace, buf, offset) {
          var off = buf && offset || 0;
          if (typeof value == "string")
            value = stringToBytes(value);
          if (typeof namespace == "string")
            namespace = uuidToBytes(namespace);
          if (!Array.isArray(value))
            throw TypeError("value must be an array of bytes");
          if (!Array.isArray(namespace) || namespace.length !== 16)
            throw TypeError("namespace must be uuid string or an Array of 16 byte values");
          var bytes = hashfunc(namespace.concat(value));
          bytes[6] = bytes[6] & 15 | version;
          bytes[8] = bytes[8] & 63 | 128;
          if (buf) {
            for (var idx = 0; idx < 16; ++idx) {
              buf[off + idx] = bytes[idx];
            }
          }
          return buf || (0, _bytesToUuid.default)(bytes);
        };
        try {
          generateUUID.name = name;
        } catch (err) {
        }
        generateUUID.DNS = DNS;
        generateUUID.URL = URL;
        return generateUUID;
      }
    }
  });

  // node_modules/uuid/dist/md5-browser.js
  var require_md5_browser = __commonJS({
    "node_modules/uuid/dist/md5-browser.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      function md5(bytes) {
        if (typeof bytes == "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = new Array(msg.length);
          for (var i = 0; i < msg.length; i++)
            bytes[i] = msg.charCodeAt(i);
        }
        return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
      }
      function md5ToHexEncodedArray(input) {
        var i;
        var x;
        var output = [];
        var length32 = input.length * 32;
        var hexTab = "0123456789abcdef";
        var hex;
        for (i = 0; i < length32; i += 8) {
          x = input[i >> 5] >>> i % 32 & 255;
          hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
          output.push(hex);
        }
        return output;
      }
      function wordsToMd5(x, len) {
        x[len >> 5] |= 128 << len % 32;
        x[(len + 64 >>> 9 << 4) + 14] = len;
        var i;
        var olda;
        var oldb;
        var oldc;
        var oldd;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        for (i = 0; i < x.length; i += 16) {
          olda = a;
          oldb = b;
          oldc = c;
          oldd = d;
          a = md5ff(a, b, c, d, x[i], 7, -680876936);
          d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5gg(b, c, d, a, x[i], 20, -373897302);
          a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5hh(d, a, b, c, x[i], 11, -358537222);
          c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5ii(a, b, c, d, x[i], 6, -198630844);
          d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = safeAdd(a, olda);
          b = safeAdd(b, oldb);
          c = safeAdd(c, oldc);
          d = safeAdd(d, oldd);
        }
        return [a, b, c, d];
      }
      function bytesToWords(input) {
        var i;
        var output = [];
        output[(input.length >> 2) - 1] = void 0;
        for (i = 0; i < output.length; i += 1) {
          output[i] = 0;
        }
        var length8 = input.length * 8;
        for (i = 0; i < length8; i += 8) {
          output[i >> 5] |= (input[i / 8] & 255) << i % 32;
        }
        return output;
      }
      function safeAdd(x, y) {
        var lsw = (x & 65535) + (y & 65535);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5cmn(q, a, b, x, s, t) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
      }
      function md5ff(a, b, c, d, x, s, t) {
        return md5cmn(b & c | ~b & d, a, b, x, s, t);
      }
      function md5gg(a, b, c, d, x, s, t) {
        return md5cmn(b & d | c & ~d, a, b, x, s, t);
      }
      function md5hh(a, b, c, d, x, s, t) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t);
      }
      function md5ii(a, b, c, d, x, s, t) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t);
      }
      var _default = md5;
      exports.default = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/uuid/dist/v3.js
  var require_v3 = __commonJS({
    "node_modules/uuid/dist/v3.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _v = _interopRequireDefault(require_v35());
      var _md = _interopRequireDefault(require_md5_browser());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v3 = (0, _v.default)("v3", 48, _md.default);
      var _default = v3;
      exports.default = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/uuid/dist/v4.js
  var require_v4 = __commonJS({
    "node_modules/uuid/dist/v4.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _rng = _interopRequireDefault(require_rng_browser());
      var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function v4(options, buf, offset) {
        var i = buf && offset || 0;
        if (typeof options == "string") {
          buf = options === "binary" ? new Array(16) : null;
          options = null;
        }
        options = options || {};
        var rnds = options.random || (options.rng || _rng.default)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
          for (var ii = 0; ii < 16; ++ii) {
            buf[i + ii] = rnds[ii];
          }
        }
        return buf || (0, _bytesToUuid.default)(rnds);
      }
      var _default = v4;
      exports.default = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/uuid/dist/sha1-browser.js
  var require_sha1_browser = __commonJS({
    "node_modules/uuid/dist/sha1-browser.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      function f(s, x, y, z) {
        switch (s) {
          case 0:
            return x & y ^ ~x & z;
          case 1:
            return x ^ y ^ z;
          case 2:
            return x & y ^ x & z ^ y & z;
          case 3:
            return x ^ y ^ z;
        }
      }
      function ROTL(x, n) {
        return x << n | x >>> 32 - n;
      }
      function sha1(bytes) {
        var K = [1518500249, 1859775393, 2400959708, 3395469782];
        var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if (typeof bytes == "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = new Array(msg.length);
          for (var i = 0; i < msg.length; i++)
            bytes[i] = msg.charCodeAt(i);
        }
        bytes.push(128);
        var l = bytes.length / 4 + 2;
        var N = Math.ceil(l / 16);
        var M = new Array(N);
        for (var i = 0; i < N; i++) {
          M[i] = new Array(16);
          for (var j = 0; j < 16; j++) {
            M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
          }
        }
        M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
        M[N - 1][14] = Math.floor(M[N - 1][14]);
        M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
        for (var i = 0; i < N; i++) {
          var W = new Array(80);
          for (var t = 0; t < 16; t++)
            W[t] = M[i][t];
          for (var t = 16; t < 80; t++) {
            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
          }
          var a = H[0];
          var b = H[1];
          var c = H[2];
          var d = H[3];
          var e = H[4];
          for (var t = 0; t < 80; t++) {
            var s = Math.floor(t / 20);
            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
          }
          H[0] = H[0] + a >>> 0;
          H[1] = H[1] + b >>> 0;
          H[2] = H[2] + c >>> 0;
          H[3] = H[3] + d >>> 0;
          H[4] = H[4] + e >>> 0;
        }
        return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
      }
      var _default = sha1;
      exports.default = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/uuid/dist/v5.js
  var require_v5 = __commonJS({
    "node_modules/uuid/dist/v5.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _v = _interopRequireDefault(require_v35());
      var _sha = _interopRequireDefault(require_sha1_browser());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v5 = (0, _v.default)("v5", 80, _sha.default);
      var _default = v5;
      exports.default = _default;
      module.exports = exports.default;
    }
  });

  // node_modules/uuid/dist/index.js
  var require_dist = __commonJS({
    "node_modules/uuid/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "v1", {
        enumerable: true,
        get: function() {
          return _v.default;
        }
      });
      Object.defineProperty(exports, "v3", {
        enumerable: true,
        get: function() {
          return _v2.default;
        }
      });
      Object.defineProperty(exports, "v4", {
        enumerable: true,
        get: function() {
          return _v3.default;
        }
      });
      Object.defineProperty(exports, "v5", {
        enumerable: true,
        get: function() {
          return _v4.default;
        }
      });
      var _v = _interopRequireDefault(require_v1());
      var _v2 = _interopRequireDefault(require_v3());
      var _v3 = _interopRequireDefault(require_v4());
      var _v4 = _interopRequireDefault(require_v5());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js
  var require_glsp_client = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPClient = exports.ClientState = exports.ApplicationIdProvider = void 0;
      var uuid = require_dist();
      var type_util_1 = require_type_util();
      var ApplicationIdProvider = class {
        static get() {
          if (!ApplicationIdProvider._applicationId) {
            ApplicationIdProvider._applicationId = uuid.v4();
          }
          return ApplicationIdProvider._applicationId;
        }
      };
      exports.ApplicationIdProvider = ApplicationIdProvider;
      var ClientState;
      (function(ClientState2) {
        ClientState2[ClientState2["Initial"] = 0] = "Initial";
        ClientState2[ClientState2["Starting"] = 1] = "Starting";
        ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
        ClientState2[ClientState2["Running"] = 3] = "Running";
        ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
        ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
        ClientState2[ClientState2["ServerError"] = 6] = "ServerError";
      })(ClientState || (exports.ClientState = ClientState = {}));
      var GLSPClient;
      (function(GLSPClient2) {
        function isOptions(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "id");
        }
        GLSPClient2.isOptions = isOptions;
        GLSPClient2.protocolVersion = "1.0.0";
      })(GLSPClient || (exports.GLSPClient = GLSPClient = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/base-glsp-client.js
  var require_base_glsp_client = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/base-glsp-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseGLSPClient = exports.GLOBAL_HANDLER_ID = void 0;
      var sprotty_protocol_1 = require_lib3();
      var vscode_jsonrpc_1 = require_main();
      var array_util_1 = require_array_util();
      var event_1 = require_event();
      var glsp_client_1 = require_glsp_client();
      exports.GLOBAL_HANDLER_ID = "*";
      var BaseGLSPClient = class {
        get onServerInitialized() {
          return this.onServerInitializedEmitter.event;
        }
        constructor(options) {
          this.options = options;
          this.serverDeferred = new sprotty_protocol_1.Deferred();
          this.onStartDeferred = new sprotty_protocol_1.Deferred();
          this.onStopDeferred = new sprotty_protocol_1.Deferred();
          this.startupTimeout = 1500;
          this.actionMessageHandlers = /* @__PURE__ */ new Map([[exports.GLOBAL_HANDLER_ID, []]]);
          this.onServerInitializedEmitter = new event_1.Emitter();
          this.state = glsp_client_1.ClientState.Initial;
          this.proxy = this.createProxy();
        }
        createProxy() {
          return {
            process: (message) => {
              var _a;
              const handlers = (_a = this.actionMessageHandlers.get(message.clientId)) !== null && _a !== void 0 ? _a : this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID);
              if (!handlers) {
                console.warn("No ActionMessageHandler is configured- Cannot process server message", message);
                return;
              }
              handlers.forEach((handler) => handler(message));
            }
          };
        }
        configureServer(server) {
          if (this.state === glsp_client_1.ClientState.Running) {
            throw new Error("Could not configure new server. The GLSPClient is already running");
          }
          this.serverDeferred.resolve(server);
        }
        start() {
          if (this.state === glsp_client_1.ClientState.Running) {
            return this.onStartDeferred.promise;
          }
          this.state = glsp_client_1.ClientState.Starting;
          const timeOut = new Promise((_, reject) => setTimeout(() => {
            reject(new Error("Could not start client. No server is configured"));
          }, this.startupTimeout));
          Promise.race([this.serverDeferred.promise, timeOut]).then((server) => {
            this._server = server;
            this.state = glsp_client_1.ClientState.Running;
            this.onStartDeferred.resolve();
          }).catch((error) => {
            this.state = glsp_client_1.ClientState.StartFailed;
            this.onStartDeferred.reject(error);
          });
          return this.onStartDeferred.promise;
        }
        async initializeServer(params) {
          if (!this._initializeResult) {
            this._initializeResult = await this.checkedServer.initialize(params);
            this.onServerInitializedEmitter.fire(this._initializeResult);
          }
          return this._initializeResult;
        }
        get initializeResult() {
          return this._initializeResult;
        }
        initializeClientSession(params) {
          return this.checkedServer.initializeClientSession(params);
        }
        disposeClientSession(params) {
          return this.checkedServer.disposeClientSession(params);
        }
        shutdownServer() {
          this.checkedServer.shutdown();
        }
        async stop() {
          if (this.state === glsp_client_1.ClientState.Stopped || this.state === glsp_client_1.ClientState.Stopping) {
            return this.onStop();
          }
          this.state = glsp_client_1.ClientState.Stopping;
          try {
            if (this._server) {
              this._server.shutdown();
            }
          } finally {
            this.state = glsp_client_1.ClientState.Stopped;
            this.onStopDeferred.resolve();
          }
        }
        sendActionMessage(message) {
          this.checkedServer.process(message);
        }
        onActionMessage(handler, clientId) {
          if (!clientId) {
            (0, array_util_1.distinctAdd)(this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID), handler);
            return vscode_jsonrpc_1.Disposable.create(() => (0, array_util_1.remove)(this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID), handler));
          }
          if (!this.actionMessageHandlers.has(clientId)) {
            this.actionMessageHandlers.set(clientId, [handler]);
          } else {
            (0, array_util_1.distinctAdd)(this.actionMessageHandlers.get(clientId), handler);
          }
          return vscode_jsonrpc_1.Disposable.create(() => (0, array_util_1.remove)(this.actionMessageHandlers.get(clientId), handler));
        }
        get currentState() {
          return this.state;
        }
        onStart() {
          return this.onStartDeferred.promise;
        }
        onStop() {
          return this.onStopDeferred.promise;
        }
        get id() {
          return this.options.id;
        }
        checkState() {
          if (this.state !== glsp_client_1.ClientState.Running) {
            throw new Error(`Client with id '${this.id}' is not in 'Running' state`);
          }
        }
        get checkedServer() {
          this.checkState();
          if (!this._server) {
            throw new Error(`No server is configured for GLSPClient with id '${this.id}'`);
          }
          return this._server;
        }
        setStartupTimeout(ms) {
          this.startupTimeout = ms;
        }
      };
      exports.BaseGLSPClient = BaseGLSPClient;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-server.js
  var require_glsp_server = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPClientProxy = exports.GLSPServerListener = exports.GLSPServer = void 0;
      exports.GLSPServer = Symbol("GLSPServer");
      exports.GLSPServerListener = Symbol("GLSPServerListener");
      exports.GLSPClientProxy = Symbol("GLSPClientProxy");
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js
  var require_glsp_jsonrpc_client = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsonrpcGLSPClient = void 0;
      var vscode_jsonrpc_1 = require_main();
      var glsp_client_1 = require_glsp_client();
      var JsonrpcGLSPClient;
      (function(JsonrpcGLSPClient2) {
        function isOptions(object) {
          return glsp_client_1.GLSPClient.isOptions(object) && "connectionProvider" in object;
        }
        JsonrpcGLSPClient2.isOptions = isOptions;
        JsonrpcGLSPClient2.ActionMessageNotification = new vscode_jsonrpc_1.NotificationType("process");
        JsonrpcGLSPClient2.InitializeRequest = new vscode_jsonrpc_1.RequestType("initialize");
        JsonrpcGLSPClient2.InitializeClientSessionRequest = new vscode_jsonrpc_1.RequestType("initializeClientSession");
        JsonrpcGLSPClient2.DisposeClientSessionRequest = new vscode_jsonrpc_1.RequestType("disposeClientSession");
        JsonrpcGLSPClient2.ShutdownNotification = new vscode_jsonrpc_1.NotificationType0("shutdown");
        JsonrpcGLSPClient2.ClientNotReadyMsg = "JsonrpcGLSPClient is not ready yet";
        function error(message, ...optionalParams) {
          console.error(`[JsonrpcGLSPClient] ${message}`, optionalParams);
        }
        JsonrpcGLSPClient2.error = error;
      })(JsonrpcGLSPClient || (exports.JsonrpcGLSPClient = JsonrpcGLSPClient = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/base-jsonrpc-glsp-client.js
  var require_base_jsonrpc_glsp_client = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/base-jsonrpc-glsp-client.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsonrpcClientProxy = exports.BaseJsonrpcGLSPClient = void 0;
      var inversify_1 = require_inversify();
      var event_1 = require_event();
      var glsp_client_1 = require_glsp_client();
      var glsp_jsonrpc_client_1 = require_glsp_jsonrpc_client();
      var BaseJsonrpcGLSPClient = class {
        get onServerInitialized() {
          return this.onServerInitializedEmitter.event;
        }
        constructor(options) {
          this.onServerInitializedEmitter = new event_1.Emitter();
          Object.assign(this, options);
          this.state = glsp_client_1.ClientState.Initial;
        }
        shutdownServer() {
          this.checkedConnection.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ShutdownNotification);
        }
        async initializeServer(params) {
          if (!this._initializeResult) {
            this._initializeResult = await this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest, params);
            this.onServerInitializedEmitter.fire(this._initializeResult);
          }
          return this._initializeResult;
        }
        get initializeResult() {
          return this._initializeResult;
        }
        initializeClientSession(params) {
          return this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeClientSessionRequest, params);
        }
        disposeClientSession(params) {
          return this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.DisposeClientSessionRequest, params);
        }
        onActionMessage(handler, clientId) {
          return this.checkedConnection.onNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, (msg) => {
            if (!clientId || msg.clientId === clientId) {
              handler(msg);
            }
          });
        }
        sendActionMessage(message) {
          this.checkedConnection.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, message);
        }
        get checkedConnection() {
          if (!this.isConnectionActive()) {
            throw new Error(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ClientNotReadyMsg);
          }
          return this.resolvedConnection;
        }
        async start() {
          if (this.state === glsp_client_1.ClientState.Running) {
            return;
          }
          try {
            this.state = glsp_client_1.ClientState.Starting;
            const connection = await this.resolveConnection();
            connection.listen();
            this.resolvedConnection = connection;
            this.state = glsp_client_1.ClientState.Running;
          } catch (error) {
            glsp_jsonrpc_client_1.JsonrpcGLSPClient.error("Failed to start connection to server", error);
            this.state = glsp_client_1.ClientState.StartFailed;
          }
        }
        stop() {
          if (!this.connectionPromise) {
            this.state = glsp_client_1.ClientState.Stopped;
            return Promise.resolve();
          }
          if (this.state === glsp_client_1.ClientState.Stopping && this.onStop) {
            return this.onStop;
          }
          this.state = glsp_client_1.ClientState.Stopping;
          return this.onStop = this.resolveConnection().then((connection) => {
            connection.dispose();
            this.state = glsp_client_1.ClientState.Stopped;
            this.onStop = void 0;
            this.connectionPromise = void 0;
            this.resolvedConnection = void 0;
          });
        }
        resolveConnection() {
          if (!this.connectionPromise) {
            this.connectionPromise = this.doCreateConnection();
          }
          return this.connectionPromise;
        }
        async doCreateConnection() {
          const connection = typeof this.connectionProvider === "function" ? await this.connectionProvider() : this.connectionProvider;
          connection.onError((data) => this.handleConnectionError(data[0], data[1], data[2]));
          connection.onClose(() => this.handleConnectionClosed());
          return connection;
        }
        handleConnectionError(error, message, count) {
          glsp_jsonrpc_client_1.JsonrpcGLSPClient.error("Connection to server is erroring. Shutting down server.", error);
          this.stop();
          this.state = glsp_client_1.ClientState.ServerError;
        }
        handleConnectionClosed() {
          if (this.state === glsp_client_1.ClientState.Stopping || this.state === glsp_client_1.ClientState.Stopped) {
            return;
          }
          try {
            if (this.resolvedConnection) {
              this.resolvedConnection.dispose();
              this.connectionPromise = void 0;
              this.resolvedConnection = void 0;
            }
          } catch (error) {
          }
          glsp_jsonrpc_client_1.JsonrpcGLSPClient.error("Connection to server got closed. Server will not be restarted.");
          this.state = glsp_client_1.ClientState.ServerError;
        }
        isConnectionActive() {
          return this.state === glsp_client_1.ClientState.Running && !!this.resolvedConnection;
        }
        get currentState() {
          return this.state;
        }
      };
      exports.BaseJsonrpcGLSPClient = BaseJsonrpcGLSPClient;
      var JsonrpcClientProxy = class JsonrpcClientProxy {
        initialize(clientConnection, enableLogging = false) {
          this.clientConnection = clientConnection;
          this.enableLogging = enableLogging;
        }
        process(message) {
          var _a;
          if (this.enableLogging) {
            console.log(`Send action '${message.action.kind}' to client '${message.clientId}'`);
          }
          (_a = this.clientConnection) === null || _a === void 0 ? void 0 : _a.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, message);
        }
      };
      exports.JsonrpcClientProxy = JsonrpcClientProxy;
      exports.JsonrpcClientProxy = JsonrpcClientProxy = __decorate([
        (0, inversify_1.injectable)()
      ], JsonrpcClientProxy);
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-server.js
  var require_glsp_jsonrpc_server = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureClientConnection = void 0;
      var glsp_jsonrpc_client_1 = require_glsp_jsonrpc_client();
      function configureClientConnection(clientConnection, glspServer) {
        clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest.method, (params) => glspServer.initialize(params));
        clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeClientSessionRequest, (params) => glspServer.initializeClientSession(params));
        clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.DisposeClientSessionRequest, (params) => glspServer.disposeClientSession(params));
        clientConnection.onNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, (message) => glspServer.process(message));
        clientConnection.listen();
      }
      exports.configureClientConnection = configureClientConnection;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/websocket-connection.js
  var require_websocket_connection = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/websocket-connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.listen = exports.createWebSocketConnection = exports.WebSocketMessageWriter = exports.WebSocketMessageReader = exports.wrap = void 0;
      var vscode_jsonrpc_1 = require_main();
      function wrap(socket) {
        return {
          send: (content) => socket.send(content),
          onMessage: (cb) => socket.onmessage = (event) => cb(event.data),
          onClose: (cb) => socket.onclose = (event) => cb(event.code, event.reason),
          onError: (cb) => socket.onerror = (event) => {
            if ("error" in event) {
              cb(event.error);
            }
          },
          dispose: () => socket.close()
        };
      }
      exports.wrap = wrap;
      var WebSocketMessageReader = class extends vscode_jsonrpc_1.AbstractMessageReader {
        constructor(socket) {
          super();
          this.socket = socket;
          this.state = "initial";
          this.eventQueue = [];
          this.socket.onMessage((message) => this.handleMessage(message));
          this.socket.onError((error) => this.fireError(error));
          this.socket.onClose(() => this.fireClose());
        }
        listen(callback) {
          if (this.state === "initial") {
            this.state = "listening";
            this.callback = callback;
            this.eventQueue.forEach((event) => {
              if (event.message) {
                this.handleMessage(event.message);
              } else if (event.error) {
                this.fireError(event.error);
              } else {
                this.fireClose();
              }
            });
            this.eventQueue = [];
          }
          return vscode_jsonrpc_1.Disposable.create(() => {
            this.callback = void 0;
            this.eventQueue = [];
          });
        }
        handleMessage(message) {
          if (this.state === "initial") {
            this.eventQueue.push({ message });
          } else if (this.state === "listening") {
            const data = JSON.parse(message);
            this.callback(data);
          }
        }
        fireError(error) {
          if (this.state === "initial") {
            this.eventQueue.push({ error });
          } else if (this.state === "listening") {
            super.fireError(error);
          }
        }
        fireClose() {
          if (this.state === "initial") {
            this.eventQueue.push({});
          } else if (this.state === "listening") {
            super.fireClose();
          }
          this.state = "closed";
        }
      };
      exports.WebSocketMessageReader = WebSocketMessageReader;
      var WebSocketMessageWriter = class extends vscode_jsonrpc_1.AbstractMessageWriter {
        constructor(socket) {
          super();
          this.socket = socket;
          this.errorCount = 0;
        }
        end() {
        }
        async write(msg) {
          try {
            const content = JSON.stringify(msg);
            this.socket.send(content);
          } catch (e) {
            this.errorCount++;
            this.fireError(e, msg, this.errorCount);
          }
        }
      };
      exports.WebSocketMessageWriter = WebSocketMessageWriter;
      function createWebSocketConnection(socket, logger) {
        const reader = new WebSocketMessageReader(socket);
        const writer = new WebSocketMessageWriter(socket);
        return (0, vscode_jsonrpc_1.createMessageConnection)(reader, writer, logger);
      }
      exports.createWebSocketConnection = createWebSocketConnection;
      function listen(webSocket, onConnection, logger) {
        return new Promise((resolve) => {
          webSocket.onopen = () => {
            const socket = wrap(webSocket);
            const connection = createWebSocketConnection(socket, logger);
            onConnection === null || onConnection === void 0 ? void 0 : onConnection(connection);
            resolve(connection);
          };
        });
      }
      exports.listen = listen;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/ws-connection-provider.js
  var require_ws_connection_provider = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/ws-connection-provider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPWebSocketProvider = exports.GLSPConnectionHandler = void 0;
      var websocket_connection_1 = require_websocket_connection();
      exports.GLSPConnectionHandler = Symbol("GLSPConnectionHandler");
      var GLSPWebSocketProvider = class {
        constructor(url, options) {
          this.url = url;
          this.reconnectAttempts = 0;
          this.options = {
            // default values
            reconnecting: true,
            reconnectAttempts: Infinity,
            reconnectDelay: 1e3
          };
          this.options = Object.assign(this.options, options);
        }
        createWebSocket(url) {
          return new WebSocket(url);
        }
        listen(handler, isReconnecting = false) {
          this.webSocket = this.createWebSocket(this.url);
          this.webSocket.onerror = () => {
            var _a;
            (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.error("GLSPWebSocketProvider Connection to server errored. Please make sure that the server is running!");
            clearInterval(this.reconnectTimer);
            this.webSocket.close();
          };
          return new Promise((resolve) => {
            this.webSocket.onopen = () => {
              var _a, _b, _c, _d;
              clearInterval(this.reconnectTimer);
              const wrappedSocket = (0, websocket_connection_1.wrap)(this.webSocket);
              const wsConnection = (0, websocket_connection_1.createWebSocketConnection)(wrappedSocket, handler.logger);
              this.webSocket.onclose = () => {
                var _a2, _b2;
                const { reconnecting, reconnectAttempts, reconnectDelay } = this.options;
                if (reconnecting) {
                  if (this.reconnectAttempts >= reconnectAttempts) {
                    (_a2 = handler.logger) === null || _a2 === void 0 ? void 0 : _a2.error(`GLSPWebSocketProvider WebSocket reconnect failed - maximum number reconnect attempts (${reconnectAttempts}) was exceeded!`);
                  } else {
                    this.reconnectTimer = setInterval(() => {
                      var _a3;
                      (_a3 = handler.logger) === null || _a3 === void 0 ? void 0 : _a3.warn("GLSPWebSocketProvider reconnecting...");
                      this.listen(handler, true);
                      this.reconnectAttempts++;
                    }, reconnectDelay);
                  }
                } else {
                  (_b2 = handler.logger) === null || _b2 === void 0 ? void 0 : _b2.error("GLSPWebSocketProvider WebSocket will not reconnect - closing the connection now!");
                }
              };
              if (isReconnecting) {
                (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.warn("GLSPWebSocketProvider Reconnecting!");
                (_b = handler.onReconnect) === null || _b === void 0 ? void 0 : _b.call(handler, wsConnection);
              } else {
                (_c = handler.logger) === null || _c === void 0 ? void 0 : _c.warn("GLSPWebSocketProvider Initializing!");
                (_d = handler.onConnection) === null || _d === void 0 ? void 0 : _d.call(handler, wsConnection);
              }
              resolve(wsConnection);
            };
          });
        }
      };
      exports.GLSPWebSocketProvider = GLSPWebSocketProvider;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/types.js
  var require_types3 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/model/default-types.js
  var require_default_types = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/model/default-types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultTypes = void 0;
      var DefaultTypes3;
      (function(DefaultTypes4) {
        DefaultTypes4.HTML = "html";
        DefaultTypes4.FOREIGN_OBJECT = "foreign-object";
        DefaultTypes4.PRE_RENDERED = "pre-rendered";
        DefaultTypes4.SHAPE_PRE_RENDERED = "shape-pre-rendered";
        DefaultTypes4.SVG = "svg";
        DefaultTypes4.GRAPH = "graph";
        DefaultTypes4.NODE = "node";
        DefaultTypes4.COMPARTMENT = "comp";
        DefaultTypes4.COMPARTMENT_HEADER = "comp:header";
        DefaultTypes4.EDGE = "edge";
        DefaultTypes4.PORT = "port";
        DefaultTypes4.ROUTING_POINT = "routing-point";
        DefaultTypes4.VOLATILE_ROUTING_POINT = `volatile-${DefaultTypes4.ROUTING_POINT}`;
        DefaultTypes4.LABEL = "label";
        DefaultTypes4.BUTTON = "button";
        DefaultTypes4.BUTTON_EXPAND = "button:expand";
        DefaultTypes4.ISSUE_MARKER = "marker";
        DefaultTypes4.NODE_CIRCLE = "node:circle";
        DefaultTypes4.NODE_RECTANGLE = "node:rectangle";
        DefaultTypes4.NODE_DIAMOND = "node:diamond";
      })(DefaultTypes3 || (exports.DefaultTypes = DefaultTypes3 = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/model/model-schema.js
  var require_model_schema = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/model/model-schema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isGModelElementSchema = void 0;
      var type_util_1 = require_type_util();
      function isGModelElementSchema(object) {
        return typeof object === "object" && (0, type_util_1.hasStringProp)(object, "type") && (0, type_util_1.hasStringProp)(object, "id");
      }
      exports.isGModelElementSchema = isGModelElementSchema;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/sprotty-actions.js
  var require_sprotty_actions = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/sprotty-actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportResult = exports.SetViewportAction = exports.SetBoundsAction = exports.SelectionResult = exports.OpenAction = exports.MoveAction = exports.HoverFeedbackAction = exports.GetViewportAction = exports.GetSelectionAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.BringToFrontAction = void 0;
      var actions_1 = require_actions2();
      Object.defineProperty(exports, "BringToFrontAction", { enumerable: true, get: function() {
        return actions_1.BringToFrontAction;
      } });
      Object.defineProperty(exports, "CollapseExpandAction", { enumerable: true, get: function() {
        return actions_1.CollapseExpandAction;
      } });
      Object.defineProperty(exports, "CollapseExpandAllAction", { enumerable: true, get: function() {
        return actions_1.CollapseExpandAllAction;
      } });
      Object.defineProperty(exports, "GetSelectionAction", { enumerable: true, get: function() {
        return actions_1.GetSelectionAction;
      } });
      Object.defineProperty(exports, "GetViewportAction", { enumerable: true, get: function() {
        return actions_1.GetViewportAction;
      } });
      Object.defineProperty(exports, "HoverFeedbackAction", { enumerable: true, get: function() {
        return actions_1.HoverFeedbackAction;
      } });
      Object.defineProperty(exports, "MoveAction", { enumerable: true, get: function() {
        return actions_1.MoveAction;
      } });
      Object.defineProperty(exports, "OpenAction", { enumerable: true, get: function() {
        return actions_1.OpenAction;
      } });
      Object.defineProperty(exports, "SelectionResult", { enumerable: true, get: function() {
        return actions_1.SelectionResult;
      } });
      Object.defineProperty(exports, "SetBoundsAction", { enumerable: true, get: function() {
        return actions_1.SetBoundsAction;
      } });
      Object.defineProperty(exports, "SetViewportAction", { enumerable: true, get: function() {
        return actions_1.SetViewportAction;
      } });
      Object.defineProperty(exports, "ViewportResult", { enumerable: true, get: function() {
        return actions_1.ViewportResult;
      } });
      var base_protocol_1 = require_base_protocol();
      var type_util_1 = require_type_util();
      actions_1.CollapseExpandAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.CollapseExpandAction.KIND) && (0, type_util_1.hasArrayProp)(object, "expandIds") && (0, type_util_1.hasArrayProp)(object, "collapseIds");
      actions_1.CollapseExpandAllAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.CollapseExpandAllAction.KIND) && (0, type_util_1.hasBooleanProp)(object, "expand");
      actions_1.GetSelectionAction.is = (object) => base_protocol_1.RequestAction.hasKind(object, actions_1.GetSelectionAction.KIND);
      actions_1.GetViewportAction.is = (object) => base_protocol_1.RequestAction.hasKind(object, actions_1.GetViewportAction.KIND);
      actions_1.HoverFeedbackAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.HoverFeedbackAction.KIND) && (0, type_util_1.hasStringProp)(object, "mouseoverElement") && (0, type_util_1.hasBooleanProp)(object, "mouseIsOver");
      actions_1.MoveAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.MoveAction.KIND) && (0, type_util_1.hasArrayProp)(object, "moves") && (0, type_util_1.hasBooleanProp)(object, "animate") && (0, type_util_1.hasBooleanProp)(object, "finished");
      actions_1.OpenAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.OpenAction.KIND) && (0, type_util_1.hasStringProp)(object, "elementId");
      actions_1.SelectionResult.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SelectionResult.KIND) && (0, type_util_1.hasArrayProp)(object, "selectedElementsIDs");
      actions_1.SetBoundsAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SetBoundsAction.KIND) && (0, type_util_1.hasObjectProp)(object, "bounds");
      actions_1.SetViewportAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SetViewportAction.KIND) && (0, type_util_1.hasStringProp)(object, "elementId") && (0, type_util_1.hasObjectProp)(object, "newViewport") && (0, type_util_1.hasBooleanProp)(object, "animate");
      actions_1.ViewportResult.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.ViewportResult.KIND) && (0, type_util_1.hasObjectProp)(object, "viewport") && (0, type_util_1.hasObjectProp)(object, "canvasBounds");
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/di-util.js
  var require_di_util = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/di-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindAsService = exports.lazyBind = exports.bindOrRebind = exports.FeatureModule = exports.resolveContainerConfiguration = exports.initializeContainer = void 0;
      var inversify_1 = require_inversify();
      var array_util_1 = require_array_util();
      var type_util_1 = require_type_util();
      function initializeContainer(container, ...containerConfigurations) {
        const modules = resolveContainerConfiguration(...containerConfigurations);
        container.load(...modules);
        return container;
      }
      exports.initializeContainer = initializeContainer;
      function resolveContainerConfiguration(...containerConfigurations) {
        const modules = [];
        containerConfigurations.forEach((config) => {
          if (isContainerModule(config)) {
            (0, array_util_1.distinctAdd)(modules, config);
          } else {
            if (config.remove) {
              (0, array_util_1.remove)(modules, ...(0, array_util_1.asArray)(config.remove));
            }
            if (config.add) {
              (0, array_util_1.distinctAdd)(modules, ...(0, array_util_1.asArray)(config.add));
            }
          }
        });
        return modules;
      }
      exports.resolveContainerConfiguration = resolveContainerConfiguration;
      function isContainerModule(config) {
        return (0, type_util_1.hasNumberProp)(config, "id") && (0, type_util_1.hasFunctionProp)(config, "registry");
      }
      var FeatureModule = class extends inversify_1.ContainerModule {
        constructor(registry, options = {}) {
          var _a;
          super((bind, unbind, isBound, ...rest) => {
            if (this.configure(bind, isBound)) {
              registry(bind, unbind, isBound, ...rest);
            }
          });
          this.featureId = (_a = options.featureId) !== null && _a !== void 0 ? _a : this.createFeatureId();
          this.requires = options.requires;
        }
        createFeatureId() {
          return Symbol(this.id);
        }
        /**
         * Configures the feature module i.e. checks if the requirements are met.
         * If this is the case the {@link FeatureModule.featureId} will be bound and the module will be loaded
         * @param bind container bind function
         * @param isBound container isBound function
         * @returns `true` if all requirements are met and the module is loaded. `false` otherwise
         */
        configure(bind, isBound) {
          if (this.checkRequirements(isBound)) {
            bind(this.featureId).toConstantValue(this.featureId);
            return true;
          }
          return false;
        }
        /**
         * Checks if all required {@link FeatureModule}s are already loaded/bound in the container.
         * @param isBound The `isBound` property of the module callback. Used to check the required modules.
         * @returns `true` if all requirements are met, `false` otherwise
         */
        checkRequirements(isBound) {
          return this.requires ? (0, array_util_1.asArray)(this.requires).every((module2) => isBound(module2.featureId)) : true;
        }
        isLoaded(context) {
          return context.isBound(this.featureId);
        }
      };
      exports.FeatureModule = FeatureModule;
      function bindOrRebind(context, serviceIdentifier) {
        if (context.isBound(serviceIdentifier)) {
          return context.rebind(serviceIdentifier);
        }
        return context.bind(serviceIdentifier);
      }
      exports.bindOrRebind = bindOrRebind;
      function lazyBind(context, serviceIdentifier) {
        if (context.isBound(serviceIdentifier)) {
          return void 0;
        }
        return context.bind(serviceIdentifier);
      }
      exports.lazyBind = lazyBind;
      function bindAsService2(context, serviceIdentifier, targetService) {
        const bind = typeof context === "object" ? context.bind.bind(context) : context;
        bind(targetService).toSelf().inSingletonScope();
        bind(serviceIdentifier).toService(targetService);
      }
      exports.bindAsService = bindAsService2;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/disposable.js
  var require_disposable2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DisposableCollection = exports.Disposable = void 0;
      var array_util_1 = require_array_util();
      var type_util_1 = require_type_util();
      var Disposable;
      (function(Disposable2) {
        function is(value) {
          return type_util_1.AnyObject.is(value) && (0, type_util_1.hasFunctionProp)(value, "dispose");
        }
        Disposable2.is = is;
        function empty() {
          return { dispose: () => {
          } };
        }
        Disposable2.empty = empty;
        function create(cb) {
          return { dispose: cb };
        }
        Disposable2.create = create;
      })(Disposable || (exports.Disposable = Disposable = {}));
      var DisposableCollection = class {
        constructor(...toDispose) {
          this.disposables = [];
          toDispose.forEach((d) => this.push(d));
          this.errorHandler = (err) => console.error(err);
        }
        dispose() {
          var _a, _b;
          if (this.disposed) {
            return;
          }
          try {
            while (!this.disposed) {
              (_a = this.disposables.pop()) === null || _a === void 0 ? void 0 : _a.dispose();
            }
          } catch (err) {
            (_b = this.errorHandler) === null || _b === void 0 ? void 0 : _b.call(this, err);
          }
        }
        get disposed() {
          return this.disposables.length === 0;
        }
        /**
         * Pushes the given disposables to the collection.
         * @param disposables The disposables that should be added
         * @returns A disposable that removes the previously pushed values from the collection when invoked
         */
        push(...disposables) {
          this.disposables.push(...disposables);
          return Disposable.create(() => (0, array_util_1.remove)(this.disposables, ...disposables));
        }
        get isDisposed() {
          return this.disposed;
        }
      };
      exports.DisposableCollection = DisposableCollection;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSubType = exports.getBasicType = exports.findElement = exports.cloneModel = exports.applyBounds = void 0;
      __exportStar(require_async3(), exports);
      __exportStar(require_geometry3(), exports);
      __exportStar(require_json2(), exports);
      var model_utils_1 = require_model_utils2();
      Object.defineProperty(exports, "applyBounds", { enumerable: true, get: function() {
        return model_utils_1.applyBounds;
      } });
      Object.defineProperty(exports, "cloneModel", { enumerable: true, get: function() {
        return model_utils_1.cloneModel;
      } });
      Object.defineProperty(exports, "findElement", { enumerable: true, get: function() {
        return model_utils_1.findElement;
      } });
      Object.defineProperty(exports, "getBasicType", { enumerable: true, get: function() {
        return model_utils_1.getBasicType;
      } });
      Object.defineProperty(exports, "getSubType", { enumerable: true, get: function() {
        return model_utils_1.getSubType;
      } });
      __exportStar(require_action_protocol(), exports);
      __exportStar(require_base_glsp_client(), exports);
      __exportStar(require_glsp_client(), exports);
      __exportStar(require_glsp_server(), exports);
      __exportStar(require_base_jsonrpc_glsp_client(), exports);
      __exportStar(require_glsp_jsonrpc_client(), exports);
      __exportStar(require_glsp_jsonrpc_server(), exports);
      __exportStar(require_websocket_connection(), exports);
      __exportStar(require_ws_connection_provider(), exports);
      __exportStar(require_types3(), exports);
      __exportStar(require_default_types(), exports);
      __exportStar(require_model_schema(), exports);
      __exportStar(require_sprotty_actions(), exports);
      __exportStar(require_array_util(), exports);
      __exportStar(require_di_util(), exports);
      __exportStar(require_disposable2(), exports);
      __exportStar(require_event(), exports);
      __exportStar(require_type_util(), exports);
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/action-override.js
  var require_action_override = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/action-override.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MouseListener = exports.KeyListener = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib2();
      var KeyListener = class KeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          return [];
        }
        keyUp(element, event) {
          return [];
        }
      };
      exports.KeyListener = KeyListener;
      exports.KeyListener = KeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], KeyListener);
      var MouseListener2 = class MouseListener extends sprotty_1.MouseListener {
        mouseOver(target, event) {
          return [];
        }
        mouseOut(target, event) {
          return [];
        }
        mouseEnter(target, event) {
          return [];
        }
        mouseLeave(target, event) {
          return [];
        }
        mouseDown(target, event) {
          return [];
        }
        mouseMove(target, event) {
          return [];
        }
        mouseUp(target, event) {
          return [];
        }
        wheel(target, event) {
          return [];
        }
        doubleClick(target, event) {
          return [];
        }
        contextMenu(target, event) {
          return [];
        }
        dragOver(target, event) {
          return [];
        }
        drop(target, event) {
          return [];
        }
        decorate(vnode, element) {
          return vnode;
        }
      };
      exports.MouseListener = MouseListener2;
      exports.MouseListener = MouseListener2 = __decorate([
        (0, inversify_1.injectable)()
      ], MouseListener2);
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/types.js
  var require_types4 = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TYPES = void 0;
      var sprotty_1 = require_lib2();
      exports.TYPES = Object.assign(Object.assign({}, sprotty_1.TYPES), { IAsyncClipboardService: Symbol("IAsyncClipboardService"), IEditorContextServiceProvider: Symbol("IEditorContextProvider"), IFeedbackActionDispatcher: Symbol("IFeedbackActionDispatcher"), IToolFactory: Symbol("Factory<Tool>"), ITypeHintProvider: Symbol("ITypeHintProvider"), IMovementRestrictor: Symbol("IMovementRestrictor"), ISelectionListener: Symbol("ISelectionListener"), ISModelRootListener: Symbol("ISModelRootListener"), IContextMenuProvider: Symbol("IContextMenuProvider"), ICopyPasteHandler: Symbol("ICopyPasteHandler"), ITool: Symbol("ITool"), IDefaultTool: Symbol("IDefaultTool"), IEditModeListener: Symbol("IEditModeListener"), IMarqueeBehavior: Symbol("IMarqueeBehavior"), IElementNavigator: Symbol("IElementNavigator"), ILocalElementNavigator: Symbol("ILocalElementNavigator"), IDiagramOptions: Symbol("IDiagramOptions"), IDiagramStartup: Symbol("IDiagramStartup"), IToolManager: Symbol("IToolManager") });
    }
  });

  // node_modules/sprotty/lib/features/bounds/layout-options.js
  var require_layout_options = __commonJS({
    "node_modules/sprotty/lib/features/bounds/layout-options.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/feature-modules.js
  var require_feature_modules = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/feature-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sprottyDefaultModule = exports.zorderModule = exports.updateModule = exports.openModule = exports.moveModule = exports.modelSourceModule = exports.labelEditUiModule = exports.fadeModule = exports.expandModule = exports.edgeLayoutModule = exports.edgeIntersectionModule = exports.edgeEditModule = exports.buttonModule = void 0;
      var protocol_1 = require_lib4();
      var di_config_1 = require_di_config5();
      var di_config_2 = require_di_config9();
      var di_config_3 = require_di_config2();
      var di_config_4 = require_di_config3();
      var di_config_5 = require_di_config10();
      var di_config_6 = require_di_config12();
      var di_config_7 = require_di_config14();
      var di_config_8 = require_di_config19();
      var di_config_9 = require_di_config21();
      var di_config_10 = require_di_config22();
      var di_config_11 = require_di_config();
      exports.sprottyDefaultModule = di_config_11.default;
      var di_config_12 = require_di_config15();
      exports.buttonModule = new protocol_1.FeatureModule(di_config_1.default.registry);
      exports.edgeEditModule = new protocol_1.FeatureModule(di_config_4.edgeEditModule.registry);
      exports.edgeIntersectionModule = new protocol_1.FeatureModule(di_config_2.default.registry);
      exports.edgeLayoutModule = new protocol_1.FeatureModule(di_config_3.default.registry);
      exports.expandModule = new protocol_1.FeatureModule(di_config_5.default.registry);
      exports.fadeModule = new protocol_1.FeatureModule(di_config_6.default.registry);
      exports.labelEditUiModule = new protocol_1.FeatureModule(di_config_4.labelEditUiModule.registry);
      exports.modelSourceModule = new protocol_1.FeatureModule(di_config_10.default.registry);
      exports.moveModule = new protocol_1.FeatureModule(di_config_7.default.registry);
      exports.openModule = new protocol_1.FeatureModule(di_config_12.default.registry);
      exports.updateModule = new protocol_1.FeatureModule(di_config_8.default.registry);
      exports.zorderModule = new protocol_1.FeatureModule(di_config_9.default.registry);
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.edgeInProgressID = exports.connectableFeature = exports.GRoutingHandle = exports.GRoutableElement = exports.GDanglingAnchor = exports.GConnectableElement = exports.SIssueMarker = exports.GIssue = exports.GDecoration = exports.SvgExporter = exports.ExportSvgPostprocessor = exports.ExportSvgKeyListener = exports.ExportSvgCommand = exports.DeleteContextMenuItemProvider = exports.ContextMenuProviderRegistry = exports.RevealNamedElementActionProvider = exports.CommandPaletteActionProviderRegistry = exports.GButton = exports.configureButtonHandler = exports.ButtonHandlerRegistry = exports.layoutableChildFeature = exports.layoutContainerFeature = exports.isSizeable = exports.isLayoutableChild = exports.isLayoutContainer = exports.isBoundsAware = exports.isAlignable = exports.getAbsoluteClientBounds = exports.getAbsoluteBounds = exports.findChildrenAtPosition = exports.boundsFeature = exports.GShapeElement = exports.PopupMouseTool = exports.MouseTool = exports.MousePositionTracker = exports.KeyTool = exports.createFeatureSet = exports.SModelRegistry = exports.GModelFactory = exports.EMPTY_ROOT = exports.isParent = exports.createRandomId = exports.ModelIndexImpl = exports.GParentElement = exports.GModelRoot = exports.GModelElement = exports.GChildElement = exports.onAction = exports.configureActionHandler = exports.ActionHandlerRegistry = void 0;
      exports.RectangularPort = exports.RectangularNode = exports.GShapedPreRenderedElement = exports.GPreRenderedElement = exports.GHtmlRoot = exports.GForeignObjectElement = exports.DiamondNode = exports.CircularPort = exports.CircularNode = exports.PolylineEdgeViewWithGapsOnIntersections = exports.PolylineEdgeView = exports.JumpingPolylineEdgeView = exports.GRoutingHandleView = exports.GLabelView = exports.GGraphView = exports.GCompartmentView = exports.GBezierCreateHandleView = exports.GBezierControlHandleView = exports.BezierCurveEdgeView = exports.SGraphImpl = exports.SEdgeImpl = exports.GPort = exports.GNode = exports.GLabel = exports.GGraphIndex = exports.GCompartment = exports.GViewportRootElement = exports.SprottySelectCommand = exports.SprottySelectAllCommand = exports.SelectMouseListener = exports.SelectKeyboardListener = exports.GetSelectionCommand = exports.isConnectable = exports.getRouteBounds = exports.getAbsoluteRouteBounds = exports.edgeInProgressTargetHandleID = void 0;
      __exportStar(require_lib4(), exports);
      __exportStar(require_action_override(), exports);
      __exportStar(require_action_dispatcher(), exports);
      var action_handler_1 = require_action_handler();
      Object.defineProperty(exports, "ActionHandlerRegistry", { enumerable: true, get: function() {
        return action_handler_1.ActionHandlerRegistry;
      } });
      Object.defineProperty(exports, "configureActionHandler", { enumerable: true, get: function() {
        return action_handler_1.configureActionHandler;
      } });
      Object.defineProperty(exports, "onAction", { enumerable: true, get: function() {
        return action_handler_1.onAction;
      } });
      __exportStar(require_diagram_locker(), exports);
      __exportStar(require_animation(), exports);
      __exportStar(require_animation_frame_syncer(), exports);
      __exportStar(require_easing(), exports);
      __exportStar(require_command(), exports);
      __exportStar(require_command_registration(), exports);
      __exportStar(require_command_stack(), exports);
      __exportStar(require_command_stack_options(), exports);
      __exportStar(require_initialize_canvas(), exports);
      __exportStar(require_set_model(), exports);
      var smodel_1 = require_smodel();
      Object.defineProperty(exports, "GChildElement", { enumerable: true, get: function() {
        return smodel_1.SChildElementImpl;
      } });
      Object.defineProperty(exports, "GModelElement", { enumerable: true, get: function() {
        return smodel_1.SModelElementImpl;
      } });
      Object.defineProperty(exports, "GModelRoot", { enumerable: true, get: function() {
        return smodel_1.SModelRootImpl;
      } });
      Object.defineProperty(exports, "GParentElement", { enumerable: true, get: function() {
        return smodel_1.SParentElementImpl;
      } });
      Object.defineProperty(exports, "ModelIndexImpl", { enumerable: true, get: function() {
        return smodel_1.ModelIndexImpl;
      } });
      Object.defineProperty(exports, "createRandomId", { enumerable: true, get: function() {
        return smodel_1.createRandomId;
      } });
      Object.defineProperty(exports, "isParent", { enumerable: true, get: function() {
        return smodel_1.isParent;
      } });
      var smodel_factory_1 = require_smodel_factory();
      Object.defineProperty(exports, "EMPTY_ROOT", { enumerable: true, get: function() {
        return smodel_factory_1.EMPTY_ROOT;
      } });
      Object.defineProperty(exports, "GModelFactory", { enumerable: true, get: function() {
        return smodel_factory_1.SModelFactory;
      } });
      Object.defineProperty(exports, "SModelRegistry", { enumerable: true, get: function() {
        return smodel_factory_1.SModelRegistry;
      } });
      Object.defineProperty(exports, "createFeatureSet", { enumerable: true, get: function() {
        return smodel_factory_1.createFeatureSet;
      } });
      __exportStar(require_smodel_utils(), exports);
      __exportStar(require_ui_extension(), exports);
      __exportStar(require_ui_extension_registry(), exports);
      __exportStar(require_dom_helper(), exports);
      var key_tool_1 = require_key_tool();
      Object.defineProperty(exports, "KeyTool", { enumerable: true, get: function() {
        return key_tool_1.KeyTool;
      } });
      var mouse_tool_1 = require_mouse_tool();
      Object.defineProperty(exports, "MousePositionTracker", { enumerable: true, get: function() {
        return mouse_tool_1.MousePositionTracker;
      } });
      Object.defineProperty(exports, "MouseTool", { enumerable: true, get: function() {
        return mouse_tool_1.MouseTool;
      } });
      Object.defineProperty(exports, "PopupMouseTool", { enumerable: true, get: function() {
        return mouse_tool_1.PopupMouseTool;
      } });
      __exportStar(require_thunk_view(), exports);
      __exportStar(require_view(), exports);
      __exportStar(require_viewer(), exports);
      __exportStar(require_viewer_cache(), exports);
      __exportStar(require_viewer_options(), exports);
      __exportStar(require_vnode_postprocessor(), exports);
      __exportStar(require_vnode_utils(), exports);
      __exportStar(require_types4(), exports);
      __exportStar(require_abstract_layout(), exports);
      __exportStar(require_bounds_manipulation(), exports);
      __exportStar(require_hbox_layout(), exports);
      __exportStar(require_hidden_bounds_updater(), exports);
      __exportStar(require_layout(), exports);
      __exportStar(require_layout_options(), exports);
      var model_1 = require_model2();
      Object.defineProperty(exports, "GShapeElement", { enumerable: true, get: function() {
        return model_1.SShapeElementImpl;
      } });
      Object.defineProperty(exports, "boundsFeature", { enumerable: true, get: function() {
        return model_1.boundsFeature;
      } });
      Object.defineProperty(exports, "findChildrenAtPosition", { enumerable: true, get: function() {
        return model_1.findChildrenAtPosition;
      } });
      Object.defineProperty(exports, "getAbsoluteBounds", { enumerable: true, get: function() {
        return model_1.getAbsoluteBounds;
      } });
      Object.defineProperty(exports, "getAbsoluteClientBounds", { enumerable: true, get: function() {
        return model_1.getAbsoluteClientBounds;
      } });
      Object.defineProperty(exports, "isAlignable", { enumerable: true, get: function() {
        return model_1.isAlignable;
      } });
      Object.defineProperty(exports, "isBoundsAware", { enumerable: true, get: function() {
        return model_1.isBoundsAware;
      } });
      Object.defineProperty(exports, "isLayoutContainer", { enumerable: true, get: function() {
        return model_1.isLayoutContainer;
      } });
      Object.defineProperty(exports, "isLayoutableChild", { enumerable: true, get: function() {
        return model_1.isLayoutableChild;
      } });
      Object.defineProperty(exports, "isSizeable", { enumerable: true, get: function() {
        return model_1.isSizeable;
      } });
      Object.defineProperty(exports, "layoutContainerFeature", { enumerable: true, get: function() {
        return model_1.layoutContainerFeature;
      } });
      Object.defineProperty(exports, "layoutableChildFeature", { enumerable: true, get: function() {
        return model_1.layoutableChildFeature;
      } });
      __exportStar(require_vbox_layout(), exports);
      __exportStar(require_views(), exports);
      var button_handler_1 = require_button_handler();
      Object.defineProperty(exports, "ButtonHandlerRegistry", { enumerable: true, get: function() {
        return button_handler_1.ButtonHandlerRegistry;
      } });
      Object.defineProperty(exports, "configureButtonHandler", { enumerable: true, get: function() {
        return button_handler_1.configureButtonHandler;
      } });
      var model_2 = require_model4();
      Object.defineProperty(exports, "GButton", { enumerable: true, get: function() {
        return model_2.SButtonImpl;
      } });
      var action_providers_1 = require_action_providers();
      Object.defineProperty(exports, "CommandPaletteActionProviderRegistry", { enumerable: true, get: function() {
        return action_providers_1.CommandPaletteActionProviderRegistry;
      } });
      Object.defineProperty(exports, "RevealNamedElementActionProvider", { enumerable: true, get: function() {
        return action_providers_1.RevealNamedElementActionProvider;
      } });
      __exportStar(require_command_palette(), exports);
      var menu_providers_1 = require_menu_providers();
      Object.defineProperty(exports, "ContextMenuProviderRegistry", { enumerable: true, get: function() {
        return menu_providers_1.ContextMenuProviderRegistry;
      } });
      Object.defineProperty(exports, "DeleteContextMenuItemProvider", { enumerable: true, get: function() {
        return menu_providers_1.DeleteContextMenuItemProvider;
      } });
      __exportStar(require_mouse_listener(), exports);
      __exportStar(require_di_config2(), exports);
      __exportStar(require_edge_layout(), exports);
      __exportStar(require_model10(), exports);
      __exportStar(require_delete(), exports);
      __exportStar(require_edit_label(), exports);
      __exportStar(require_edit_label_ui(), exports);
      __exportStar(require_edit_routing(), exports);
      __exportStar(require_model11(), exports);
      __exportStar(require_expand(), exports);
      __exportStar(require_model14(), exports);
      __exportStar(require_views2(), exports);
      var export_1 = require_export();
      Object.defineProperty(exports, "ExportSvgCommand", { enumerable: true, get: function() {
        return export_1.ExportSvgCommand;
      } });
      Object.defineProperty(exports, "ExportSvgKeyListener", { enumerable: true, get: function() {
        return export_1.ExportSvgKeyListener;
      } });
      Object.defineProperty(exports, "ExportSvgPostprocessor", { enumerable: true, get: function() {
        return export_1.ExportSvgPostprocessor;
      } });
      __exportStar(require_model13(), exports);
      var svg_exporter_1 = require_svg_exporter();
      Object.defineProperty(exports, "SvgExporter", { enumerable: true, get: function() {
        return svg_exporter_1.SvgExporter;
      } });
      __exportStar(require_fade(), exports);
      __exportStar(require_model3(), exports);
      __exportStar(require_hover(), exports);
      __exportStar(require_model7(), exports);
      __exportStar(require_popup_position_updater(), exports);
      __exportStar(require_decoration_placer(), exports);
      var model_3 = require_model15();
      Object.defineProperty(exports, "GDecoration", { enumerable: true, get: function() {
        return model_3.SDecoration;
      } });
      Object.defineProperty(exports, "GIssue", { enumerable: true, get: function() {
        return model_3.SIssue;
      } });
      Object.defineProperty(exports, "SIssueMarker", { enumerable: true, get: function() {
        return model_3.SIssueMarker;
      } });
      __exportStar(require_views3(), exports);
      __exportStar(require_intersection_finder(), exports);
      __exportStar(require_sweepline(), exports);
      __exportStar(require_model8(), exports);
      __exportStar(require_move(), exports);
      __exportStar(require_snap(), exports);
      __exportStar(require_model5(), exports);
      __exportStar(require_model16(), exports);
      __exportStar(require_open(), exports);
      __exportStar(require_model17(), exports);
      __exportStar(require_views4(), exports);
      __exportStar(require_abstract_edge_router(), exports);
      __exportStar(require_anchor(), exports);
      __exportStar(require_bezier_anchors(), exports);
      __exportStar(require_bezier_edge_router(), exports);
      __exportStar(require_manhattan_anchors(), exports);
      __exportStar(require_manhattan_edge_router(), exports);
      var model_4 = require_model9();
      Object.defineProperty(exports, "GConnectableElement", { enumerable: true, get: function() {
        return model_4.SConnectableElementImpl;
      } });
      Object.defineProperty(exports, "GDanglingAnchor", { enumerable: true, get: function() {
        return model_4.SDanglingAnchorImpl;
      } });
      Object.defineProperty(exports, "GRoutableElement", { enumerable: true, get: function() {
        return model_4.SRoutableElementImpl;
      } });
      Object.defineProperty(exports, "GRoutingHandle", { enumerable: true, get: function() {
        return model_4.SRoutingHandleImpl;
      } });
      Object.defineProperty(exports, "connectableFeature", { enumerable: true, get: function() {
        return model_4.connectableFeature;
      } });
      Object.defineProperty(exports, "edgeInProgressID", { enumerable: true, get: function() {
        return model_4.edgeInProgressID;
      } });
      Object.defineProperty(exports, "edgeInProgressTargetHandleID", { enumerable: true, get: function() {
        return model_4.edgeInProgressTargetHandleID;
      } });
      Object.defineProperty(exports, "getAbsoluteRouteBounds", { enumerable: true, get: function() {
        return model_4.getAbsoluteRouteBounds;
      } });
      Object.defineProperty(exports, "getRouteBounds", { enumerable: true, get: function() {
        return model_4.getRouteBounds;
      } });
      Object.defineProperty(exports, "isConnectable", { enumerable: true, get: function() {
        return model_4.isConnectable;
      } });
      __exportStar(require_polyline_anchors(), exports);
      __exportStar(require_polyline_edge_router(), exports);
      __exportStar(require_routing(), exports);
      __exportStar(require_views5(), exports);
      __exportStar(require_model6(), exports);
      var select_1 = require_select();
      Object.defineProperty(exports, "GetSelectionCommand", { enumerable: true, get: function() {
        return select_1.GetSelectionCommand;
      } });
      Object.defineProperty(exports, "SelectKeyboardListener", { enumerable: true, get: function() {
        return select_1.SelectKeyboardListener;
      } });
      Object.defineProperty(exports, "SelectMouseListener", { enumerable: true, get: function() {
        return select_1.SelectMouseListener;
      } });
      Object.defineProperty(exports, "SprottySelectAllCommand", { enumerable: true, get: function() {
        return select_1.SelectAllCommand;
      } });
      Object.defineProperty(exports, "SprottySelectCommand", { enumerable: true, get: function() {
        return select_1.SelectCommand;
      } });
      __exportStar(require_model_matching(), exports);
      __exportStar(require_update_model(), exports);
      __exportStar(require_center_fit(), exports);
      __exportStar(require_model12(), exports);
      __exportStar(require_scroll(), exports);
      __exportStar(require_viewport(), exports);
      var viewport_root_1 = require_viewport_root();
      Object.defineProperty(exports, "GViewportRootElement", { enumerable: true, get: function() {
        return viewport_root_1.ViewportRootElementImpl;
      } });
      __exportStar(require_zoom(), exports);
      __exportStar(require_zorder(), exports);
      var sgraph_1 = require_sgraph();
      Object.defineProperty(exports, "GCompartment", { enumerable: true, get: function() {
        return sgraph_1.SCompartmentImpl;
      } });
      Object.defineProperty(exports, "GGraphIndex", { enumerable: true, get: function() {
        return sgraph_1.SGraphIndex;
      } });
      Object.defineProperty(exports, "GLabel", { enumerable: true, get: function() {
        return sgraph_1.SLabelImpl;
      } });
      Object.defineProperty(exports, "GNode", { enumerable: true, get: function() {
        return sgraph_1.SNodeImpl;
      } });
      Object.defineProperty(exports, "GPort", { enumerable: true, get: function() {
        return sgraph_1.SPortImpl;
      } });
      Object.defineProperty(exports, "SEdgeImpl", { enumerable: true, get: function() {
        return sgraph_1.SEdgeImpl;
      } });
      Object.defineProperty(exports, "SGraphImpl", { enumerable: true, get: function() {
        return sgraph_1.SGraphImpl;
      } });
      var views_1 = require_views6();
      Object.defineProperty(exports, "BezierCurveEdgeView", { enumerable: true, get: function() {
        return views_1.BezierCurveEdgeView;
      } });
      Object.defineProperty(exports, "GBezierControlHandleView", { enumerable: true, get: function() {
        return views_1.SBezierControlHandleView;
      } });
      Object.defineProperty(exports, "GBezierCreateHandleView", { enumerable: true, get: function() {
        return views_1.SBezierCreateHandleView;
      } });
      Object.defineProperty(exports, "GCompartmentView", { enumerable: true, get: function() {
        return views_1.SCompartmentView;
      } });
      Object.defineProperty(exports, "GGraphView", { enumerable: true, get: function() {
        return views_1.SGraphView;
      } });
      Object.defineProperty(exports, "GLabelView", { enumerable: true, get: function() {
        return views_1.SLabelView;
      } });
      Object.defineProperty(exports, "GRoutingHandleView", { enumerable: true, get: function() {
        return views_1.SRoutingHandleView;
      } });
      Object.defineProperty(exports, "JumpingPolylineEdgeView", { enumerable: true, get: function() {
        return views_1.JumpingPolylineEdgeView;
      } });
      Object.defineProperty(exports, "PolylineEdgeView", { enumerable: true, get: function() {
        return views_1.PolylineEdgeView;
      } });
      Object.defineProperty(exports, "PolylineEdgeViewWithGapsOnIntersections", { enumerable: true, get: function() {
        return views_1.PolylineEdgeViewWithGapsOnIntersections;
      } });
      __exportStar(require_feature_modules(), exports);
      __exportStar(require_generic_views(), exports);
      __exportStar(require_html_views(), exports);
      __exportStar(require_jsx(), exports);
      var model_5 = require_model18();
      Object.defineProperty(exports, "CircularNode", { enumerable: true, get: function() {
        return model_5.CircularNode;
      } });
      Object.defineProperty(exports, "CircularPort", { enumerable: true, get: function() {
        return model_5.CircularPort;
      } });
      Object.defineProperty(exports, "DiamondNode", { enumerable: true, get: function() {
        return model_5.DiamondNode;
      } });
      Object.defineProperty(exports, "GForeignObjectElement", { enumerable: true, get: function() {
        return model_5.ForeignObjectElementImpl;
      } });
      Object.defineProperty(exports, "GHtmlRoot", { enumerable: true, get: function() {
        return model_5.HtmlRootImpl;
      } });
      Object.defineProperty(exports, "GPreRenderedElement", { enumerable: true, get: function() {
        return model_5.PreRenderedElementImpl;
      } });
      Object.defineProperty(exports, "GShapedPreRenderedElement", { enumerable: true, get: function() {
        return model_5.ShapedPreRenderedElementImpl;
      } });
      Object.defineProperty(exports, "RectangularNode", { enumerable: true, get: function() {
        return model_5.RectangularNode;
      } });
      Object.defineProperty(exports, "RectangularPort", { enumerable: true, get: function() {
        return model_5.RectangularPort;
      } });
      __exportStar(require_modules(), exports);
      __exportStar(require_svg_views(), exports);
      __exportStar(require_commit_model(), exports);
      __exportStar(require_logging2(), exports);
      __exportStar(require_model_source(), exports);
      __exportStar(require_browser(), exports);
      __exportStar(require_codicon(), exports);
      __exportStar(require_color(), exports);
      __exportStar(require_geometry2(), exports);
      __exportStar(require_inversify2(), exports);
      __exportStar(require_iterable(), exports);
      __exportStar(require_keyboard(), exports);
      __exportStar(require_logging(), exports);
      __exportStar(require_registry(), exports);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/model/model-initialization-constraint.js
  var require_model_initialization_constraint = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/model/model-initialization-constraint.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultModelInitializationConstraint = exports.ModelInitializationConstraint = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var ModelInitializationConstraint = class ModelInitializationConstraint {
        constructor() {
          this.completion = new sprotty_1.Deferred();
          this._isCompleted = false;
          this.onInitializedEmitter = new sprotty_1.Emitter();
        }
        get isCompleted() {
          return this._isCompleted;
        }
        onInitialized(listener) {
          if (!listener) {
            return this.completion.promise;
          }
          if (this.isCompleted) {
            listener();
            return sprotty_1.Disposable.empty();
          }
          return this.onInitializedEmitter.event(listener);
        }
        setCompleted() {
          if (!this.isCompleted) {
            this._isCompleted = true;
            this.completion.resolve();
            this.onInitializedEmitter.fire();
            this.onInitializedEmitter.dispose();
          }
        }
        notifyDispatched(action) {
          if (this.isCompleted) {
            return;
          }
          if (this.isInitializedAfter(action)) {
            this.setCompleted();
          }
        }
      };
      exports.ModelInitializationConstraint = ModelInitializationConstraint;
      exports.ModelInitializationConstraint = ModelInitializationConstraint = __decorate([
        (0, inversify_1.injectable)()
      ], ModelInitializationConstraint);
      var DefaultModelInitializationConstraint = class DefaultModelInitializationConstraint extends ModelInitializationConstraint {
        constructor() {
          super(...arguments);
          this.seenNonEmptyModelAction = false;
        }
        isInitializedAfter(action) {
          if (this.isNonEmptyModelAction(action)) {
            this.seenNonEmptyModelAction = true;
          } else if (this.seenNonEmptyModelAction && action.kind === sprotty_1.InitializeCanvasBoundsAction.KIND) {
            return true;
          }
          return false;
        }
        isNonEmptyModelAction(action) {
          if (sprotty_1.SetModelAction.is(action) || sprotty_1.UpdateModelAction.is(action)) {
            return action.newRoot.type !== "NONE";
          }
          return false;
        }
      };
      exports.DefaultModelInitializationConstraint = DefaultModelInitializationConstraint;
      exports.DefaultModelInitializationConstraint = DefaultModelInitializationConstraint = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultModelInitializationConstraint);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/action-dispatcher.js
  var require_action_dispatcher2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/action-dispatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPActionDispatcher = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var model_initialization_constraint_1 = require_model_initialization_constraint();
      var GLSPActionDispatcher = class GLSPActionDispatcher extends sprotty_1.ActionDispatcher {
        constructor() {
          super(...arguments);
          this.timeouts = /* @__PURE__ */ new Map();
          this.initializedConstraint = false;
        }
        initialize() {
          return super.initialize().then(() => this.startModelInitialization());
        }
        startModelInitialization() {
          if (!this.initializedConstraint) {
            this.logger.log(this, "Starting model initialization mode");
            this.initializationConstraint.onInitialized(() => this.logger.log(this, "Model initialization completed"));
            this.initializedConstraint = true;
          }
        }
        onceModelInitialized() {
          return this.initializationConstraint.onInitialized();
        }
        hasHandler(action) {
          return this.actionHandlerRegistry.get(action.kind).length > 0;
        }
        /**
         * Processes all given actions, by dispatching them to the corresponding handlers, after the model initialization is completed.
         *
         * @param actions The actions that should be dispatched after the model initialization
         */
        dispatchOnceModelInitialized(...actions) {
          this.initializationConstraint.onInitialized(() => this.dispatchAll(actions));
        }
        async dispatch(action) {
          const result = await super.dispatch(action);
          this.initializationConstraint.notifyDispatched(action);
          return result;
        }
        handleAction(action) {
          if (sprotty_1.ResponseAction.hasValidResponseId(action)) {
            const timeout = this.timeouts.get(action.responseId);
            if (timeout !== void 0) {
              clearTimeout(timeout);
              this.timeouts.delete(action.responseId);
            }
            const deferred = this.requests.get(action.responseId);
            if (deferred === void 0) {
              action.responseId = "";
            }
          }
          return super.handleAction(action);
        }
        request(action) {
          if (!action.requestId && action.requestId === "") {
            action.requestId = sprotty_1.RequestAction.generateRequestId();
          }
          return super.request(action);
        }
        /**
         * Dispatch a request and waits for a response until the timeout given in `timeoutMs` has
         * been reached. The returned promise is resolved when a response with matching identifier
         * is dispatched or when the timeout has been reached. That response is _not_ passed to the
         * registered action handlers. Instead, it is the responsibility of the caller of this method
         * to handle the response properly. For example, it can be sent to the registered handlers by
         * passing it again to the `dispatch` method.
         * If `rejectOnTimeout` is set to false (default) the returned promise will be resolved with
         * no value, otherwise it will be rejected.
         */
        requestUntil(action, timeoutMs = 2e3, rejectOnTimeout = false) {
          if (!action.requestId && action.requestId === "") {
            action.requestId = sprotty_1.RequestAction.generateRequestId();
          }
          const requestId = action.requestId;
          const timeout = setTimeout(() => {
            const deferred = this.requests.get(requestId);
            if (deferred !== void 0) {
              clearTimeout(timeout);
              this.requests.delete(requestId);
              const notification = "Request " + requestId + " (" + action + ") time out after " + timeoutMs + "ms.";
              if (rejectOnTimeout) {
                deferred.reject(notification);
              } else {
                this.logger.info(this, notification);
                deferred.resolve();
              }
            }
          }, timeoutMs);
          this.timeouts.set(requestId, timeout);
          return super.request(action);
        }
      };
      exports.GLSPActionDispatcher = GLSPActionDispatcher;
      __decorate([
        (0, inversify_1.inject)(model_initialization_constraint_1.ModelInitializationConstraint),
        __metadata("design:type", model_initialization_constraint_1.ModelInitializationConstraint)
      ], GLSPActionDispatcher.prototype, "initializationConstraint", void 0);
      exports.GLSPActionDispatcher = GLSPActionDispatcher = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPActionDispatcher);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/action-handler-registry.js
  var require_action_handler_registry = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/action-handler-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPActionHandlerRegistry = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var GLSPActionHandlerRegistry = class GLSPActionHandlerRegistry extends sprotty_1.ActionHandlerRegistry {
        /**
         * Retrieve a set of all action kinds for which (at least) one
         * handler is registered
         * @returns the set of handled action kinds
         */
        getHandledActionKinds() {
          return Array.from(this.elements.keys());
        }
      };
      exports.GLSPActionHandlerRegistry = GLSPActionHandlerRegistry;
      exports.GLSPActionHandlerRegistry = GLSPActionHandlerRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPActionHandlerRegistry);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/args-feature.js
  var require_args_feature = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/args-feature.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasArgs = exports.isArgsAware = exports.argsFeature = void 0;
      exports.argsFeature = Symbol("argsFeature");
      function isArgsAware(element) {
        return element.hasFeature(exports.argsFeature);
      }
      exports.isArgsAware = isArgsAware;
      function hasArgs(element) {
        return element !== void 0 && isArgsAware(element) && element.args !== void 0;
      }
      exports.hasArgs = hasArgs;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/auto-complete-actions.js
  var require_auto_complete_actions = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/auto-complete-actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AutoCompleteValue = void 0;
      var sprotty_1 = require_lib5();
      var AutoCompleteValue;
      (function(AutoCompleteValue2) {
        function is(object) {
          return sprotty_1.LabeledAction.is(object) && (0, sprotty_1.hasStringProp)(object, "text");
        }
        AutoCompleteValue2.is = is;
      })(AutoCompleteValue || (exports.AutoCompleteValue = AutoCompleteValue = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/validation-decorator.js
  var require_validation_decorator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/validation-decorator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValidationDecorator = exports.IValidationDecorator = void 0;
      var sprotty_1 = require_lib5();
      var IValidationDecorator;
      (function(IValidationDecorator2) {
        IValidationDecorator2.NO_DECORATION = {
          // eslint-disable-next-line @typescript-eslint/no-empty-function
          decorateValidationResult(_status) {
          },
          isValidatedOk() {
            return false;
          },
          // eslint-disable-next-line @typescript-eslint/no-empty-function
          invalidate() {
          },
          // eslint-disable-next-line @typescript-eslint/no-empty-function
          dispose() {
          }
        };
      })(IValidationDecorator || (exports.IValidationDecorator = IValidationDecorator = {}));
      var ValidationDecorator = class {
        constructor(containerElement) {
          this.containerElement = containerElement;
          this.warningClasses = ["warning"];
          this.warningIconClasses = (0, sprotty_1.codiconCSSString)("warning");
          this.errorClasses = ["error"];
          this.errorIconClasses = (0, sprotty_1.codiconCSSString)("error");
          this.isValidated = false;
          this.hasValidationError = false;
        }
        decorateValidationResult(status) {
          if (sprotty_1.ValidationStatus.isError(status)) {
            this.hasValidationError = true;
            this.decorateError(status.message ? status.message : "Error");
          } else if (sprotty_1.ValidationStatus.isWarning(status)) {
            this.hasValidationError = false;
            this.decorateWarning(status.message ? status.message : "Warning");
          } else {
            this.hasValidationError = false;
            this.dispose();
          }
          this.isValidated = true;
        }
        decorateError(message) {
          this.switchCssClasses(this.containerElement, this.errorClasses);
          const div = this.createDecorationDiv();
          this.switchCssClasses(div, this.errorClasses);
          div.innerHTML = `<span class="${this.errorIconClasses}"></span> ${message}`;
          this.adjustPosition();
        }
        decorateWarning(message) {
          this.switchCssClasses(this.containerElement, this.warningClasses);
          const div = this.createDecorationDiv();
          this.switchCssClasses(div, this.warningClasses);
          div.innerHTML = `<span class="${this.warningIconClasses}"></span> ${message}`;
          this.adjustPosition();
        }
        switchCssClasses(element, cssClasses) {
          element.classList.remove(...this.errorClasses, ...this.warningClasses);
          element.classList.add(...cssClasses);
        }
        createDecorationDiv() {
          if (!this.decorationDiv) {
            this.containerElement.classList.add("validation");
            this.decorationDiv = document.createElement("div");
            this.decorationDiv.style.width = `${this.decorationContainerWidth()}px`;
            this.decorationDiv.classList.add("validation-decorator");
            this.containerElement.appendChild(this.decorationDiv);
          }
          return this.decorationDiv;
        }
        decorationContainerWidth() {
          return this.containerElement.clientWidth - 5;
        }
        adjustPosition() {
          if (this.decorationDiv) {
            const height = this.decorationDiv.clientHeight + 2;
            this.decorationDiv.style.top = `-${height}px`;
          }
        }
        isValidatedOk() {
          return this.isValidated && !this.hasValidationError;
        }
        invalidate() {
          this.isValidated = false;
        }
        dispose() {
          this.hasValidationError = false;
          this.isValidated = false;
          if (this.decorationDiv && this.containerElement && this.containerElement.contains(this.decorationDiv)) {
            this.containerElement.removeChild(this.decorationDiv);
            this.switchCssClasses(this.containerElement, []);
            this.decorationDiv = void 0;
          }
        }
      };
      exports.ValidationDecorator = ValidationDecorator;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/auto-complete-widget.js
  var require_auto_complete_widget = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/auto-complete-widget.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toActionArray = exports.AutoCompleteWidget = void 0;
      var sprotty_1 = require_lib5();
      var auto_complete_actions_1 = require_auto_complete_actions();
      var validation_decorator_1 = require_validation_decorator();
      var configureAutocomplete = require_autocomplete();
      var AutoCompleteWidget = class {
        constructor(autoSuggestionSettings, suggestionProvider, suggestionSubmitHandler, notifyClose = () => {
        }, logger, options) {
          this.autoSuggestionSettings = autoSuggestionSettings;
          this.suggestionProvider = suggestionProvider;
          this.suggestionSubmitHandler = suggestionSubmitHandler;
          this.notifyClose = notifyClose;
          this.logger = logger;
          this.options = options;
          this.loadingIndicatorClasses = (0, sprotty_1.codiconCSSClasses)("loading", false, true, ["loading"]);
          this.validationDecorator = validation_decorator_1.IValidationDecorator.NO_DECORATION;
        }
        configureValidation(inputValidator, validationDecorator = validation_decorator_1.IValidationDecorator.NO_DECORATION) {
          this.inputValidator = inputValidator;
          this.validationDecorator = validationDecorator;
        }
        configureTextSubmitHandler(textSubmitHandler) {
          this.textSubmitHandler = textSubmitHandler;
        }
        initialize(containerElement) {
          this.containerElement = containerElement;
          this.inputElement = this.createInputElement();
          this.containerElement.appendChild(this.inputElement);
          this.containerElement.style.position = "absolute";
        }
        createInputElement() {
          const inputElement = document.createElement("input");
          inputElement.style.position = "absolute";
          inputElement.spellcheck = false;
          inputElement.autocapitalize = "false";
          inputElement.autocomplete = "off";
          inputElement.style.width = "100%";
          inputElement.addEventListener("keydown", (event) => this.handleKeyDown(event));
          inputElement.addEventListener("blur", () => {
            if (this.containerElement.style.visibility !== "hidden") {
              window.setTimeout(() => this.notifyClose("blur"), 200);
            }
          });
          return inputElement;
        }
        handleKeyDown(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            this.notifyClose("escape");
            return;
          }
          if ((0, sprotty_1.matchesKeystroke)(event, "Enter") && !this.isInputElementChanged() && this.isSuggestionAvailable()) {
            return;
          }
          if (this.isInputElementChanged()) {
            this.invalidateValidationResultAndContextActions();
          }
          if (!(0, sprotty_1.matchesKeystroke)(event, "Enter") || this.isSuggestionAvailable()) {
            return;
          }
          if (!this.validationDecorator.isValidatedOk()) {
            event.stopImmediatePropagation();
            return;
          }
          if (this.textSubmitHandler) {
            this.executeFromTextOnlyInput();
            this.notifyClose("submission");
          }
        }
        isInputElementChanged() {
          return this.inputElement.value !== this.previousContent;
        }
        invalidateValidationResultAndContextActions() {
          this.contextActions = void 0;
          this.validationDecorator.invalidate();
        }
        open(root, ...contextElementIds) {
          this.contextActions = void 0;
          this.autoCompleteResult = configureAutocomplete(this.autocompleteSettings(root));
          this.previousContent = this.inputElement.value;
          this.inputElement.setSelectionRange(0, this.inputElement.value.length);
          this.inputElement.focus();
        }
        autocompleteSettings(root) {
          return {
            input: this.inputElement,
            emptyMsg: this.autoSuggestionSettings.noSuggestionsMessage,
            className: this.autoSuggestionSettings.suggestionsClass,
            showOnFocus: this.autoSuggestionSettings.showOnFocus,
            debounceWaitMs: this.autoSuggestionSettings.debounceWaitMs,
            minLength: -1,
            fetch: (text, update) => this.updateSuggestions(update, text, root),
            onSelect: (item) => this.onSelect(item),
            render: (item, currentValue) => this.renderSuggestions(item, currentValue),
            customize: (input, inputRect, container, maxHeight) => {
              this.customizeInputElement(input, inputRect, container, maxHeight);
            }
          };
        }
        customizeInputElement(input, inputRect, container, maxHeight) {
          var _a;
          if (this.containerElement) {
            this.containerElement.appendChild(container);
            if (this.options && this.options.selectedSuggestionChanged) {
              const selectedElement = container.querySelector(".selected");
              if (selectedElement !== null && selectedElement !== void 0) {
                const index = Array.from(container.children).indexOf(selectedElement);
                this.options.selectedSuggestionChanged((_a = this.contextActions) === null || _a === void 0 ? void 0 : _a[index]);
              } else {
                this.options.selectedSuggestionChanged(void 0);
              }
            }
          }
        }
        updateSuggestions(update, text, root, ...contextElementIds) {
          this.onLoading();
          this.doUpdateSuggestions(text, root).then((actions) => {
            var _a, _b;
            this.contextActions = this.filterActions(text, actions);
            update(this.contextActions);
            (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.visibleSuggestionsChanged) === null || _b === void 0 ? void 0 : _b.call(_a, this.contextActions);
            this.onLoaded("success");
          }).catch((reason) => {
            if (this.logger) {
              this.logger.error(this, "Failed to obtain suggestions", reason);
            }
            this.onLoaded("error");
          });
        }
        onLoading() {
          if (this.loadingIndicator && this.containerElement.contains(this.loadingIndicator)) {
            return;
          }
          this.loadingIndicator = document.createElement("span");
          this.loadingIndicator.classList.add(...this.loadingIndicatorClasses);
          this.containerElement.appendChild(this.loadingIndicator);
        }
        doUpdateSuggestions(text, root, ...contextElementIds) {
          return this.suggestionProvider.provideSuggestions(text);
        }
        onLoaded(_success) {
          if (this.containerElement.contains(this.loadingIndicator)) {
            this.containerElement.removeChild(this.loadingIndicator);
          }
          this.validationDecorator.invalidate();
          this.validateInputIfNoContextActions();
          this.previousContent = this.inputElement.value;
        }
        renderSuggestions(item, value) {
          const itemElement = document.createElement("div");
          const wordMatcher = this.escapeForRegExp(value).split(" ").join("|");
          const regex = new RegExp(wordMatcher, "gi");
          if (item.icon) {
            this.renderIcon(itemElement, item.icon);
          }
          itemElement.innerHTML += item.label.replace(regex, (match) => "<em>" + match + "</em>").replace(/ /g, "&nbsp;");
          return itemElement;
        }
        escapeForRegExp(value) {
          return value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
        }
        renderIcon(itemElement, icon) {
          itemElement.innerHTML += `<span class="icon ${icon}"></span>`;
        }
        filterActions(filterText, actions) {
          return (0, sprotty_1.toArray)(actions.filter((action) => {
            const label = action.label.toLowerCase();
            const searchWords = filterText.split(" ");
            return searchWords.every((word) => label.indexOf(word.toLowerCase()) !== -1);
          }));
        }
        onSelect(item) {
          if (auto_complete_actions_1.AutoCompleteValue.is(item)) {
            this.inputElement.value = item.text;
            window.setTimeout(() => this.inputElement.dispatchEvent(new Event("keyup")));
          } else {
            this.executeFromSuggestion(item);
            this.notifyClose("submission");
          }
        }
        validateInputIfNoContextActions() {
          if (this.isNoOrExactlyOneMatchingContextAction()) {
            this.validateInput();
          } else {
            this.validationDecorator.dispose();
          }
        }
        isNoOrExactlyOneMatchingContextAction() {
          return !this.isSuggestionAvailable() || this.contextActions && this.contextActions.length === 1 && this.inputElement.value.endsWith(this.contextActions[0].label);
        }
        isSuggestionAvailable() {
          return this.contextActions && this.contextActions.length > 0;
        }
        validateInput() {
          if (this.inputValidator) {
            this.inputValidator.validate(this.inputElement.value).then((result) => this.validationDecorator.decorateValidationResult(result)).catch((error) => this.handleErrorDuringValidation(error));
          }
        }
        handleErrorDuringValidation(error) {
          if (this.logger) {
            this.logger.error(this, "Failed to validate input", error);
          }
          this.validationDecorator.dispose();
        }
        executeFromSuggestion(input) {
          this.suggestionSubmitHandler.executeFromSuggestion(input);
        }
        executeFromTextOnlyInput() {
          if (this.textSubmitHandler) {
            this.textSubmitHandler.executeFromTextOnlyInput(this.inputElement.value);
          }
        }
        get inputField() {
          return this.inputElement;
        }
        dispose() {
          this.validationDecorator.dispose();
          if (this.autoCompleteResult) {
            this.autoCompleteResult.destroy();
          }
        }
      };
      exports.AutoCompleteWidget = AutoCompleteWidget;
      function toActionArray(input) {
        if (sprotty_1.LabeledAction.is(input)) {
          return input.actions;
        } else if (sprotty_1.Action.is(input)) {
          return [input];
        }
        return [];
      }
      exports.toActionArray = toActionArray;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/command-stack.js
  var require_command_stack2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/command-stack.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPCommandStack = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var GLSPCommandStack = class GLSPCommandStack extends sprotty_1.CommandStack {
        constructor() {
          super(...arguments);
          this.modelRootListeners = [];
          this.toDispose = new sprotty_1.DisposableCollection();
          this.onModelRootChangedEmitter = new sprotty_1.Emitter();
        }
        initialize() {
          super.initialize();
          this.toDispose.push(this.onModelRootChangedEmitter);
          this.modelRootListeners.forEach((listener) => this.onModelRootChanged((root) => listener.modelRootChanged(root)));
        }
        dispose() {
          this.toDispose.dispose();
        }
        get onModelRootChanged() {
          return this.onModelRootChangedEmitter.event;
        }
        undo() {
          this.logger.warn(this, "GLSPCommandStack.undo() was called. This should never happen as the GLSP server is responsible for handling undo requests");
          return this.currentModel;
        }
        redo() {
          this.logger.warn(this, "GLSPCommandStack.redo() was called. This should never happen as the GLSP server is responsible for handling redo requests");
          return this.currentModel;
        }
        execute(command) {
          const result = super.execute(command);
          if (command instanceof sprotty_1.SetModelCommand || command instanceof sprotty_1.UpdateModelCommand) {
            result.then((root) => this.notifyListeners(root));
          }
          return result;
        }
        notifyListeners(root) {
          this.onModelRootChangedEmitter.fire(root);
        }
      };
      exports.GLSPCommandStack = GLSPCommandStack;
      __decorate([
        (0, inversify_1.multiInject)(sprotty_1.TYPES.ISModelRootListener),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], GLSPCommandStack.prototype, "modelRootListeners", void 0);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], GLSPCommandStack.prototype, "dispose", null);
      exports.GLSPCommandStack = GLSPCommandStack = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPCommandStack);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/drag-aware-mouse-listener.js
  var require_drag_aware_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/drag-aware-mouse-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DragAwareMouseListener = void 0;
      var sprotty_1 = require_lib5();
      var DragAwareMouseListener2 = class extends sprotty_1.MouseListener {
        constructor() {
          super(...arguments);
          this._isMouseDown = false;
          this._isMouseDrag = false;
        }
        mouseDown(target, event) {
          this._isMouseDown = true;
          return [];
        }
        mouseMove(target, event) {
          if (this._isMouseDown) {
            this._isMouseDrag = true;
          }
          return [];
        }
        mouseUp(element, event) {
          this._isMouseDown = false;
          if (this._isMouseDrag) {
            this._isMouseDrag = false;
            return this.draggingMouseUp(element, event);
          }
          return this.nonDraggingMouseUp(element, event);
        }
        nonDraggingMouseUp(element, event) {
          return [];
        }
        draggingMouseUp(element, event) {
          return [];
        }
        get isMouseDrag() {
          return this._isMouseDrag;
        }
        get isMouseDown() {
          return this._isMouseDown;
        }
      };
      exports.DragAwareMouseListener = DragAwareMouseListener2;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/gmodel-util.js
  var require_gmodel_util = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/gmodel-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getElementTypeId = exports.calcRoute = exports.calcElementAndRoute = exports.calcElementAndRoutingPoints = exports.ROUTE_KINDS = exports.ROUTING_POINT_KINDS = exports.ALL_ROUTING_POINTS = exports.toElementAndRoutingPoints = exports.toElementAndBounds = exports.isSelectableAndBoundsAware = exports.isRoutingHandle = exports.isRoutable = exports.isNonRoutableSelectedBoundsAware = exports.isNonRoutableSelectedMovableBoundsAware = exports.removeCssClasses = exports.addCssClasses = exports.isNotUndefined = exports.hasSelectedElements = exports.getSelectedElementCount = exports.getElements = exports.getMatchingElements = exports.forEachElement = exports.filter = void 0;
      var sprotty_1 = require_lib5();
      function filter(index, predicate) {
        return index.all().filter(predicate);
      }
      exports.filter = filter;
      function forEachElement(index, predicate, runnable) {
        filter(index, predicate).forEach(runnable);
      }
      exports.forEachElement = forEachElement;
      function getMatchingElements(index, predicate) {
        return Array.from(filter(index, predicate));
      }
      exports.getMatchingElements = getMatchingElements;
      function getElements(index, elementsIDs, guard) {
        const filterFn = (element) => {
          if (element !== void 0) {
            return guard ? guard(element) : true;
          }
          return false;
        };
        return elementsIDs.map((id) => index.getById(id)).filter(filterFn);
      }
      exports.getElements = getElements;
      function getSelectedElementCount(index) {
        let selected = 0;
        forEachElement(index, sprotty_1.isSelected, (element) => selected++);
        return selected;
      }
      exports.getSelectedElementCount = getSelectedElementCount;
      function hasSelectedElements(index) {
        return getSelectedElementCount(index) > 0;
      }
      exports.hasSelectedElements = hasSelectedElements;
      function isNotUndefined(element) {
        return element !== void 0;
      }
      exports.isNotUndefined = isNotUndefined;
      function addCssClasses(element, cssClasses) {
        var _a;
        const elementCssClasses = (_a = element.cssClasses) !== null && _a !== void 0 ? _a : [];
        (0, sprotty_1.distinctAdd)(elementCssClasses, ...cssClasses);
        element.cssClasses = elementCssClasses;
      }
      exports.addCssClasses = addCssClasses;
      function removeCssClasses(root, cssClasses) {
        if (!root.cssClasses || root.cssClasses.length === 0) {
          return;
        }
        (0, sprotty_1.remove)(root.cssClasses, ...cssClasses);
      }
      exports.removeCssClasses = removeCssClasses;
      function isNonRoutableSelectedMovableBoundsAware(element) {
        return isNonRoutableSelectedBoundsAware(element) && (0, sprotty_1.isMoveable)(element);
      }
      exports.isNonRoutableSelectedMovableBoundsAware = isNonRoutableSelectedMovableBoundsAware;
      function isNonRoutableSelectedBoundsAware(element) {
        return (0, sprotty_1.isBoundsAware)(element) && (0, sprotty_1.isSelected)(element) && !isRoutable2(element);
      }
      exports.isNonRoutableSelectedBoundsAware = isNonRoutableSelectedBoundsAware;
      function isRoutable2(element) {
        return element instanceof sprotty_1.GRoutableElement && element.routingPoints !== void 0;
      }
      exports.isRoutable = isRoutable2;
      function isRoutingHandle(element) {
        return element !== void 0 && element instanceof sprotty_1.GRoutingHandle;
      }
      exports.isRoutingHandle = isRoutingHandle;
      function isSelectableAndBoundsAware(element) {
        return (0, sprotty_1.isSelectable)(element) && (0, sprotty_1.isBoundsAware)(element);
      }
      exports.isSelectableAndBoundsAware = isSelectableAndBoundsAware;
      function toElementAndBounds(element) {
        return {
          elementId: element.id,
          newPosition: {
            x: element.bounds.x,
            y: element.bounds.y
          },
          newSize: {
            width: element.bounds.width,
            height: element.bounds.height
          }
        };
      }
      exports.toElementAndBounds = toElementAndBounds;
      function toElementAndRoutingPoints(element) {
        return {
          elementId: element.id,
          newRoutingPoints: element.routingPoints
        };
      }
      exports.toElementAndRoutingPoints = toElementAndRoutingPoints;
      exports.ALL_ROUTING_POINTS = void 0;
      exports.ROUTING_POINT_KINDS = ["linear", "bezier-junction"];
      exports.ROUTE_KINDS = [...exports.ROUTING_POINT_KINDS, "source", "target"];
      function calcElementAndRoutingPoints(element, routerRegistry) {
        const newRoutingPoints = routerRegistry ? calcRoute(element, routerRegistry, exports.ROUTING_POINT_KINDS) : element.routingPoints;
        return { elementId: element.id, newRoutingPoints };
      }
      exports.calcElementAndRoutingPoints = calcElementAndRoutingPoints;
      function calcElementAndRoute(element, routerRegistry) {
        var _a, _b;
        let route = routerRegistry ? calcRoute(element, routerRegistry, exports.ROUTE_KINDS) : void 0;
        if (!route) {
          route = [...element.routingPoints];
          route.splice(0, 0, ((_a = element.source) === null || _a === void 0 ? void 0 : _a.position) || sprotty_1.Point.ORIGIN);
          route.push(((_b = element.target) === null || _b === void 0 ? void 0 : _b.position) || sprotty_1.Point.ORIGIN);
        }
        return { elementId: element.id, newRoutingPoints: route };
      }
      exports.calcElementAndRoute = calcElementAndRoute;
      function calcRoute(element, routerRegistry, pointKinds = exports.ALL_ROUTING_POINTS, tolerance = Number.EPSILON) {
        const route = routerRegistry.get(element.routerKind).route(element);
        const calculatedRoute = [];
        for (const point of route) {
          if (pointKinds && !pointKinds.includes(point.kind)) {
            continue;
          }
          if (exports.ROUTING_POINT_KINDS.includes(point.kind) && calculatedRoute.find((calculatedPoint) => sprotty_1.Point.maxDistance(point, calculatedPoint) < tolerance)) {
            continue;
          }
          calculatedRoute.push(point);
        }
        return calculatedRoute;
      }
      exports.calcRoute = calcRoute;
      function getElementTypeId(input) {
        if (typeof input === "string") {
          return input;
        } else {
          return input.type;
        }
      }
      exports.getElementTypeId = getElementTypeId;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/selection-service.js
  var require_selection_service = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/selection-service.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectFeedbackAction = exports.SelectAllCommand = exports.SelectCommand = exports.SelectionService = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var gmodel_util_1 = require_gmodel_util();
      var SelectionService = class SelectionService {
        constructor() {
          this.selectedElementIDs = /* @__PURE__ */ new Set();
          this.selectionListeners = [];
          this.toDispose = new sprotty_1.DisposableCollection();
          this.onSelectionChangedEmitter = new sprotty_1.Emitter();
        }
        initialize() {
          this.toDispose.push(this.onSelectionChangedEmitter);
          this.selectionListeners.forEach((listener) => this.onSelectionChanged((change) => listener.selectionChanged(change.root, change.selectedElements, change.deselectedElements)));
        }
        dispose() {
          this.toDispose.dispose();
        }
        get onSelectionChanged() {
          return this.onSelectionChangedEmitter.event;
        }
        modelRootChanged(root) {
          this.updateSelection(root, [], []);
        }
        updateSelection(root, select, deselect) {
          if (root === void 0 && select.length === 0 && deselect.length === 0) {
            return;
          }
          const prevRoot = this.root;
          const prevSelectedElementIDs = new Set(this.selectedElementIDs);
          this.root = root;
          const toSelect = [...select].filter((selectId) => deselect.indexOf(selectId) === -1);
          const toDeselect = [...deselect].filter((deselectId) => select.indexOf(deselectId) === -1 && this.selectedElementIDs.has(deselectId));
          for (const id of toDeselect) {
            this.selectedElementIDs.delete(id);
          }
          for (const id of toSelect) {
            this.selectedElementIDs.add(id);
          }
          const deselectedElementIDs = new Set(toDeselect);
          for (const id of this.selectedElementIDs) {
            const element = root.index.getById(id);
            if (element === void 0) {
              this.selectedElementIDs.delete(id);
              if (prevRoot !== void 0 && prevRoot.index.getById(id)) {
                deselectedElementIDs.add(id);
              }
            }
          }
          const selectionChanged = prevSelectedElementIDs.size !== this.selectedElementIDs.size || ![...prevSelectedElementIDs].every((value) => this.selectedElementIDs.has(value));
          if (selectionChanged) {
            this.dispatchFeedback([
              SelectFeedbackAction.create({
                selectedElementsIDs: [...this.selectedElementIDs],
                deselectedElementsIDs: [...deselectedElementIDs]
              })
            ]);
          }
          const rootChanged = prevRoot !== root;
          if (rootChanged || selectionChanged) {
            this.notifyListeners(this.root, this.selectedElementIDs, deselectedElementIDs);
          }
        }
        dispatchFeedback(actions) {
          this.feedbackDispatcher.registerFeedback(this, actions);
        }
        notifyListeners(root, selectedElementIDs, deselectedElementIDs) {
          this.onSelectionChangedEmitter.fire({
            root,
            selectedElements: Array.from(selectedElementIDs),
            deselectedElements: Array.from(deselectedElementIDs)
          });
        }
        getModelRoot() {
          return this.root;
        }
        getSelectedElements() {
          return !this.root ? [] : (0, gmodel_util_1.getElements)(this.root.index, Array.from(this.selectedElementIDs), sprotty_1.isSelectable);
        }
        /**
         * QUERY METHODS
         */
        getSelectedElementIDs() {
          return [...this.selectedElementIDs];
        }
        hasSelectedElements() {
          return this.selectedElementIDs.size > 0;
        }
        isSingleSelection() {
          return this.selectedElementIDs.size === 1;
        }
        isMultiSelection() {
          return this.selectedElementIDs.size > 1;
        }
      };
      exports.SelectionService = SelectionService;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], SelectionService.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], SelectionService.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.multiInject)(sprotty_1.TYPES.ISelectionListener),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], SelectionService.prototype, "selectionListeners", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], SelectionService.prototype, "initialize", null);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], SelectionService.prototype, "dispose", null);
      exports.SelectionService = SelectionService = __decorate([
        (0, inversify_1.injectable)()
      ], SelectionService);
      var SelectCommand = class SelectCommand extends sprotty_1.Command {
        constructor(action, selectionService) {
          super();
          this.action = action;
          this.selectionService = selectionService;
          this.selected = [];
          this.deselected = [];
        }
        execute(context) {
          const model = context.root;
          const selectionGuard = (element) => element instanceof sprotty_1.GChildElement && (0, sprotty_1.isSelectable)(element);
          const selectedElements = (0, gmodel_util_1.getElements)(model.index, this.action.selectedElementsIDs, selectionGuard);
          const deselectedElements = this.action.deselectAll ? this.selectionService.getSelectedElements() : (0, gmodel_util_1.getElements)(model.index, this.action.deselectedElementsIDs, selectionGuard);
          this.selectionService.updateSelection(model, (0, sprotty_1.pluck)(selectedElements, "id"), (0, sprotty_1.pluck)(deselectedElements, "id"));
          return model;
        }
        // Basically no-op since client-side undo is not supported in GLSP.
        undo(context) {
          return context.root;
        }
        // Basically no-op since client-side redo is not supported in GLSP.
        redo(context) {
          return context.root;
        }
      };
      exports.SelectCommand = SelectCommand;
      SelectCommand.KIND = sprotty_1.SprottySelectCommand.KIND;
      exports.SelectCommand = SelectCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(SelectionService)),
        __metadata("design:paramtypes", [Object, SelectionService])
      ], SelectCommand);
      var SelectAllCommand = class SelectAllCommand extends sprotty_1.Command {
        constructor(action, selectionService) {
          super();
          this.action = action;
          this.selectionService = selectionService;
          this.previousSelection = /* @__PURE__ */ new Map();
        }
        execute(context) {
          const model = context.root;
          const selectionGuard = (element) => element instanceof sprotty_1.GChildElement && (0, sprotty_1.isSelectable)(element);
          const selectables = (0, gmodel_util_1.getMatchingElements)(model.index, selectionGuard);
          const selectableIds = (0, sprotty_1.pluck)(selectables, "id");
          if (this.action.select) {
            this.selectionService.updateSelection(model, selectableIds, []);
          } else {
            this.selectionService.updateSelection(model, [], selectableIds);
          }
          return model;
        }
        // Basically no-op since client-side undo is not supported in GLSP.
        undo(context) {
          return context.root;
        }
        // Basically no-op since client-side redo is not supported in GLSP.
        redo(context) {
          return context.root;
        }
      };
      exports.SelectAllCommand = SelectAllCommand;
      SelectAllCommand.KIND = sprotty_1.SprottySelectAllCommand.KIND;
      exports.SelectAllCommand = SelectAllCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(SelectionService)),
        __metadata("design:paramtypes", [Object, SelectionService])
      ], SelectAllCommand);
      var SelectFeedbackAction;
      (function(SelectFeedbackAction2) {
        SelectFeedbackAction2.KIND = "selectFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, SelectFeedbackAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "selectedElementsIDs") && (0, sprotty_1.hasArrayProp)(object, "deselectedElementsIDs");
        }
        SelectFeedbackAction2.is = is;
        function create(options) {
          return Object.assign(Object.assign({}, sprotty_1.SelectAction.create(options)), { kind: SelectFeedbackAction2.KIND });
        }
        SelectFeedbackAction2.create = create;
        function addSelection(selectedElementsIDs) {
          return Object.assign(Object.assign({}, sprotty_1.SelectAction.addSelection(selectedElementsIDs)), { kind: SelectFeedbackAction2.KIND });
        }
        SelectFeedbackAction2.addSelection = addSelection;
        function removeSelection(deselectedElementsIDs) {
          return Object.assign(Object.assign({}, sprotty_1.SelectAction.removeSelection(deselectedElementsIDs)), { kind: SelectFeedbackAction2.KIND });
        }
        SelectFeedbackAction2.removeSelection = removeSelection;
        function setSelection(selectedElementsIDs) {
          return Object.assign(Object.assign({}, sprotty_1.SelectAction.setSelection(selectedElementsIDs)), { kind: SelectFeedbackAction2.KIND });
        }
        SelectFeedbackAction2.setSelection = setSelection;
      })(SelectFeedbackAction || (exports.SelectFeedbackAction = SelectFeedbackAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/editor-context-service.js
  var require_editor_context_service = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/editor-context-service.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EditorContextService = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var selection_service_1 = require_selection_service();
      var EditorContextService = class EditorContextService {
        constructor() {
          this.editModeListeners = [];
          this.onEditModeChangedEmitter = new sprotty_1.Emitter();
          this.onDirtyStateChangedEmitter = new sprotty_1.Emitter();
          this.toDispose = new sprotty_1.DisposableCollection();
        }
        get onEditModeChanged() {
          return this.onEditModeChangedEmitter.event;
        }
        get onDirtyStateChanged() {
          return this.onDirtyStateChangedEmitter.event;
        }
        initialize() {
          var _a;
          this._editMode = (_a = this.diagramOptions.editMode) !== null && _a !== void 0 ? _a : sprotty_1.EditMode.EDITABLE;
          this.toDispose.push(this.onEditModeChangedEmitter, this.onDirtyStateChangedEmitter);
          this.editModeListeners.forEach((listener) => this.onEditModeChanged((change) => listener.editModeChanged(change.newValue, change.oldValue)));
        }
        dispose() {
          this.toDispose.dispose();
        }
        get(args) {
          return {
            selectedElementIds: Array.from(this.selectionService.getSelectedElementIDs()),
            lastMousePosition: this.mousePositionTracker.lastPositionOnDiagram,
            args
          };
        }
        getWithSelection(selectedElementIds, args) {
          return {
            selectedElementIds,
            lastMousePosition: this.mousePositionTracker.lastPositionOnDiagram,
            args
          };
        }
        handle(action) {
          if (sprotty_1.SetEditModeAction.is(action)) {
            this.handleSetEditModeAction(action);
          } else if (sprotty_1.SetDirtyStateAction.is(action)) {
            this.handleSetDirtyStateAction(action);
          }
        }
        handleSetEditModeAction(action) {
          const oldValue = this._editMode;
          this._editMode = action.editMode;
          this.onEditModeChangedEmitter.fire({ newValue: this.editMode, oldValue });
        }
        handleSetDirtyStateAction(action) {
          if (action.isDirty !== this._isDirty) {
            this._isDirty = action.isDirty;
            this.onDirtyStateChangedEmitter.fire(action);
          }
        }
        get sourceUri() {
          return this.diagramOptions.sourceUri;
        }
        get editMode() {
          return this._editMode;
        }
        get diagramType() {
          return this.diagramOptions.diagramType;
        }
        get clientId() {
          return this.diagramOptions.clientId;
        }
        get modelRoot() {
          return this.selectionService.getModelRoot();
        }
        get selectedElements() {
          return this.selectionService.getSelectedElements();
        }
        get isReadonly() {
          return this.editMode === sprotty_1.EditMode.READONLY;
        }
        get isDirty() {
          return this._isDirty;
        }
        postRequestModel() {
          this.actionDispatcher.dispatch(sprotty_1.SetEditModeAction.create(this.editMode));
        }
      };
      exports.EditorContextService = EditorContextService;
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], EditorContextService.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.MousePositionTracker),
        __metadata("design:type", sprotty_1.MousePositionTracker)
      ], EditorContextService.prototype, "mousePositionTracker", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], EditorContextService.prototype, "diagramOptions", void 0);
      __decorate([
        (0, inversify_1.multiInject)(sprotty_1.TYPES.IEditModeListener),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], EditorContextService.prototype, "editModeListeners", void 0);
      __decorate([
        (0, inversify_1.inject)(action_dispatcher_1.GLSPActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], EditorContextService.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], EditorContextService.prototype, "initialize", null);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], EditorContextService.prototype, "dispose", null);
      exports.EditorContextService = EditorContextService = __decorate([
        (0, inversify_1.injectable)()
      ], EditorContextService);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-action-dispatcher.js
  var require_feedback_action_dispatcher = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-action-dispatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackActionDispatcher = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var FeedbackActionDispatcher = class FeedbackActionDispatcher {
        constructor() {
          this.registeredFeedback = /* @__PURE__ */ new Map();
        }
        registerFeedback(feedbackEmitter, feedbackActions, cleanupActions) {
          if (feedbackActions.length > 0) {
            this.registeredFeedback.set(feedbackEmitter, feedbackActions);
            this.dispatchFeedback(feedbackActions, feedbackEmitter);
          }
          return sprotty_1.Disposable.create(() => this.deregisterFeedback(feedbackEmitter, cleanupActions));
        }
        deregisterFeedback(feedbackEmitter, cleanupActions) {
          this.registeredFeedback.delete(feedbackEmitter);
          if (cleanupActions && cleanupActions.length > 0) {
            this.dispatchFeedback(cleanupActions, feedbackEmitter);
          }
        }
        getRegisteredFeedback() {
          const result = [];
          this.registeredFeedback.forEach((actions) => result.push(...actions));
          return result;
        }
        getRegisteredFeedbackEmitters(action) {
          const result = [];
          this.registeredFeedback.forEach((actions, emitter) => {
            if (actions.includes(action)) {
              result.push(emitter);
            }
          });
          return result;
        }
        async dispatchFeedback(actions, feedbackEmitter) {
          try {
            const actionDispatcher = await this.actionDispatcher();
            await actionDispatcher.dispatchAll(actions);
            this.logger.info(this, `Dispatched feedback actions for ${feedbackEmitter}`);
          } catch (reason) {
            this.logger.error(this, "Failed to dispatch feedback actions", reason);
          }
        }
      };
      exports.FeedbackActionDispatcher = FeedbackActionDispatcher;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcherProvider),
        __metadata("design:type", Function)
      ], FeedbackActionDispatcher.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], FeedbackActionDispatcher.prototype, "logger", void 0);
      exports.FeedbackActionDispatcher = FeedbackActionDispatcher = __decorate([
        (0, inversify_1.injectable)()
      ], FeedbackActionDispatcher);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-command.js
  var require_feedback_command = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-command.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackCommand = void 0;
      var sprotty_1 = require_lib5();
      var FeedbackCommand2 = class extends sprotty_1.Command {
        constructor() {
          super(...arguments);
          this.priority = 0;
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.FeedbackCommand = FeedbackCommand2;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/update-model-command.js
  var require_update_model_command = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/update-model-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackAwareUpdateModelCommand = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var FeedbackAwareUpdateModelCommand = class FeedbackAwareUpdateModelCommand extends sprotty_1.UpdateModelCommand {
        constructor(action, actionHandlerRegistryProvider) {
          super(Object.assign({ animate: true }, action));
          actionHandlerRegistryProvider().then((registry) => this.actionHandlerRegistry = registry);
        }
        performUpdate(oldRoot, newRoot, context) {
          if (this.feedbackActionDispatcher && this.actionHandlerRegistry) {
            const tempContext = Object.assign(Object.assign({}, context), { root: newRoot });
            const feedbackCommands = this.getFeedbackCommands(this.actionHandlerRegistry);
            feedbackCommands.forEach((command) => command.execute(tempContext));
          }
          return super.performUpdate(oldRoot, newRoot, context);
        }
        getFeedbackCommands(registry) {
          const result = [];
          this.feedbackActionDispatcher.getRegisteredFeedback().forEach((action) => {
            const commands = registry.get(action.kind).filter((0, sprotty_1.toTypeGuard)(sprotty_1.CommandActionHandler)).map((handler) => handler.handle(action));
            result.push(...commands);
          });
          return result.sort((a, b) => this.getPriority(b) - this.getPriority(a));
        }
        getPriority(command) {
          var _a;
          return (_a = command.priority) !== null && _a !== void 0 ? _a : 0;
        }
        // Override the `createAnimations` implementation and remove the animation for edge morphing. Otherwise routing & reconnect
        // handles flicker after each server update.
        createAnimations(data, root, context) {
          const animations = super.createAnimations(data, root, context);
          return animations.filter((animation) => !(animation instanceof sprotty_1.MorphEdgesAnimation));
        }
      };
      exports.FeedbackAwareUpdateModelCommand = FeedbackAwareUpdateModelCommand;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], FeedbackAwareUpdateModelCommand.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], FeedbackAwareUpdateModelCommand.prototype, "feedbackActionDispatcher", void 0);
      exports.FeedbackAwareUpdateModelCommand = FeedbackAwareUpdateModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(sprotty_1.TYPES.ActionHandlerRegistryProvider)),
        __metadata("design:paramtypes", [Object, Function])
      ], FeedbackAwareUpdateModelCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/focus/focus-state-change-action.js
  var require_focus_state_change_action = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/focus/focus-state-change-action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusStateChangedAction = void 0;
      var sprotty_1 = require_lib5();
      var FocusStateChangedAction;
      (function(FocusStateChangedAction2) {
        FocusStateChangedAction2.KIND = "focusStateChanged";
        function is(object) {
          return sprotty_1.Action.hasKind(object, FocusStateChangedAction2.KIND) && (0, sprotty_1.hasBooleanProp)(object, "hasFocus");
        }
        FocusStateChangedAction2.is = is;
        function create(hasFocus = true) {
          return {
            kind: FocusStateChangedAction2.KIND,
            hasFocus
          };
        }
        FocusStateChangedAction2.create = create;
      })(FocusStateChangedAction || (exports.FocusStateChangedAction = FocusStateChangedAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/focus/focus-tracker.js
  var require_focus_tracker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/focus/focus-tracker.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusTracker = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var FocusTracker = class FocusTracker {
        constructor() {
          this.inActiveCssClass = "inactive";
          this._hasFocus = true;
        }
        get hasFocus() {
          return this._hasFocus;
        }
        get focusElement() {
          return this._focusElement;
        }
        get diagramElement() {
          return this._diagramElement;
        }
        handle(action) {
          if (focus_state_change_action_1.FocusStateChangedAction.is(action)) {
            this._hasFocus = action.hasFocus;
            this._focusElement = document.activeElement;
            this._diagramElement = document.getElementById(this.options.baseDiv);
            if (!this._diagramElement) {
              return;
            }
            if (this.hasFocus) {
              if (this._diagramElement.classList.contains(this.inActiveCssClass)) {
                this._diagramElement.classList.remove(this.inActiveCssClass);
              }
            } else {
              this._diagramElement.classList.add(this.inActiveCssClass);
            }
          }
        }
      };
      exports.FocusTracker = FocusTracker;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], FocusTracker.prototype, "options", void 0);
      exports.FocusTracker = FocusTracker = __decorate([
        (0, inversify_1.injectable)()
      ], FocusTracker);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/ranked.js
  var require_ranked = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/ranked.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Ranked = void 0;
      var sprotty_1 = require_lib5();
      var Ranked;
      (function(Ranked2) {
        Ranked2.DEFAULT_RANK = 0;
        function is(object) {
          return sprotty_1.AnyObject.is(object) && (0, sprotty_1.hasNumberProp)(object, "rank");
        }
        Ranked2.is = is;
        function getRank(object) {
          return is(object) ? object.rank : Ranked2.DEFAULT_RANK;
        }
        Ranked2.getRank = getRank;
      })(Ranked || (exports.Ranked = Ranked = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/model/glsp-model-source.js
  var require_glsp_model_source = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/model/glsp-model-source.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPModelSource = exports.ServerAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var ServerAction;
      (function(ServerAction2) {
        function is(object) {
          return sprotty_1.Action.is(object) && "__receivedFromServer" in object && object.__receivedFromServer === true;
        }
        ServerAction2.is = is;
        function mark(action) {
          action.__receivedFromServer = true;
        }
        ServerAction2.mark = mark;
      })(ServerAction || (exports.ServerAction = ServerAction = {}));
      var GLSPModelSource = class GLSPModelSource extends sprotty_1.ModelSource {
        constructor() {
          super(...arguments);
          this.toDispose = new sprotty_1.DisposableCollection();
        }
        get diagramType() {
          return this.options.diagramType;
        }
        get sourceUri() {
          return this.options.sourceUri;
        }
        /**
         * Configure forwarding of server-handled actions to the given {@link GLSPClient} and
         * handling of action received from the `GLSPClient` (i.e. server). It is expected that the
         * given GLSP client has already been initialized.
         * @param glspClient The GLSP  to use.
         * @throws An error if the given `GLSPClient` has not been initialized yet or if the set of server handled
         *         action kinds could not be derived from the initialize result
         */
        configure(glspClient) {
          this.glspClient = glspClient;
          if (!glspClient.initializeResult) {
            throw new Error("Could not configure model source. The GLSP client is not initialized yet!");
          }
          const initializeParams = this.createInitializeClientSessionParameters(glspClient.initializeResult);
          this.configureServeActions(glspClient.initializeResult);
          this.toDispose.push(glspClient.onActionMessage((message) => this.messageReceived(message), this.clientId), sprotty_1.Disposable.create(() => glspClient.disposeClientSession(this.createDisposeClientSessionParameters())));
          return glspClient.initializeClientSession(initializeParams);
        }
        createInitializeClientSessionParameters(_initializeResult) {
          const clientActionKinds = this.registry.getHandledActionKinds();
          return {
            clientSessionId: this.clientId,
            clientActionKinds,
            diagramType: this.diagramType
          };
        }
        createDisposeClientSessionParameters() {
          return {
            clientSessionId: this.clientId
          };
        }
        configureServeActions(initializeResult) {
          const serverActions = initializeResult.serverActions[this.diagramType];
          if ((serverActions === null || serverActions === void 0 ? void 0 : serverActions.length) === 0) {
            throw new Error(`No server-handled actions could be derived from the initialize result for diagramType: ${this.diagramType}!`);
          }
          serverActions.forEach((action) => this.registry.register(action, this));
        }
        messageReceived(message) {
          if (this.clientId !== message.clientId) {
            return;
          }
          const action = message.action;
          ServerAction.mark(action);
          this.logger.log(this, "receiving", action);
          this.actionDispatcher.dispatch(action);
        }
        initialize(registry) {
          var _a;
          if (!this.clientId) {
            this.clientId = (_a = this.options.clientId) !== null && _a !== void 0 ? _a : this.viewerOptions.baseDiv;
          }
          this.registry = registry;
        }
        handle(action) {
          if (this.shouldForwardToServer(action)) {
            this.forwardToServer(action);
          }
        }
        forwardToServer(action) {
          const message = {
            clientId: this.clientId,
            action
          };
          this.logger.log(this, "sending", message);
          if (this.glspClient) {
            this.glspClient.sendActionMessage(message);
          } else {
            throw new Error("GLSPClient is not connected");
          }
        }
        shouldForwardToServer(action) {
          return !ServerAction.is(action);
        }
        commitModel(newRoot) {
          this._currentRoot = newRoot;
          return newRoot;
        }
        get model() {
          return this._currentRoot;
        }
        dispose() {
          this.toDispose.dispose();
        }
      };
      exports.GLSPModelSource = GLSPModelSource;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], GLSPModelSource.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], GLSPModelSource.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], GLSPModelSource.prototype, "dispose", null);
      exports.GLSPModelSource = GLSPModelSource = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPModelSource);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/model/diagram-loader.js
  var require_diagram_loader = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/model/diagram-loader.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramLoader = exports.IDiagramStartup = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var ranked_1 = require_ranked();
      var glsp_model_source_1 = require_glsp_model_source();
      var model_initialization_constraint_1 = require_model_initialization_constraint();
      var IDiagramStartup;
      (function(IDiagramStartup2) {
        function is(object) {
          return sprotty_1.AnyObject.is(object) && (0, sprotty_1.hasNumberProp)(object, "rank", true) && ("preInitialize" in object || "preRequestModel" in object || "postRequestModel" in object || "postModelInitialization" in object);
        }
        IDiagramStartup2.is = is;
      })(IDiagramStartup || (exports.IDiagramStartup = IDiagramStartup = {}));
      var DiagramLoader = class DiagramLoader {
        constructor() {
          this.diagramStartups = [];
        }
        postConstruct() {
          this.diagramStartups.sort((a, b) => ranked_1.Ranked.getRank(a) - ranked_1.Ranked.getRank(b));
        }
        async load(options = {}) {
          var _a, _b;
          const resolvedOptions = {
            requestModelOptions: Object.assign({ sourceUri: (_a = this.options.sourceUri) !== null && _a !== void 0 ? _a : "", diagramType: this.options.diagramType }, options.requestModelOptions),
            initializeParameters: Object.assign({ applicationId: sprotty_1.ApplicationIdProvider.get(), protocolVersion: sprotty_1.GLSPClient.protocolVersion }, options.initializeParameters),
            enableNotifications: (_b = options.enableNotifications) !== null && _b !== void 0 ? _b : true
          };
          await this.actionDispatcher.dispatch(sprotty_1.SetModelAction.create(sprotty_1.EMPTY_ROOT));
          await this.invokeStartupHook("preInitialize");
          await this.initialize(resolvedOptions);
          await this.invokeStartupHook("preRequestModel");
          await this.requestModel(resolvedOptions);
          await this.invokeStartupHook("postRequestModel");
          this.modelInitializationConstraint.onInitialized(() => this.invokeStartupHook("postModelInitialization"));
        }
        async invokeStartupHook(hook) {
          var _a;
          for (const startup of this.diagramStartups) {
            await ((_a = startup[hook]) === null || _a === void 0 ? void 0 : _a.call(startup));
          }
        }
        async requestModel(options) {
          const response = await this.actionDispatcher.request(sprotty_1.RequestModelAction.create({ options: options.requestModelOptions }));
          return this.actionDispatcher.dispatch(response);
        }
        async initialize(options) {
          if (options.enableNotifications) {
            await this.actionDispatcher.dispatch(sprotty_1.StatusAction.create("Initializing...", { severity: "INFO" }));
          }
          const glspClient = await this.options.glspClientProvider();
          await glspClient.start();
          if (!glspClient.initializeResult) {
            await glspClient.initializeServer(options.initializeParameters);
          }
          this.modelSource.configure(glspClient);
          if (options.enableNotifications) {
            this.actionDispatcher.dispatch(sprotty_1.StatusAction.create("", { severity: "NONE" }));
          }
        }
      };
      exports.DiagramLoader = DiagramLoader;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], DiagramLoader.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(action_dispatcher_1.GLSPActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], DiagramLoader.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.multiInject)(sprotty_1.TYPES.IDiagramStartup),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], DiagramLoader.prototype, "diagramStartups", void 0);
      __decorate([
        (0, inversify_1.inject)(glsp_model_source_1.GLSPModelSource),
        __metadata("design:type", glsp_model_source_1.GLSPModelSource)
      ], DiagramLoader.prototype, "modelSource", void 0);
      __decorate([
        (0, inversify_1.inject)(model_initialization_constraint_1.ModelInitializationConstraint),
        __metadata("design:type", model_initialization_constraint_1.ModelInitializationConstraint)
      ], DiagramLoader.prototype, "modelInitializationConstraint", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], DiagramLoader.prototype, "postConstruct", null);
      exports.DiagramLoader = DiagramLoader = __decorate([
        (0, inversify_1.injectable)()
      ], DiagramLoader);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/model/model-registry.js
  var require_model_registry = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/model/model-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GModelRegistry = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var args_feature_1 = require_args_feature();
      var GModelRegistry = class GModelRegistry extends sprotty_1.SModelRegistry {
        /* Overwrite the `register` method to only log an info message (instead of thrown an error) if
           an existing registration is overwritten */
        register(key, factory) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            console.log(`Factory for model element '${key}' will be overwritten.`);
          }
          this.elements.set(key, factory);
        }
        getDefaultFeatures(constr) {
          var _a;
          const features = [...(_a = super.getDefaultFeatures(constr)) !== null && _a !== void 0 ? _a : []];
          if (!features.includes(args_feature_1.argsFeature)) {
            features.push(args_feature_1.argsFeature);
          }
          return features;
        }
      };
      exports.GModelRegistry = GModelRegistry;
      exports.GModelRegistry = GModelRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], GModelRegistry);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/selection-clearing-mouse-listener.js
  var require_selection_clearing_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/selection-clearing-mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectionClearingMouseListener = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var SelectionClearingMouseListener = class SelectionClearingMouseListener extends sprotty_1.MouseListener {
        mouseDown(_target, event) {
          const selection = document.getSelection();
          if (selection === null) {
            return [];
          }
          selection.removeAllRanges();
          selection.addRange(document.createRange());
          return [];
        }
      };
      exports.SelectionClearingMouseListener = SelectionClearingMouseListener;
      exports.SelectionClearingMouseListener = SelectionClearingMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], SelectionClearingMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/tool-manager/tool.js
  var require_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/tool-manager/tool.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Tool = exports.EnableDefaultToolsAction = exports.EnableToolsAction = void 0;
      var sprotty_1 = require_lib5();
      var EnableToolsAction;
      (function(EnableToolsAction2) {
        EnableToolsAction2.KIND = "enable-tools";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableToolsAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "toolIds");
        }
        EnableToolsAction2.is = is;
        function create(toolIds) {
          return {
            kind: EnableToolsAction2.KIND,
            toolIds
          };
        }
        EnableToolsAction2.create = create;
      })(EnableToolsAction || (exports.EnableToolsAction = EnableToolsAction = {}));
      var EnableDefaultToolsAction;
      (function(EnableDefaultToolsAction2) {
        EnableDefaultToolsAction2.KIND = "enable-default-tools";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableDefaultToolsAction2.KIND);
        }
        EnableDefaultToolsAction2.is = is;
        function create() {
          return {
            kind: EnableDefaultToolsAction2.KIND
          };
        }
        EnableDefaultToolsAction2.create = create;
      })(EnableDefaultToolsAction || (exports.EnableDefaultToolsAction = EnableDefaultToolsAction = {}));
      var Tool;
      (function(Tool2) {
        function is(object) {
          return sprotty_1.AnyObject.is(object) && (0, sprotty_1.hasStringProp)(object, "id") && (0, sprotty_1.hasFunctionProp)(object, "enable") && (0, sprotty_1.hasFunctionProp)(object, "disable") && (0, sprotty_1.hasBooleanProp)(object, "isEditTool", true);
        }
        Tool2.is = is;
      })(Tool || (exports.Tool = Tool = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/tool-manager/tool-manager.js
  var require_tool_manager = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/tool-manager/tool-manager.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultToolsEnablingKeyListener = exports.ToolManagerActionHandler = exports.ToolManager = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var tool_1 = require_tool();
      var ToolManager = class ToolManager {
        constructor(tools = [], defaultTools, contextServiceProvider) {
          this.tools = tools;
          this.defaultTools = defaultTools;
          this.contextServiceProvider = contextServiceProvider;
          this.actives = [];
          this.registerTools(...this.tools);
          this.registerDefaultTools(...this.defaultTools);
          this.enableDefaultTools();
          this.contextServiceProvider().then((editorContext) => {
            editorContext.onEditModeChanged((change) => this.editModeChanged(change.newValue, change.oldValue));
            this.editorContext = editorContext;
          });
        }
        get managedTools() {
          return this.defaultTools.concat(this.tools);
        }
        get activeTools() {
          return this.actives;
        }
        registerDefaultTools(...tools) {
          (0, sprotty_1.distinctAdd)(this.defaultTools, ...tools);
        }
        registerTools(...tools) {
          (0, sprotty_1.distinctAdd)(this.tools, ...tools);
        }
        disableActiveTools() {
          this.actives.forEach((tool) => tool.disable());
          this.actives.splice(0, this.actives.length);
        }
        enableDefaultTools() {
          this.enable(this.defaultTools.map((tool) => tool.id));
        }
        enable(toolIds) {
          this.disableActiveTools();
          let tools = toolIds.map((id) => this.tool(id));
          if (this.editorContext && this.editorContext.isReadonly) {
            tools = tools.filter((tool) => !(tool === null || tool === void 0 ? void 0 : tool.isEditTool));
          }
          tools.forEach((tool) => {
            if (tool !== void 0) {
              tool.enable();
              this.actives.push(tool);
            }
          });
        }
        tool(toolId) {
          return this.managedTools.find((tool) => tool.id === toolId);
        }
        disableEditTools() {
          this.disableActiveTools();
          this.enable(this.defaultTools.filter((tool) => !tool.isEditTool).map((tool) => tool.id));
        }
        editModeChanged(newValue, oldValue) {
          if (oldValue === newValue) {
            return;
          }
          if (newValue === sprotty_1.EditMode.READONLY) {
            this.disableEditTools();
          } else if (newValue === sprotty_1.EditMode.EDITABLE) {
            this.enableDefaultTools();
          }
        }
      };
      exports.ToolManager = ToolManager;
      exports.ToolManager = ToolManager = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(sprotty_1.TYPES.ITool)),
        __param(0, (0, inversify_1.optional)()),
        __param(1, (0, inversify_1.multiInject)(sprotty_1.TYPES.IDefaultTool)),
        __param(1, (0, inversify_1.optional)()),
        __param(2, (0, inversify_1.inject)(sprotty_1.TYPES.IEditorContextServiceProvider)),
        __metadata("design:paramtypes", [Array, Array, Function])
      ], ToolManager);
      var ToolManagerActionHandler = class ToolManagerActionHandler {
        handle(action) {
          if (tool_1.EnableDefaultToolsAction.is(action)) {
            this.toolManager.enableDefaultTools();
          } else if (tool_1.EnableToolsAction.is(action)) {
            this.toolManager.enable(action.toolIds);
          }
        }
      };
      exports.ToolManagerActionHandler = ToolManagerActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IToolManager),
        __metadata("design:type", Object)
      ], ToolManagerActionHandler.prototype, "toolManager", void 0);
      exports.ToolManagerActionHandler = ToolManagerActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ToolManagerActionHandler);
      var DefaultToolsEnablingKeyListener = class DefaultToolsEnablingKeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            return [tool_1.EnableDefaultToolsAction.create()];
          }
          return [];
        }
      };
      exports.DefaultToolsEnablingKeyListener = DefaultToolsEnablingKeyListener;
      exports.DefaultToolsEnablingKeyListener = DefaultToolsEnablingKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultToolsEnablingKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/view/mouse-tool.js
  var require_mouse_tool2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/view/mouse-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPMouseTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var ranked_1 = require_ranked();
      var GLSPMouseTool = class GLSPMouseTool extends sprotty_1.MouseTool {
        constructor(mouseListeners = []) {
          super(mouseListeners);
          this.mouseListeners = mouseListeners;
          this.rankedMouseListeners = groupBy(mouseListeners, (listener) => ranked_1.Ranked.getRank(listener));
        }
        register(mouseListener) {
          super.register(mouseListener);
          this.rankedMouseListeners = groupBy(this.mouseListeners, (listener) => ranked_1.Ranked.getRank(listener));
        }
        registerListener(mouseListener) {
          this.register(mouseListener);
          return sprotty_1.Disposable.create(() => this.deregister(mouseListener));
        }
        deregister(mouseListener) {
          super.deregister(mouseListener);
          this.rankedMouseListeners = groupBy(this.mouseListeners, (listener) => ranked_1.Ranked.getRank(listener));
        }
        handleEvent(methodName, model, event) {
          this.focusOnMouseEvent(methodName, model);
          const element = this.getTargetElement(model, event);
          if (!element) {
            return;
          }
          this.notifyListenersByRank(element, methodName, event);
        }
        async notifyListenersByRank(element, methodName, event) {
          for (const rank of this.rankedMouseListeners) {
            await this.dispatchActions(rank[1], methodName, element, event);
          }
        }
        async dispatchActions(mouseListeners, methodName, element, event) {
          const actions = mouseListeners.map((listener) => listener[methodName](element, event)).reduce((a, b) => a.concat(b));
          if (actions.length > 0) {
            event.preventDefault();
            for (const actionOrPromise of actions) {
              if (sprotty_1.Action.is(actionOrPromise)) {
                await this.actionDispatcher.dispatch(actionOrPromise);
              } else {
                actionOrPromise.then((action) => {
                  this.actionDispatcher.dispatch(action);
                });
              }
            }
          }
        }
      };
      exports.GLSPMouseTool = GLSPMouseTool;
      exports.GLSPMouseTool = GLSPMouseTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(sprotty_1.TYPES.MouseListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], GLSPMouseTool);
      function groupBy(array, keyFunction) {
        const unsortedMap = array.reduce((result, item) => {
          const key = keyFunction(item);
          if (!result.has(key)) {
            result.set(key, [item]);
          } else {
            const entries = result.get(key);
            if (entries) {
              entries.push(item);
            }
          }
          return result;
        }, /* @__PURE__ */ new Map());
        return new Map([...unsortedMap.entries()].sort());
      }
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/view/view-registry.js
  var require_view_registry = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/view/view-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GViewRegistry = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var GViewRegistry = class GViewRegistry extends sprotty_1.ViewRegistry {
        /* Overwrite the `register` method to only log an info message (instead of thrown an error) if
           an existing registration is overwritten */
        register(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            console.log(`View instance for type '${key}' will be overwritten.`);
          }
          this.elements.set(key, instance);
        }
      };
      exports.GViewRegistry = GViewRegistry;
      exports.GViewRegistry = GViewRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], GViewRegistry);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/css-feedback.js
  var require_css_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/css-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deleteCssClasses = exports.applyCssClasses = exports.cursorFeedbackAction = exports.CursorCSS = exports.ModifyCssFeedbackCommand = exports.ModifyCSSFeedbackAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var gmodel_util_1 = require_gmodel_util();
      var feedback_command_1 = require_feedback_command();
      var ModifyCSSFeedbackAction;
      (function(ModifyCSSFeedbackAction2) {
        ModifyCSSFeedbackAction2.KIND = "modifyCSSFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ModifyCSSFeedbackAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "elementIds");
        }
        ModifyCSSFeedbackAction2.is = is;
        function create(options) {
          const { elements } = options, rest = __rest(options, ["elements"]);
          const elementIds = elements ? elements.map((element) => typeof element === "string" ? element : element.id) : void 0;
          return Object.assign({ kind: ModifyCSSFeedbackAction2.KIND, elementIds }, rest);
        }
        ModifyCSSFeedbackAction2.create = create;
      })(ModifyCSSFeedbackAction || (exports.ModifyCSSFeedbackAction = ModifyCSSFeedbackAction = {}));
      var ModifyCssFeedbackCommand = class ModifyCssFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const elements = this.action.elementIds ? (0, gmodel_util_1.getElements)(context.root.index, this.action.elementIds) : [context.root];
          elements.forEach((e) => {
            if (this.action.remove) {
              (0, gmodel_util_1.removeCssClasses)(e, this.action.remove);
            }
            if (this.action.add) {
              (0, gmodel_util_1.addCssClasses)(e, this.action.add);
            }
          });
          return context.root;
        }
      };
      exports.ModifyCssFeedbackCommand = ModifyCssFeedbackCommand;
      ModifyCssFeedbackCommand.KIND = ModifyCSSFeedbackAction.KIND;
      exports.ModifyCssFeedbackCommand = ModifyCssFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ModifyCssFeedbackCommand);
      var CursorCSS;
      (function(CursorCSS2) {
        CursorCSS2["DEFAULT"] = "default-mode";
        CursorCSS2["OVERLAP_FORBIDDEN"] = "overlap-forbidden-mode";
        CursorCSS2["NODE_CREATION"] = "node-creation-mode";
        CursorCSS2["EDGE_CREATION_SOURCE"] = "edge-creation-select-source-mode";
        CursorCSS2["EDGE_CREATION_TARGET"] = "edge-creation-select-target-mode";
        CursorCSS2["EDGE_RECONNECT"] = "edge-reconnect-select-target-mode";
        CursorCSS2["EDGE_CHECK_PENDING"] = "edge-check-pending-mode";
        CursorCSS2["OPERATION_NOT_ALLOWED"] = "edge-modification-not-allowed-mode";
        CursorCSS2["ELEMENT_DELETION"] = "element-deletion-mode";
        CursorCSS2["RESIZE_NESW"] = "resize-nesw-mode";
        CursorCSS2["RESIZE_NWSE"] = "resize-nwse-mode";
        CursorCSS2["MOVE"] = "move-mode";
        CursorCSS2["MARQUEE"] = "marquee-mode";
      })(CursorCSS || (exports.CursorCSS = CursorCSS = {}));
      function cursorFeedbackAction(cursorCss) {
        const add = [];
        if (cursorCss) {
          add.push(cursorCss);
        }
        return ModifyCSSFeedbackAction.create({ add, remove: Object.values(CursorCSS) });
      }
      exports.cursorFeedbackAction = cursorFeedbackAction;
      function applyCssClasses(element, ...add) {
        return ModifyCSSFeedbackAction.create({ elements: [element], add });
      }
      exports.applyCssClasses = applyCssClasses;
      function deleteCssClasses(element, ...remove) {
        return ModifyCSSFeedbackAction.create({ elements: [element], remove });
      }
      exports.deleteCssClasses = deleteCssClasses;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hints/model.js
  var require_model20 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hints/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isReparentable = exports.reparentFeature = exports.isContainable = exports.containerFeature = void 0;
      exports.containerFeature = Symbol("containable");
      function isContainable(element) {
        return element.hasFeature(exports.containerFeature);
      }
      exports.isContainable = isContainable;
      exports.reparentFeature = Symbol("reparentFeature");
      function isReparentable(element) {
        return element.hasFeature(exports.reparentFeature);
      }
      exports.isReparentable = isReparentable;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/model.js
  var require_model21 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GEdge = exports.GGraph = void 0;
      var sprotty_1 = require_lib5();
      var args_feature_1 = require_args_feature();
      var model_1 = require_model20();
      var GGraph = class extends sprotty_1.SGraphImpl {
        isContainableElement(_input) {
          return true;
        }
      };
      exports.GGraph = GGraph;
      GGraph.DEFAULT_FEATURES = [...sprotty_1.SGraphImpl.DEFAULT_FEATURES, model_1.containerFeature, args_feature_1.argsFeature];
      var GEdge2 = class extends sprotty_1.SEdgeImpl {
        localToParent(point) {
          const bounds = (0, sprotty_1.getRouteBounds)(this.routingPoints);
          const result = {
            x: point.x + bounds.x,
            y: point.y + bounds.y,
            width: -1,
            height: -1
          };
          if ((0, sprotty_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
        parentToLocal(point) {
          const bounds = (0, sprotty_1.getRouteBounds)(this.routingPoints);
          const result = {
            x: point.x - bounds.x,
            y: point.y - bounds.y,
            width: -1,
            height: -1
          };
          if ((0, sprotty_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
      };
      exports.GEdge = GEdge2;
      GEdge2.DEFAULT_FEATURES = [...sprotty_1.SEdgeImpl.DEFAULT_FEATURES, args_feature_1.argsFeature];
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/reposition.js
  var require_reposition = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/reposition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RepositionCommand = exports.RepositionAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model21();
      var RepositionAction;
      (function(RepositionAction2) {
        RepositionAction2.KIND = "repositionAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, RepositionAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "elementIDs");
        }
        RepositionAction2.is = is;
        function create(elementIDs) {
          return {
            kind: RepositionAction2.KIND,
            elementIDs
          };
        }
        RepositionAction2.create = create;
      })(RepositionAction || (exports.RepositionAction = RepositionAction = {}));
      var RepositionCommand = class RepositionCommand extends sprotty_1.BoundsAwareViewportCommand {
        constructor(action) {
          super(true);
          this.action = action;
        }
        boundsInViewport(element, bounds, viewport) {
          var _a;
          if (element instanceof sprotty_1.GChildElement && element.parent !== viewport) {
            return this.boundsInViewport(element.parent, element.parent.localToParent(bounds), viewport);
          } else if (element instanceof model_1.GEdge) {
            const edgeBounds = (0, sprotty_1.getRouteBounds)((_a = (0, gmodel_util_1.calcElementAndRoute)(element).newRoutingPoints) !== null && _a !== void 0 ? _a : []);
            if (element instanceof sprotty_1.GChildElement && element.parent !== viewport) {
              return this.boundsInViewport(element.parent, element.parent.localToParent(edgeBounds), viewport);
            }
            return edgeBounds;
          }
          return bounds;
        }
        getElementIds() {
          return this.action.elementIDs;
        }
        getNewViewport(bounds, model) {
          if (!sprotty_1.Dimension.isValid(model.canvasBounds)) {
            return void 0;
          }
          if ((0, sprotty_1.isViewport)(model)) {
            const zoom = model.zoom;
            const c = sprotty_1.Bounds.center(bounds);
            if (this.isFullyVisible(bounds, model)) {
              return void 0;
            } else {
              return {
                scroll: {
                  x: c.x - 0.5 * model.canvasBounds.width / zoom,
                  y: c.y - 0.5 * model.canvasBounds.height / zoom
                },
                zoom
              };
            }
          }
          return void 0;
        }
        isFullyVisible(bounds, viewport) {
          return bounds.x >= viewport.scroll.x && bounds.x + bounds.width <= viewport.scroll.x + viewport.canvasBounds.width / viewport.zoom && bounds.y >= viewport.scroll.y && bounds.y + bounds.height <= viewport.scroll.y + viewport.canvasBounds.height / viewport.zoom;
        }
      };
      exports.RepositionCommand = RepositionCommand;
      RepositionCommand.KIND = RepositionAction.KIND;
      exports.RepositionCommand = RepositionCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], RepositionCommand);
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape2;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _ = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else {
          root._ = _;
        }
      }).call(exports);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/key-shortcut/accessible-key-shortcut.js
  var require_accessible_key_shortcut = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/key-shortcut/accessible-key-shortcut.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var KeyShortcutUIExtension_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyShortcutUIExtension = exports.SetAccessibleKeyShortcutAction = void 0;
      var inversify_1 = require_inversify();
      var lodash_1 = require_lodash();
      var sprotty_1 = require_lib5();
      var SetAccessibleKeyShortcutAction;
      (function(SetAccessibleKeyShortcutAction2) {
        SetAccessibleKeyShortcutAction2.KIND = "setAccessibleKeyShortcut";
        function is(object) {
          return sprotty_1.Action.hasKind(object, SetAccessibleKeyShortcutAction2.KIND);
        }
        SetAccessibleKeyShortcutAction2.is = is;
        function create(options) {
          return { kind: SetAccessibleKeyShortcutAction2.KIND, token: options.token, keys: options.keys };
        }
        SetAccessibleKeyShortcutAction2.create = create;
      })(SetAccessibleKeyShortcutAction || (exports.SetAccessibleKeyShortcutAction = SetAccessibleKeyShortcutAction = {}));
      var KeyShortcutUIExtension = KeyShortcutUIExtension_1 = class KeyShortcutUIExtension extends sprotty_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.registrations = {};
        }
        handle(action) {
          if (SetAccessibleKeyShortcutAction.is(action)) {
            this.registrations[action.token] = action.keys;
            if (this.containerElement) {
              this.refreshUI();
            }
          }
        }
        id() {
          return KeyShortcutUIExtension_1.ID;
        }
        containerClass() {
          return KeyShortcutUIExtension_1.ID;
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.shortcutsContainer.focus();
        }
        refreshUI() {
          this.shortcutsContainer.innerHTML = "";
          const registrations = Object.values(this.registrations).flatMap((r) => r);
          registrations.sort((a, b) => {
            if (a.group < b.group) {
              return -1;
            }
            if (a.group > b.group) {
              return 1;
            }
            return a.position - b.position;
          });
          const grouped = (0, lodash_1.groupBy)(registrations, (k) => k.group);
          const groupTable = document.createElement("table");
          groupTable.classList.add("shortcut-table");
          const tableHead = document.createElement("thead");
          const tableBody = document.createElement("tbody");
          const headerRow = document.createElement("tr");
          const commandCell = document.createElement("th");
          const keybindingCell = document.createElement("th");
          commandCell.classList.add("column-title");
          commandCell.innerText = "Command";
          keybindingCell.innerText = "Keybinding";
          headerRow.appendChild(commandCell);
          headerRow.appendChild(keybindingCell);
          tableHead.appendChild(headerRow);
          for (const [group, shortcuts] of Object.entries(grouped)) {
            tableBody.appendChild(this.createGroupHeader(group));
            shortcuts.forEach((s) => {
              tableBody.appendChild(this.createEntry(s));
            });
          }
          groupTable.appendChild(tableHead);
          groupTable.appendChild(tableBody);
          this.shortcutsContainer.append(groupTable);
        }
        createGroupHeader(group) {
          const entryRow = document.createElement("tr");
          const groupElement = document.createElement("td");
          const text = document.createElement("strong");
          const emptyElement = document.createElement("td");
          text.innerText = group;
          groupElement.appendChild(text);
          entryRow.appendChild(groupElement);
          entryRow.appendChild(emptyElement);
          return entryRow;
        }
        getShortcutHTML(shortcuts) {
          const shortcutKeys = document.createElement("span");
          shortcutKeys.innerHTML = shortcuts.map((key) => `<kbd>${key}</kbd>`).join(" + ");
          return shortcutKeys;
        }
        createEntry(registration) {
          const entryRow = document.createElement("tr");
          const shortcutElement = document.createElement("td");
          const descElement = document.createElement("td");
          const shortcut = this.getShortcutHTML(registration.shortcuts);
          descElement.innerText = registration.description;
          shortcutElement.appendChild(shortcut);
          entryRow.appendChild(descElement);
          entryRow.appendChild(shortcutElement);
          return entryRow;
        }
        initializeContents(containerElement) {
          this.container = document.createElement("div");
          this.container.classList.add("keyboard-shortcuts-menu");
          const menuTitle = document.createElement("h3");
          menuTitle.classList.add("menu-header");
          menuTitle.innerText = "Keyboard Shortcuts";
          this.container.appendChild(menuTitle);
          const closeBtn = document.createElement("button");
          closeBtn.id = "key-shortcut-close-btn";
          closeBtn.textContent = "x";
          closeBtn.addEventListener("click", () => {
            this.hide();
          });
          this.container.appendChild(closeBtn);
          this.shortcutsContainer = document.createElement("div");
          this.shortcutsContainer.classList.add("keyboard-shortcuts-container");
          this.shortcutsContainer.tabIndex = 30;
          this.shortcutsContainer.addEventListener("keydown", (event) => {
            if (event.key === "Escape" || (0, sprotty_1.matchesKeystroke)(event, "KeyH", "alt")) {
              this.hide();
            }
          });
          this.container.appendChild(this.shortcutsContainer);
          containerElement.appendChild(this.container);
          containerElement.ariaLabel = "Shortcut-Menu";
          this.refreshUI();
        }
      };
      exports.KeyShortcutUIExtension = KeyShortcutUIExtension;
      KeyShortcutUIExtension.ID = "key-shortcut";
      exports.KeyShortcutUIExtension = KeyShortcutUIExtension = KeyShortcutUIExtension_1 = __decorate([
        (0, inversify_1.injectable)()
      ], KeyShortcutUIExtension);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/view/key-tool.js
  var require_key_tool2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/view/key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPKeyTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var GLSPKeyTool = class GLSPKeyTool extends sprotty_1.KeyTool {
        registerListener(keyListener) {
          super.register(keyListener);
          return sprotty_1.Disposable.create(() => this.deregister(keyListener));
        }
      };
      exports.GLSPKeyTool = GLSPKeyTool;
      exports.GLSPKeyTool = GLSPKeyTool = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPKeyTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/base-tools.js
  var require_base_tools = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/base-tools.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseCreationTool = exports.BaseEditTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var editor_context_service_1 = require_editor_context_service();
      var tool_1 = require_tool();
      var key_tool_1 = require_key_tool2();
      var mouse_tool_1 = require_mouse_tool2();
      var BaseEditTool = class BaseEditTool {
        constructor() {
          this.toDisposeOnDisable = new sprotty_1.DisposableCollection();
        }
        disable() {
          this.toDisposeOnDisable.dispose();
        }
        get isEditTool() {
          return true;
        }
        dispatchActions(actions) {
          this.actionDispatcher.dispatchAll(actions);
        }
        /**
         * Registers `actions` to be sent out as feedback, i.e., changes that are re-established whenever the `GModelRoot`
         * has been set or updated.
         *
         * @param feedbackActions the actions to be sent out.
         * @param feedbackEmitter the emitter sending out feedback actions (this tool by default).
         * @param cleanupActions the actions to be sent out when the feedback is de-registered through the returned Disposable.
         * @returns A 'Disposable' that de-registers the feedback and cleans up any pending feedback with the given `cleanupActions`.
         */
        registerFeedback(feedbackActions, feedbackEmitter, cleanupActions) {
          return this.feedbackDispatcher.registerFeedback(feedbackEmitter !== null && feedbackEmitter !== void 0 ? feedbackEmitter : this, feedbackActions, cleanupActions);
        }
        /**
         * De-registers all feedback from the given `feedbackEmitter` (this tool by default) and cleans up any pending feedback with the
         * given `cleanupActions`.
         *
         * @param feedbackEmitter the emitter to be deregistered (this tool by default).
         * @param cleanupActions the actions to be dispatched right after the deregistration to clean up any pending feedback.
         */
        deregisterFeedback(feedbackEmitter, cleanupActions) {
          this.feedbackDispatcher.deregisterFeedback(feedbackEmitter !== null && feedbackEmitter !== void 0 ? feedbackEmitter : this, cleanupActions);
        }
      };
      exports.BaseEditTool = BaseEditTool;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], BaseEditTool.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], BaseEditTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(mouse_tool_1.GLSPMouseTool),
        __metadata("design:type", mouse_tool_1.GLSPMouseTool)
      ], BaseEditTool.prototype, "mouseTool", void 0);
      __decorate([
        (0, inversify_1.inject)(key_tool_1.GLSPKeyTool),
        __metadata("design:type", key_tool_1.GLSPKeyTool)
      ], BaseEditTool.prototype, "keyTool", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], BaseEditTool.prototype, "editorContext", void 0);
      exports.BaseEditTool = BaseEditTool = __decorate([
        (0, inversify_1.injectable)()
      ], BaseEditTool);
      var BaseCreationTool = class BaseCreationTool extends BaseEditTool {
        handle(action) {
          if (this.isTriggerAction(action)) {
            this.triggerAction = action;
            return tool_1.EnableToolsAction.create([this.id]);
          }
        }
        enable() {
          if (this.triggerAction === void 0) {
            throw new TypeError(`Could not enable tool ${this.id}. The triggerAction cannot be undefined.`);
          }
          this.doEnable();
        }
      };
      exports.BaseCreationTool = BaseCreationTool;
      exports.BaseCreationTool = BaseCreationTool = __decorate([
        (0, inversify_1.injectable)()
      ], BaseCreationTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/key-shortcut/accessible-key-shortcut-tool.js
  var require_accessible_key_shortcut_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/key-shortcut/accessible-key-shortcut-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var AccessibleKeyShortcutTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AccessibleShortcutKeyListener = exports.AccessibleKeyShortcutTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var base_tools_1 = require_base_tools();
      var accessible_key_shortcut_1 = require_accessible_key_shortcut();
      var AccessibleKeyShortcutTool = AccessibleKeyShortcutTool_1 = class AccessibleKeyShortcutTool extends base_tools_1.BaseEditTool {
        constructor() {
          super(...arguments);
          this.shortcutKeyListener = new AccessibleShortcutKeyListener();
        }
        get id() {
          return AccessibleKeyShortcutTool_1.ID;
        }
        enable() {
          this.keytool.register(this.shortcutKeyListener);
        }
        disable() {
          this.keytool.deregister(this.shortcutKeyListener);
        }
      };
      exports.AccessibleKeyShortcutTool = AccessibleKeyShortcutTool;
      AccessibleKeyShortcutTool.ID = "accessible-key-shortcut-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], AccessibleKeyShortcutTool.prototype, "keytool", void 0);
      exports.AccessibleKeyShortcutTool = AccessibleKeyShortcutTool = AccessibleKeyShortcutTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], AccessibleKeyShortcutTool);
      var AccessibleShortcutKeyListener = class extends sprotty_1.KeyListener {
        constructor() {
          super(...arguments);
          this.token = Symbol(AccessibleShortcutKeyListener.name);
        }
        keyDown(element, event) {
          if (this.matchesActivateShortcutHelpKeystroke(event)) {
            return [sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: accessible_key_shortcut_1.KeyShortcutUIExtension.ID, visible: true })];
          }
          return [];
        }
        matchesActivateShortcutHelpKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "KeyH", "alt");
        }
      };
      exports.AccessibleShortcutKeyListener = AccessibleShortcutKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/css/autocomplete-palette.css
  var require_ = __commonJS({
    "node_modules/@eclipse-glsp/client/css/autocomplete-palette.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/base-autocomplete-palette.js
  var require_base_autocomplete_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/base-autocomplete-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseAutocompletePalette = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      require_();
      var action_dispatcher_1 = require_action_dispatcher2();
      var auto_complete_widget_1 = require_auto_complete_widget();
      var BaseAutocompletePalette = class extends sprotty_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.autoSuggestionSettings = {
            noSuggestionsMessage: "No suggestions available",
            suggestionsClass: "command-palette-suggestions",
            debounceWaitMs: 50,
            showOnFocus: true
          };
        }
        containerClass() {
          return "autocomplete-palette";
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.root = root;
          this.autocompleteWidget.open(root);
        }
        hide() {
          var _a;
          (_a = this.autocompleteWidget) === null || _a === void 0 ? void 0 : _a.dispose();
          this.root = void 0;
          super.hide();
        }
        initializeContents(containerElement) {
          containerElement.classList.add("command-palette");
          this.autocompleteWidget = new auto_complete_widget_1.AutoCompleteWidget(this.autoSuggestionSettings, { provideSuggestions: (input) => this.retrieveSuggestions(this.root, input) }, { executeFromSuggestion: (input) => this.executeSuggestion(input) }, (reason) => this.autocompleteHide(reason), this.logger, {
            visibleSuggestionsChanged: (suggestions) => this.visibleSuggestionsChanged(this.root, suggestions),
            selectedSuggestionChanged: (suggestion) => this.selectedSuggestionChanged(this.root, suggestion)
          });
          this.autocompleteWidget.initialize(containerElement);
        }
        async visibleSuggestionsChanged(root, labeledActions) {
          return;
        }
        async selectedSuggestionChanged(root, labeledAction) {
          return;
        }
        autocompleteHide(reason) {
          this.hide();
        }
        executeSuggestion(input) {
          this.actionDispatcher.dispatchAll((0, auto_complete_widget_1.toActionArray)(input));
        }
      };
      exports.BaseAutocompletePalette = BaseAutocompletePalette;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], BaseAutocompletePalette.prototype, "actionDispatcher", void 0);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-palette.js
  var require_search_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var SearchAutocompletePalette_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SearchAutocompletePalette = exports.RevealEdgeElementAutocompleteSuggestionProvider = exports.RevealNodesWithoutNameAutocompleteSuggestionProvider = exports.RevealNamedElementAutocompleteSuggestionProvider = void 0;
      var inversify_1 = require_inversify();
      var lodash_1 = require_lodash();
      var iterable_1 = require_iterable();
      var sprotty_1 = require_lib5();
      var base_autocomplete_palette_1 = require_base_autocomplete_palette();
      var css_feedback_1 = require_css_feedback();
      var reposition_1 = require_reposition();
      var model_1 = require_model21();
      var CSS_SEARCH_HIDDEN = "search-hidden";
      var CSS_SEARCH_HIGHLIGHTED = "search-highlighted";
      var RevealNamedElementAutocompleteSuggestionProvider = class {
        async retrieveSuggestions(root, text) {
          const nameables = (0, iterable_1.toArray)(root.index.all().filter((element) => (0, sprotty_1.isNameable)(element)));
          return nameables.map((nameable) => {
            var _a;
            return {
              element: nameable,
              action: {
                label: `[${nameable.type}] ${(_a = (0, sprotty_1.name)(nameable)) !== null && _a !== void 0 ? _a : "<no-name>"}`,
                actions: this.getActions(nameable),
                icon: (0, sprotty_1.codiconCSSString)("eye")
              }
            };
          });
        }
        getActions(nameable) {
          return [sprotty_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), sprotty_1.CenterAction.create([nameable.id], { retainZoom: true })];
        }
      };
      exports.RevealNamedElementAutocompleteSuggestionProvider = RevealNamedElementAutocompleteSuggestionProvider;
      var RevealNodesWithoutNameAutocompleteSuggestionProvider = class {
        async retrieveSuggestions(root, text) {
          const nodes = (0, iterable_1.toArray)(root.index.all().filter((element) => !(0, sprotty_1.isNameable)(element) && element instanceof sprotty_1.GNode));
          return nodes.map((node) => ({
            element: node,
            action: {
              label: `[${node.type}]`,
              actions: this.getActions(node),
              icon: (0, sprotty_1.codiconCSSString)("symbol-namespace")
            }
          }));
        }
        getActions(nameable) {
          return [sprotty_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), sprotty_1.CenterAction.create([nameable.id], { retainZoom: true })];
        }
      };
      exports.RevealNodesWithoutNameAutocompleteSuggestionProvider = RevealNodesWithoutNameAutocompleteSuggestionProvider;
      var RevealEdgeElementAutocompleteSuggestionProvider = class {
        async retrieveSuggestions(root, text) {
          const edges = (0, iterable_1.toArray)(root.index.all().filter((element) => element instanceof model_1.GEdge));
          return edges.map((edge) => ({
            element: edge,
            action: {
              label: `[${edge.type}]  ${this.getEdgeLabel(root, edge)}`,
              actions: this.getActions(edge),
              icon: (0, sprotty_1.codiconCSSString)("arrow-both")
            }
          }));
        }
        getActions(edge) {
          return [sprotty_1.SelectAction.create({ selectedElementsIDs: [edge.id] }), sprotty_1.CenterAction.create([edge.sourceId, edge.targetId])];
        }
        getEdgeLabel(root, edge) {
          var _a, _b;
          let sourceName = "";
          let targetName = "";
          const sourceNode = root.index.getById(edge.sourceId);
          const targetNode = root.index.getById(edge.targetId);
          if (sourceNode !== void 0) {
            sourceName = (_a = (0, sprotty_1.name)(sourceNode)) !== null && _a !== void 0 ? _a : sourceNode.type;
          }
          if (targetNode !== void 0) {
            targetName = (_b = (0, sprotty_1.name)(targetNode)) !== null && _b !== void 0 ? _b : targetNode.type;
          }
          return sourceName + " -> " + targetName;
        }
      };
      exports.RevealEdgeElementAutocompleteSuggestionProvider = RevealEdgeElementAutocompleteSuggestionProvider;
      var SearchAutocompletePalette = SearchAutocompletePalette_1 = class SearchAutocompletePalette extends base_autocomplete_palette_1.BaseAutocompletePalette {
        constructor() {
          super(...arguments);
          this.cachedSuggestions = [];
        }
        id() {
          return SearchAutocompletePalette_1.ID;
        }
        initializeContents(containerElement) {
          super.initializeContents(containerElement);
          this.autocompleteWidget.inputField.placeholder = "Search for elements";
          containerElement.setAttribute("aria-label", "Search Field");
        }
        getSuggestionProviders(root, input) {
          return [
            new RevealNamedElementAutocompleteSuggestionProvider(),
            new RevealEdgeElementAutocompleteSuggestionProvider(),
            new RevealNodesWithoutNameAutocompleteSuggestionProvider()
          ];
        }
        async retrieveSuggestions(root, input) {
          const providers = this.getSuggestionProviders(root, input);
          const suggestions = (await Promise.all(providers.map((provider) => provider.retrieveSuggestions(root, input)))).flat(1);
          this.cachedSuggestions = suggestions;
          return suggestions.map((s) => s.action);
        }
        async visibleSuggestionsChanged(root, labeledActions) {
          await this.applyCSS(this.getHiddenElements(root, this.getSuggestionsFromLabeledActions(labeledActions)), CSS_SEARCH_HIDDEN);
          await this.deleteCSS(this.getSuggestionsFromLabeledActions(labeledActions).map((s) => s.element), CSS_SEARCH_HIDDEN);
        }
        async selectedSuggestionChanged(root, labeledAction) {
          await this.deleteAllCSS(root, CSS_SEARCH_HIGHLIGHTED);
          if (labeledAction !== void 0) {
            const suggestions = this.getSuggestionsFromLabeledActions([labeledAction]);
            const actions = [];
            suggestions.map((currElem) => actions.push(reposition_1.RepositionAction.create([currElem.element.id])));
            this.actionDispatcher.dispatchAll(actions);
            await this.applyCSS(suggestions.map((s) => s.element), CSS_SEARCH_HIGHLIGHTED);
          }
        }
        show(root, ...contextElementIds) {
          this.actionDispatcher.dispatch(sprotty_1.SelectAllAction.create(false));
          super.show(root, ...contextElementIds);
        }
        hide() {
          if (this.root !== void 0) {
            this.deleteAllCSS(this.root, CSS_SEARCH_HIDDEN);
            this.deleteAllCSS(this.root, CSS_SEARCH_HIGHLIGHTED);
            this.autocompleteWidget.inputField.value = "";
          }
          super.hide();
        }
        applyCSS(elements, cssClass) {
          const actions = elements.map((element) => (0, css_feedback_1.applyCssClasses)(element, cssClass));
          return this.actionDispatcher.dispatchAll(actions);
        }
        deleteCSS(elements, cssClass) {
          const actions = elements.map((element) => (0, css_feedback_1.deleteCssClasses)(element, cssClass));
          return this.actionDispatcher.dispatchAll(actions);
        }
        deleteAllCSS(root, cssClass) {
          const actions = (0, iterable_1.toArray)(root.index.all().map((element) => (0, css_feedback_1.deleteCssClasses)(element, cssClass)));
          return this.actionDispatcher.dispatchAll(actions);
        }
        getSuggestionsFromLabeledActions(labeledActions) {
          return this.cachedSuggestions.filter((c) => labeledActions.find((s) => (0, lodash_1.isEqual)(s, c.action)));
        }
        getHiddenSuggestionsFromLabeledActions(labeledActions) {
          return this.cachedSuggestions.filter((c) => !labeledActions.find((s) => (0, lodash_1.isEqual)(s, c.action)));
        }
        getHiddenElements(root, suggestions) {
          return (0, iterable_1.toArray)(root.index.all().filter((element) => element instanceof sprotty_1.GNode || element instanceof model_1.GEdge).filter((element) => suggestions.find((suggestion) => suggestion.element.id === element.id) === void 0));
        }
      };
      exports.SearchAutocompletePalette = SearchAutocompletePalette;
      SearchAutocompletePalette.ID = "search-autocomplete-palette";
      exports.SearchAutocompletePalette = SearchAutocompletePalette = SearchAutocompletePalette_1 = __decorate([
        (0, inversify_1.injectable)()
      ], SearchAutocompletePalette);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-tool.js
  var require_search_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var SearchAutocompletePaletteTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SearchAutocompletePaletteKeyListener = exports.SearchAutocompletePaletteTool = void 0;
      var inversify_1 = require_inversify();
      var keyboard_1 = require_keyboard();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var accessible_key_shortcut_1 = require_accessible_key_shortcut();
      var search_palette_1 = require_search_palette();
      var SearchAutocompletePaletteTool = SearchAutocompletePaletteTool_1 = class SearchAutocompletePaletteTool {
        constructor() {
          this.keyListener = new SearchAutocompletePaletteKeyListener(this);
        }
        get id() {
          return SearchAutocompletePaletteTool_1.ID;
        }
        enable() {
          this.keyTool.register(this.keyListener);
          this.keyListener.registerShortcutKey();
        }
        disable() {
          this.keyTool.deregister(this.keyListener);
        }
      };
      exports.SearchAutocompletePaletteTool = SearchAutocompletePaletteTool;
      SearchAutocompletePaletteTool.ID = "glsp.search-autocomplete-palette-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], SearchAutocompletePaletteTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], SearchAutocompletePaletteTool.prototype, "keyTool", void 0);
      exports.SearchAutocompletePaletteTool = SearchAutocompletePaletteTool = SearchAutocompletePaletteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], SearchAutocompletePaletteTool);
      var SearchAutocompletePaletteKeyListener = class extends sprotty_1.KeyListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.token = search_palette_1.SearchAutocompletePalette.name;
        }
        registerShortcutKey() {
          this.tool.actionDispatcher.dispatchOnceModelInitialized(accessible_key_shortcut_1.SetAccessibleKeyShortcutAction.create({
            token: this.token,
            keys: [{ shortcuts: ["CTRL", "F"], description: "Activate search for elements", group: "Search", position: 0 }]
          }));
        }
        keyDown(element, event) {
          if (this.matchesSearchActivateKeystroke(event)) {
            return [
              sprotty_1.SetUIExtensionVisibilityAction.create({
                extensionId: search_palette_1.SearchAutocompletePalette.ID,
                visible: true
              })
            ];
          }
          return [];
        }
        matchesSearchActivateKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "KeyF", "ctrl");
        }
      };
      exports.SearchAutocompletePaletteKeyListener = SearchAutocompletePaletteKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/messages.json
  var require_messages2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/messages.json"(exports, module) {
      module.exports = {
        navigation: {
          default_navigation_mode_activated: "Navigation On: Use arrow keys to select preceding (\u2190) or succeding (\u2192) elements. Use the up (\u2191) and down (\u2193) arrows to navigate paths. Press 'N' to exit.",
          default_navigation_mode_deactivated: "Navigation Off: Press 'N' for default navigation, 'ALT+N' for position based navigation.",
          local_navigation_mode_activated: "Position based Nav On: Navigate nearest elements using arrow keys: (\u2191) for above, (\u2193) for below, (\u2190) for previous, (\u2192) for next element. Press 'ALT+N' to exit.",
          local_navigation_mode_deactivated: "Position based Nav Off: Press 'N' for default navigation, 'ALT+N' for position based navigation."
        },
        focus: {
          focus_on: "Currently focused: ",
          focus_off: "Currently no element is focused."
        },
        resize: {
          resize_mode_activated: "Resize On: Use plus(+) and minus(-) to resize, 'CTRL'+'0' for default size. Press 'ESC' to exit.",
          resize_mode_deactivated: "Resize Off: Press 'ALT'+'A' for resize mode."
        },
        grid: { zoom_in_grid: "Select a digit from 1-9 to zoom in on the respective box." },
        tool_palette: { marqueeTool: "Currently marquee tool is only usable with mouse." }
      };
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-handler.js
  var require_toast_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-handler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShowToastMessageAction = exports.HideToastAction = void 0;
      var sprotty_1 = require_lib5();
      var HideToastAction;
      (function(HideToastAction2) {
        HideToastAction2.KIND = "hideToastMessageAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, HideToastAction2.KIND);
        }
        HideToastAction2.is = is;
        function create(options) {
          return { kind: HideToastAction2.KIND, options };
        }
        HideToastAction2.create = create;
      })(HideToastAction || (exports.HideToastAction = HideToastAction = {}));
      var ShowToastMessageAction;
      (function(ShowToastMessageAction2) {
        ShowToastMessageAction2.KIND = "showToastMessageAction";
        ShowToastMessageAction2.TIMEOUT = 2e3;
        function is(object) {
          return sprotty_1.Action.hasKind(object, ShowToastMessageAction2.KIND);
        }
        ShowToastMessageAction2.is = is;
        function create(options) {
          var _a, _b;
          return { kind: ShowToastMessageAction2.KIND, options: Object.assign(Object.assign({}, options), { position: (_a = options.position) !== null && _a !== void 0 ? _a : "center", id: (_b = options.id) !== null && _b !== void 0 ? _b : Symbol("toast id") }) };
        }
        ShowToastMessageAction2.create = create;
        function createWithTimeout(options) {
          var _a, _b;
          return {
            kind: ShowToastMessageAction2.KIND,
            options: Object.assign(Object.assign({ timeout: ShowToastMessageAction2.TIMEOUT }, options), { position: (_a = options.position) !== null && _a !== void 0 ? _a : "center", id: (_b = options.id) !== null && _b !== void 0 ? _b : Symbol("toast id") })
          };
        }
        ShowToastMessageAction2.createWithTimeout = createWithTimeout;
      })(ShowToastMessageAction || (exports.ShowToastMessageAction = ShowToastMessageAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/diagram-navigation-tool.js
  var require_diagram_navigation_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/diagram-navigation-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var ElementNavigatorTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ElementNavigatorKeyListener = exports.ElementNavigatorTool = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var iterable_1 = require_iterable();
      var keyboard_1 = require_keyboard();
      var action_dispatcher_1 = require_action_dispatcher2();
      var tool_1 = require_tool();
      var reposition_1 = require_reposition();
      var accessible_key_shortcut_1 = require_accessible_key_shortcut();
      var accessible_key_shortcut_tool_1 = require_accessible_key_shortcut_tool();
      var search_tool_1 = require_search_tool();
      var messages = require_messages2();
      var toast_handler_1 = require_toast_handler();
      var model_1 = require_model21();
      var ElementNavigatorTool = ElementNavigatorTool_1 = class ElementNavigatorTool {
        constructor() {
          this.isEditTool = false;
          this.elementNavigatorKeyListener = new ElementNavigatorKeyListener(this);
        }
        get id() {
          return ElementNavigatorTool_1.ID;
        }
        enable() {
          this.keytool.register(this.elementNavigatorKeyListener);
          this.elementNavigatorKeyListener.registerShortcutKey();
        }
        disable() {
          this.keytool.deregister(this.elementNavigatorKeyListener);
        }
      };
      exports.ElementNavigatorTool = ElementNavigatorTool;
      ElementNavigatorTool.ID = "glsp.diagram-navigation";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], ElementNavigatorTool.prototype, "keytool", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IElementNavigator),
        __metadata("design:type", Object)
      ], ElementNavigatorTool.prototype, "elementNavigator", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILocalElementNavigator),
        __metadata("design:type", Object)
      ], ElementNavigatorTool.prototype, "localElementNavigator", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], ElementNavigatorTool.prototype, "actionDispatcher", void 0);
      exports.ElementNavigatorTool = ElementNavigatorTool = ElementNavigatorTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ElementNavigatorTool);
      var NavigationMode;
      (function(NavigationMode2) {
        NavigationMode2["POSITION"] = "position";
        NavigationMode2["DEFAULT"] = "default";
        NavigationMode2["NONE"] = "none";
      })(NavigationMode || (NavigationMode = {}));
      var ElementNavigatorKeyListener = class extends sprotty_1.KeyListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.mode = NavigationMode.NONE;
          this.token = ElementNavigatorKeyListener.name;
        }
        registerShortcutKey() {
          this.tool.actionDispatcher.dispatchOnceModelInitialized(accessible_key_shortcut_1.SetAccessibleKeyShortcutAction.create({
            token: this.token,
            keys: [
              { shortcuts: ["N"], description: "Activate default navigation", group: "Navigation", position: 0 },
              {
                shortcuts: ["ALT", "N"],
                description: "Activate position based navigation",
                group: "Navigation",
                position: 1
              },
              {
                shortcuts: ["\u2B05  \u2B06  \u27A1  \u2B07"],
                description: "Navigate by relation or neighbors according to navigation mode",
                group: "Navigation",
                position: 2
              }
            ]
          }));
        }
        keyDown(element, event) {
          this.resetOnEscape(event, element);
          if (this.getSelectedElements(element.root).length > 0) {
            if (!this.triggerPositionNavigationOnEvent(event, element)) {
              this.triggerDefaultNavigationOnEvent(event, element);
            }
            return this.navigate(element, event);
          }
          this.resetPositionNavigationOnEvent(event, element);
          this.resetDefaultNavigationOnEvent(event, element);
          return [];
        }
        resetOnEscape(event, element) {
          var _a, _b;
          if (this.mode !== NavigationMode.NONE && this.matchesDeactivateNavigationMode(event)) {
            (_b = (_a = this.navigator) === null || _a === void 0 ? void 0 : _a.clean) === null || _b === void 0 ? void 0 : _b.call(_a, element.root);
            this.clean();
            if (this.mode === NavigationMode.POSITION) {
              this.tool.actionDispatcher.dispatchAll([
                tool_1.EnableDefaultToolsAction.create(),
                toast_handler_1.ShowToastMessageAction.createWithTimeout({
                  id: Symbol.for(ElementNavigatorKeyListener.name),
                  message: messages.navigation.local_navigation_mode_deactivated
                })
              ]);
            } else if (this.mode === NavigationMode.DEFAULT) {
              this.tool.actionDispatcher.dispatchAll([
                tool_1.EnableDefaultToolsAction.create(),
                toast_handler_1.ShowToastMessageAction.createWithTimeout({
                  id: Symbol.for(ElementNavigatorKeyListener.name),
                  message: messages.navigation.default_navigation_mode_deactivated
                })
              ]);
            }
            this.mode = NavigationMode.NONE;
          }
        }
        triggerPositionNavigationOnEvent(event, element) {
          if (this.matchesActivatePositionNavigation(event)) {
            if (this.mode !== NavigationMode.POSITION) {
              this.clean();
              this.tool.actionDispatcher.dispatchAll([
                tool_1.EnableToolsAction.create([ElementNavigatorTool.ID, search_tool_1.SearchAutocompletePaletteTool.ID, accessible_key_shortcut_tool_1.AccessibleKeyShortcutTool.ID]),
                toast_handler_1.ShowToastMessageAction.create({
                  id: Symbol.for(ElementNavigatorKeyListener.name),
                  message: messages.navigation.local_navigation_mode_activated
                })
              ]);
              this.navigator = this.tool.elementNavigator;
              this.mode = NavigationMode.POSITION;
            } else {
              this.resetPositionNavigationOnEvent(event, element);
            }
            return true;
          }
          return false;
        }
        resetPositionNavigationOnEvent(event, element) {
          var _a, _b;
          if (this.mode === NavigationMode.POSITION && this.matchesActivatePositionNavigation(event)) {
            (_b = (_a = this.navigator) === null || _a === void 0 ? void 0 : _a.clean) === null || _b === void 0 ? void 0 : _b.call(_a, element.root);
            this.clean();
            this.mode = NavigationMode.NONE;
            this.tool.actionDispatcher.dispatchAll([
              tool_1.EnableDefaultToolsAction.create(),
              toast_handler_1.ShowToastMessageAction.createWithTimeout({
                id: Symbol.for(ElementNavigatorKeyListener.name),
                message: messages.navigation.local_navigation_mode_deactivated
              })
            ]);
          }
        }
        triggerDefaultNavigationOnEvent(event, element) {
          if (this.matchesActivateDefaultNavigation(event)) {
            if (this.mode !== NavigationMode.DEFAULT) {
              this.clean();
              this.tool.actionDispatcher.dispatchAll([
                tool_1.EnableToolsAction.create([ElementNavigatorTool.ID, search_tool_1.SearchAutocompletePaletteTool.ID, accessible_key_shortcut_tool_1.AccessibleKeyShortcutTool.ID]),
                toast_handler_1.ShowToastMessageAction.create({
                  id: Symbol.for(ElementNavigatorKeyListener.name),
                  message: messages.navigation.default_navigation_mode_activated
                })
              ]);
              this.navigator = this.tool.localElementNavigator;
              this.mode = NavigationMode.DEFAULT;
            } else {
              this.resetDefaultNavigationOnEvent(event, element);
            }
            return true;
          }
          return false;
        }
        resetDefaultNavigationOnEvent(event, element) {
          var _a, _b;
          if (this.mode === NavigationMode.DEFAULT && this.matchesActivateDefaultNavigation(event)) {
            (_b = (_a = this.navigator) === null || _a === void 0 ? void 0 : _a.clean) === null || _b === void 0 ? void 0 : _b.call(_a, element.root);
            this.clean();
            this.mode = NavigationMode.NONE;
            this.tool.actionDispatcher.dispatchAll([
              tool_1.EnableDefaultToolsAction.create(),
              toast_handler_1.ShowToastMessageAction.createWithTimeout({
                id: Symbol.for(ElementNavigatorKeyListener.name),
                message: messages.navigation.default_navigation_mode_deactivated
              })
            ]);
          }
        }
        navigate(element, event) {
          var _a, _b, _c, _d;
          const selected = this.getSelectedElements(element.root);
          const current = selected.length > 0 ? selected[0] : void 0;
          if (this.mode !== NavigationMode.NONE && this.navigator !== void 0 && current !== void 0 && (0, sprotty_1.isBoundsAware)(current)) {
            (_b = (_a = this.navigator).clean) === null || _b === void 0 ? void 0 : _b.call(_a, current.root, current, this.previousNode);
            const target = this.navigateOnEvent(event, this.navigator, current);
            if (target !== void 0) {
              (_d = (_c = this.navigator).process) === null || _d === void 0 ? void 0 : _d.call(_c, current.root, current, target, this.previousNode);
            }
            const selectableTarget = target ? (0, sprotty_1.findParentByFeature)(target, sprotty_1.isSelectable) : void 0;
            if (selectableTarget) {
              if (!(current instanceof model_1.GEdge)) {
                this.previousNode = current;
              }
              const deselectedElementsIDs = selected.map((e) => e.id).filter((id) => id !== selectableTarget.id);
              return [
                sprotty_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs }),
                reposition_1.RepositionAction.create([selectableTarget.id])
              ];
            }
          }
          return [];
        }
        navigateOnEvent(event, navigator2, current) {
          var _a, _b;
          if (this.matchesNavigatePrevious(event)) {
            return navigator2.previous(current.root, current);
          } else if (this.matchesNavigateNext(event)) {
            return navigator2.next(current.root, current);
          } else if (this.matchesNavigateUp(event)) {
            return (_a = navigator2.up) === null || _a === void 0 ? void 0 : _a.call(navigator2, current.root, current, this.previousNode);
          } else if (this.matchesNavigateDown(event)) {
            return (_b = navigator2.down) === null || _b === void 0 ? void 0 : _b.call(navigator2, current.root, current, this.previousNode);
          }
          return void 0;
        }
        clean() {
          this.previousNode = void 0;
          this.navigator = void 0;
        }
        getSelectedElements(root) {
          return (0, iterable_1.toArray)(root.index.all().filter((e) => (0, sprotty_1.isSelected)(e)));
        }
        matchesDeactivateNavigationMode(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Escape");
        }
        matchesActivateDefaultNavigation(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "KeyN");
        }
        matchesActivatePositionNavigation(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "KeyN", "alt");
        }
        matchesNavigatePrevious(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowLeft");
        }
        matchesNavigateNext(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowRight");
        }
        matchesNavigateUp(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowUp");
        }
        matchesNavigateDown(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowDown");
        }
      };
      exports.ElementNavigatorKeyListener = ElementNavigatorKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/focus-tracker/focus-tracker-tool.js
  var require_focus_tracker_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/focus-tracker/focus-tracker-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var FocusTrackerTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusTrackerTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var messages = require_messages2();
      var toast_handler_1 = require_toast_handler();
      var FocusTrackerTool = FocusTrackerTool_1 = class FocusTrackerTool {
        constructor() {
          this.isEditTool = false;
          this.focusInFunction = (event) => this.focusIn(event);
          this.focusOutFunction = (event) => this.focusOut(event);
          this.registered = false;
        }
        get id() {
          return FocusTrackerTool_1.ID;
        }
        enable() {
          if (!this.registered) {
            document.addEventListener("focusin", this.focusInFunction);
            document.addEventListener("focusout", this.focusOutFunction);
          }
          this.registered = true;
        }
        disable() {
        }
        async focusOut(event) {
          await this.showToast("Focus not set");
        }
        async focusIn(event) {
          let message;
          const target = event.target;
          if (target instanceof HTMLElement) {
            const parent = this.parentWithAriaLabel(target);
            const textMessage = this.handleTextNode(target);
            if (target.ariaLabel !== null) {
              message = this.handleAriaLabel(target);
            } else {
              if (parent === void 0 && textMessage !== void 0) {
                message = textMessage;
              } else if (parent !== void 0 && textMessage === void 0) {
                message = `Focus is in ${parent.ariaLabel}`;
              } else if (parent !== void 0 && textMessage !== void 0) {
                message = `${parent.ariaLabel} -> ${textMessage}`;
              }
            }
          }
          await this.showToast(message);
        }
        handleTextNode(target) {
          const textNode = Array.prototype.filter.call(target.childNodes, (element) => element.nodeType === Node.TEXT_NODE).map((element) => element.textContent).join("");
          if (textNode.trim().length !== 0) {
            return textNode;
          }
          return void 0;
        }
        handleAriaLabel(target) {
          return target.ariaLabel === null ? void 0 : target.ariaLabel;
        }
        showToast(message) {
          return this.actionDispatcher.dispatchAll([
            toast_handler_1.ShowToastMessageAction.create({
              id: Symbol.for(FocusTrackerTool_1.ID),
              message: `${messages.focus.focus_on} ${message !== null && message !== void 0 ? message : "unknown"}`,
              position: "left"
            })
          ]);
        }
        parentWithAriaLabel(target) {
          let current = target.parentElement;
          while (
            // eslint-disable-next-line no-null/no-null
            current !== null && current !== document.body && current !== document.getElementById(this.viewerOptions.baseDiv) && // eslint-disable-next-line no-null/no-null
            current.ariaLabel === null
          ) {
            current = current.parentElement;
          }
          if (current === document.getElementById(this.viewerOptions.baseDiv) || current === document.body) {
            return void 0;
          }
          return current !== null && current !== void 0 ? current : void 0;
        }
      };
      exports.FocusTrackerTool = FocusTrackerTool;
      FocusTrackerTool.ID = "glsp.focus-tracker";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], FocusTrackerTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], FocusTrackerTool.prototype, "viewerOptions", void 0);
      exports.FocusTrackerTool = FocusTrackerTool = FocusTrackerTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], FocusTrackerTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/layout-utils.js
  var require_layout_utils = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/layout-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toValidElementAndBounds = exports.toValidElementMove = exports.isValidMove = exports.isValidSize = exports.getLayoutOptions = exports.minHeight = exports.minWidth = void 0;
      function minWidth(element) {
        const layoutOptions = getLayoutOptions(element);
        if (layoutOptions !== void 0 && typeof layoutOptions.minWidth === "number") {
          return layoutOptions.minWidth;
        }
        return 1;
      }
      exports.minWidth = minWidth;
      function minHeight(element) {
        const layoutOptions = getLayoutOptions(element);
        if (layoutOptions !== void 0 && typeof layoutOptions.minHeight === "number") {
          return layoutOptions.minHeight;
        }
        return 1;
      }
      exports.minHeight = minHeight;
      function getLayoutOptions(element) {
        const layoutOptions = element.layoutOptions;
        if (layoutOptions !== void 0) {
          return layoutOptions;
        }
        return void 0;
      }
      exports.getLayoutOptions = getLayoutOptions;
      function isValidSize(element, size) {
        return size.width >= minWidth(element) && size.height >= minHeight(element);
      }
      exports.isValidSize = isValidSize;
      function isValidMove(element, newPosition, movementRestrictor) {
        if (movementRestrictor) {
          return movementRestrictor.validate(element, newPosition);
        }
        return true;
      }
      exports.isValidMove = isValidMove;
      function toValidElementMove(element, move, movementRestrictor) {
        if (!isValidMove(element, move.toPosition, movementRestrictor)) {
          return;
        }
        return move;
      }
      exports.toValidElementMove = toValidElementMove;
      function toValidElementAndBounds(element, bounds, movementRestrictor) {
        if (!isValidMove(element, bounds.newPosition, movementRestrictor)) {
          return;
        }
        const elementMinWidth = minWidth(element);
        if (bounds.newSize.width < elementMinWidth) {
          bounds.newSize.width = elementMinWidth;
        }
        const elementMinHeight = minHeight(element);
        if (bounds.newSize.height < elementMinHeight) {
          bounds.newSize.height = elementMinHeight;
        }
        return bounds;
      }
      exports.toValidElementAndBounds = toValidElementAndBounds;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/snap.js
  var require_snap2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/snap.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PointPositionUpdater = exports.GridSnapper = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var GridSnapper = class GridSnapper {
        constructor(grid = { x: 10, y: 10 }) {
          this.grid = grid;
        }
        snap(position, element) {
          return {
            x: Math.round(position.x / this.grid.x) * this.grid.x,
            y: Math.round(position.y / this.grid.y) * this.grid.y
          };
        }
      };
      exports.GridSnapper = GridSnapper;
      exports.GridSnapper = GridSnapper = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [Object])
      ], GridSnapper);
      var PointPositionUpdater = class {
        constructor(snapper) {
          this.snapper = snapper;
          this.positionDelta = { x: 0, y: 0 };
        }
        /**
         * Init the position with the {@link Point} of your mouse cursor.
         * This method is normally called in the `mouseDown` event.
         * @param mousePosition current mouse position e.g `{x: event.pageX, y: event.pageY }`
         */
        updateLastDragPosition(mousePosition) {
          this.lastDragPosition = mousePosition;
        }
        /**
         * Check if the mouse is currently not in a drag mode.
         * @returns true if the last drag position is undefined
         */
        isLastDragPositionUndefined() {
          return this.lastDragPosition === void 0;
        }
        /**
         * Reset the updater for new movements.
         * This method is normally called in the `mouseUp` event.
         */
        resetPosition() {
          this.lastDragPosition = void 0;
          this.positionDelta = { x: 0, y: 0 };
        }
        /**
         * Calculate the current position of your movement.
         * This method is normally called in the `mouseMove` event.
         * @param target node which is moved around
         * @param mousePosition current mouse position e.g `{x: event.pageX, y: event.pageY }`
         * @param isSnapEnabled if a snapper is defined you can disable it, e.g when a specific key is pressed `!event.altKey`
         * @returns current position or undefined if updater has no last drag position initialized
         */
        updatePosition(target, mousePosition, isSnapEnabled) {
          var _a;
          if (this.lastDragPosition) {
            const newDragPosition = mousePosition;
            const viewport = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isViewport);
            const zoom = (_a = viewport === null || viewport === void 0 ? void 0 : viewport.zoom) !== null && _a !== void 0 ? _a : 1;
            const dx = (mousePosition.x - this.lastDragPosition.x) / zoom;
            const dy = (mousePosition.y - this.lastDragPosition.y) / zoom;
            const deltaToLastPosition = { x: dx, y: dy };
            this.lastDragPosition = newDragPosition;
            this.positionDelta.x += deltaToLastPosition.x;
            this.positionDelta.y += deltaToLastPosition.y;
            const positionUpdate = this.snap(this.positionDelta, target, isSnapEnabled);
            if (positionUpdate.x === 0 && positionUpdate.y === 0) {
              return void 0;
            }
            this.positionDelta.x -= positionUpdate.x;
            this.positionDelta.y -= positionUpdate.y;
            return positionUpdate;
          }
          return void 0;
        }
        snap(position, element, isSnap) {
          return isSnap && this.snapper ? this.snapper.snap(position, element) : { x: position.x, y: position.y };
        }
      };
      exports.PointPositionUpdater = PointPositionUpdater;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/resize-key-tool/resize-key-handler.js
  var require_resize_key_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/resize-key-tool/resize-key-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var ResizeElementHandler_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResizeElementHandler = exports.ResizeElementAction = exports.ResizeType = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var editor_context_service_1 = require_editor_context_service();
      var layout_utils_1 = require_layout_utils();
      var gmodel_util_1 = require_gmodel_util();
      var snap_1 = require_snap2();
      var ResizeType;
      (function(ResizeType2) {
        ResizeType2[ResizeType2["Increase"] = 0] = "Increase";
        ResizeType2[ResizeType2["Decrease"] = 1] = "Decrease";
        ResizeType2[ResizeType2["MinSize"] = 2] = "MinSize";
      })(ResizeType || (exports.ResizeType = ResizeType = {}));
      var ResizeElementAction;
      (function(ResizeElementAction2) {
        ResizeElementAction2.KIND = "resizeElementAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ResizeElementAction2.KIND);
        }
        ResizeElementAction2.is = is;
        function create(elementIds, resizeType) {
          return { kind: ResizeElementAction2.KIND, elementIds, resizeType };
        }
        ResizeElementAction2.create = create;
      })(ResizeElementAction || (exports.ResizeElementAction = ResizeElementAction = {}));
      var ResizeElementHandler = ResizeElementHandler_1 = class ResizeElementHandler {
        constructor(snapper) {
          this.snapper = snapper;
          this.grid = { x: ResizeElementHandler_1.defaultResizeX, y: ResizeElementHandler_1.defaultResizeY };
          this.isEditMode = false;
          if (snapper instanceof snap_1.GridSnapper) {
            this.grid = snapper.grid;
          }
        }
        handle(action) {
          if (ResizeElementAction.is(action)) {
            this.handleResizeElement(action);
          }
        }
        handleResizeElement(action) {
          const elements = (0, gmodel_util_1.getElements)(this.editorContextService.modelRoot.index, action.elementIds, gmodel_util_1.isSelectableAndBoundsAware);
          this.dispatcher.dispatchAll(this.resize(elements, action));
        }
        resize(elements, action) {
          const actions = [];
          elements.forEach((element) => {
            const { x, y, width: oldWidth, height: oldHeight } = element.bounds;
            let width = 0;
            let height = 0;
            if (action.resizeType === ResizeType.Decrease) {
              width = oldWidth - this.grid.x;
              height = oldHeight - this.grid.y;
            } else if (action.resizeType === ResizeType.Increase) {
              width = oldWidth + this.grid.x;
              height = oldHeight + this.grid.y;
            } else if (action.resizeType === ResizeType.MinSize) {
              width = (0, layout_utils_1.minWidth)(element);
              height = (0, layout_utils_1.minHeight)(element);
            }
            if (this.isValidBoundChange(element, { x, y }, { width, height })) {
              const resizeElement = { id: element.id, bounds: { x, y, width, height } };
              actions.push(sprotty_1.ChangeBoundsOperation.create([(0, gmodel_util_1.toElementAndBounds)(resizeElement)]));
            }
          });
          return actions;
        }
        isValidBoundChange(element, newPosition, newSize) {
          return (0, layout_utils_1.isValidSize)(element, newSize) && (0, layout_utils_1.isValidMove)(element, newPosition);
        }
      };
      exports.ResizeElementHandler = ResizeElementHandler;
      ResizeElementHandler.defaultResizeX = 20;
      ResizeElementHandler.defaultResizeY = 20;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ResizeElementHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ResizeElementHandler.prototype, "dispatcher", void 0);
      exports.ResizeElementHandler = ResizeElementHandler = ResizeElementHandler_1 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Object])
      ], ResizeElementHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/resize-key-tool/resize-key-tool.js
  var require_resize_key_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/resize-key-tool/resize-key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var ResizeKeyTool_1;
      var ResizeKeyListener_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResizeKeyListener = exports.ResizeKeyTool = void 0;
      var inversify_1 = require_inversify();
      var keyboard_1 = require_keyboard();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var selection_service_1 = require_selection_service();
      var tool_1 = require_tool();
      var accessible_key_shortcut_1 = require_accessible_key_shortcut();
      var messages = require_messages2();
      var toast_handler_1 = require_toast_handler();
      var resize_key_handler_1 = require_resize_key_handler();
      var ResizeKeyTool = ResizeKeyTool_1 = class ResizeKeyTool {
        constructor() {
          this.isEditTool = true;
          this.resizeKeyListener = new ResizeKeyListener(this);
        }
        get id() {
          return ResizeKeyTool_1.ID;
        }
        enable() {
          this.keytool.register(this.resizeKeyListener);
          this.resizeKeyListener.registerShortcutKey();
        }
        disable() {
          this.keytool.deregister(this.resizeKeyListener);
        }
      };
      exports.ResizeKeyTool = ResizeKeyTool;
      ResizeKeyTool.ID = "glsp.resize-key-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], ResizeKeyTool.prototype, "keytool", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ResizeKeyTool.prototype, "movementRestrictor", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ResizeKeyTool.prototype, "snapper", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], ResizeKeyTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], ResizeKeyTool.prototype, "selectionService", void 0);
      exports.ResizeKeyTool = ResizeKeyTool = ResizeKeyTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ResizeKeyTool);
      var ResizeKeyListener = ResizeKeyListener_1 = class ResizeKeyListener extends sprotty_1.KeyListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.isEditMode = false;
          this.token = ResizeKeyListener_1.name;
        }
        registerShortcutKey() {
          this.tool.actionDispatcher.dispatchOnceModelInitialized(accessible_key_shortcut_1.SetAccessibleKeyShortcutAction.create({
            token: this.token,
            keys: [
              { shortcuts: ["ALT", "A"], description: "Activate resize mode for selected element", group: "Resize", position: 0 },
              { shortcuts: ["+"], description: "Increase size of element", group: "Resize", position: 1 },
              { shortcuts: ["-"], description: "Increase size of element", group: "Resize", position: 2 },
              { shortcuts: ["CTRL", "0"], description: "Set element size to default", group: "Resize", position: 3 }
            ]
          }));
        }
        keyDown(element, event) {
          const actions = [];
          const selectedElementsIds = this.tool.selectionService.getSelectedElementIDs();
          if (this.isEditMode && this.matchesDeactivateResizeModeKeystroke(event)) {
            this.isEditMode = false;
            this.tool.actionDispatcher.dispatch(toast_handler_1.ShowToastMessageAction.createWithTimeout({
              id: Symbol.for(ResizeKeyListener_1.name),
              message: messages.resize.resize_mode_deactivated
            }));
            actions.push(tool_1.EnableDefaultToolsAction.create());
          }
          if (selectedElementsIds.length > 0) {
            if (!this.isEditMode && this.matchesActivateResizeModeKeystroke(event)) {
              this.isEditMode = true;
              this.tool.actionDispatcher.dispatch(toast_handler_1.ShowToastMessageAction.create({
                id: Symbol.for(ResizeKeyListener_1.name),
                message: messages.resize.resize_mode_activated
              }));
              actions.push(tool_1.EnableToolsAction.create([ResizeKeyTool.ID]));
            }
            if (this.isEditMode) {
              if (this.matchesIncreaseSizeKeystroke(event)) {
                actions.push(resize_key_handler_1.ResizeElementAction.create(selectedElementsIds, resize_key_handler_1.ResizeType.Increase));
              } else if (this.matchesDecreaseSizeKeystroke(event)) {
                actions.push(resize_key_handler_1.ResizeElementAction.create(selectedElementsIds, resize_key_handler_1.ResizeType.Decrease));
              } else if (this.matchesMinSizeKeystroke(event)) {
                actions.push(resize_key_handler_1.ResizeElementAction.create(selectedElementsIds, resize_key_handler_1.ResizeType.MinSize));
              }
            }
          }
          return actions;
        }
        matchesIncreaseSizeKeystroke(event) {
          return event.key === "+" || (0, keyboard_1.matchesKeystroke)(event, "NumpadAdd");
        }
        matchesActivateResizeModeKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "KeyA", "alt");
        }
        matchesDeactivateResizeModeKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Escape");
        }
        matchesMinSizeKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Digit0", "ctrl") || (0, keyboard_1.matchesKeystroke)(event, "Numpad0", "ctrl");
        }
        matchesDecreaseSizeKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Minus") || (0, keyboard_1.matchesKeystroke)(event, "NumpadSubtract");
        }
      };
      exports.ResizeKeyListener = ResizeKeyListener;
      exports.ResizeKeyListener = ResizeKeyListener = ResizeKeyListener_1 = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [ResizeKeyTool])
      ], ResizeKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-tool.js
  var require_toast_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var Toast_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Toast = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var editor_context_service_1 = require_editor_context_service();
      var toast_handler_1 = require_toast_handler();
      var Toast = Toast_1 = class Toast extends sprotty_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.messages = {};
        }
        id() {
          return Toast_1.ID;
        }
        containerClass() {
          return Toast_1.ID;
        }
        initializeContents(_containerElement) {
          this.render();
        }
        handle(action) {
          if (toast_handler_1.ShowToastMessageAction.is(action)) {
            this.messages[action.options.id] = action.options;
            this.render();
            if (action.options.timeout) {
              setTimeout(() => {
                this.delete(action.options.id);
              }, action.options.timeout);
            }
          } else if (toast_handler_1.HideToastAction.is(action)) {
            if (action.options.timeout) {
              setTimeout(() => {
                this.delete(action.options.id);
              }, action.options.timeout);
            } else {
              this.delete(action.options.id);
            }
          }
        }
        render() {
          if (this.containerElement === void 0) {
            return;
          }
          this.containerElement.innerHTML = "";
          this.values(this.messages).forEach((message) => {
            this.containerElement.appendChild(this.createToastMessage(message));
          });
        }
        delete(id) {
          delete this.messages[id];
          this.render();
        }
        createToastMessage(option) {
          const cell = document.createElement("div");
          cell.classList.add("toast-cell", `toast-column-${option.position}`);
          const container = document.createElement("div");
          container.classList.add("toast-container");
          const text = document.createElement("span");
          text.textContent = option.message;
          container.appendChild(text);
          cell.appendChild(container);
          return cell;
        }
        preInitialize() {
          this.show(this.editorContext.modelRoot);
        }
        values(obj) {
          return Object.getOwnPropertySymbols(obj).map((s) => obj[s]);
        }
      };
      exports.Toast = Toast;
      Toast.ID = "toast";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], Toast.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], Toast.prototype, "editorContext", void 0);
      exports.Toast = Toast = Toast_1 = __decorate([
        (0, inversify_1.injectable)()
      ], Toast);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/model.js
  var require_model22 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.removeResizeHandles = exports.addResizeHandles = exports.SResizeHandle = exports.isBoundsAwareMoveable = exports.ResizeHandleLocation = exports.isResizable = exports.resizeFeature = void 0;
      var sprotty_1 = require_lib5();
      exports.resizeFeature = Symbol("resizeFeature");
      function isResizable(element) {
        return (0, sprotty_1.isBoundsAware)(element) && (0, sprotty_1.isSelectable)(element) && element instanceof sprotty_1.GParentElement && element.hasFeature(exports.resizeFeature);
      }
      exports.isResizable = isResizable;
      var ResizeHandleLocation;
      (function(ResizeHandleLocation2) {
        ResizeHandleLocation2["TopLeft"] = "top-left";
        ResizeHandleLocation2["TopRight"] = "top-right";
        ResizeHandleLocation2["BottomLeft"] = "bottom-left";
        ResizeHandleLocation2["BottomRight"] = "bottom-right";
      })(ResizeHandleLocation || (exports.ResizeHandleLocation = ResizeHandleLocation = {}));
      function isBoundsAwareMoveable(element) {
        return (0, sprotty_1.isMoveable)(element) && (0, sprotty_1.isBoundsAware)(element);
      }
      exports.isBoundsAwareMoveable = isBoundsAwareMoveable;
      var SResizeHandle = class extends sprotty_1.GChildElement {
        constructor(location2, type = SResizeHandle.TYPE, hoverFeedback = false) {
          super();
          this.location = location2;
          this.type = type;
          this.hoverFeedback = hoverFeedback;
        }
        hasFeature(feature) {
          return feature === sprotty_1.hoverFeedbackFeature;
        }
        isNwSeResize() {
          return this.location === ResizeHandleLocation.TopLeft || this.location === ResizeHandleLocation.BottomRight;
        }
        isNeSwResize() {
          return this.location === ResizeHandleLocation.TopRight || this.location === ResizeHandleLocation.BottomLeft;
        }
      };
      exports.SResizeHandle = SResizeHandle;
      SResizeHandle.TYPE = "resize-handle";
      function addResizeHandles(element) {
        removeResizeHandles(element);
        element.add(new SResizeHandle(ResizeHandleLocation.TopLeft));
        element.add(new SResizeHandle(ResizeHandleLocation.TopRight));
        element.add(new SResizeHandle(ResizeHandleLocation.BottomLeft));
        element.add(new SResizeHandle(ResizeHandleLocation.BottomRight));
      }
      exports.addResizeHandles = addResizeHandles;
      function removeResizeHandles(element) {
        element.removeAll((child) => child instanceof SResizeHandle);
      }
      exports.removeResizeHandles = removeResizeHandles;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/deselect-key-tool.js
  var require_deselect_key_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/deselect-key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var DeselectKeyTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeselectKeyListener = exports.DeselectKeyTool = void 0;
      var inversify_1 = require_inversify();
      var iterable_1 = require_iterable();
      var keyboard_1 = require_keyboard();
      var sprotty_1 = require_lib5();
      var model_1 = require_model22();
      var DeselectKeyTool = DeselectKeyTool_1 = class DeselectKeyTool {
        constructor() {
          this.isEditTool = true;
          this.deselectKeyListener = new DeselectKeyListener();
        }
        get id() {
          return DeselectKeyTool_1.ID;
        }
        enable() {
          this.keytool.register(this.deselectKeyListener);
        }
        disable() {
          this.keytool.deregister(this.deselectKeyListener);
        }
      };
      exports.DeselectKeyTool = DeselectKeyTool;
      DeselectKeyTool.ID = "glsp.deselect-key-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], DeselectKeyTool.prototype, "keytool", void 0);
      exports.DeselectKeyTool = DeselectKeyTool = DeselectKeyTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], DeselectKeyTool);
      var DeselectKeyListener = class extends sprotty_1.KeyListener {
        keyDown(target, event) {
          if (this.matchesDeselectKeystroke(event)) {
            const isResizeHandleActive = (0, iterable_1.toArray)(target.root.index.all().filter((el) => el instanceof model_1.SResizeHandle)).length > 0;
            if (isResizeHandleActive) {
              return [];
            }
            const deselect = (0, iterable_1.toArray)(target.root.index.all().filter((element) => (0, sprotty_1.isSelectable)(element) && element.selected));
            const actions = [];
            if (deselect.length > 0) {
              actions.push(sprotty_1.SelectAction.create({ deselectedElementsIDs: deselect.map((e) => e.id) }));
            }
            const routableDeselect = deselect.filter((e) => e instanceof sprotty_1.GRoutableElement).map((e) => e.id);
            if (routableDeselect.length > 0) {
              actions.push(sprotty_1.SwitchEditModeAction.create({ elementsToDeactivate: routableDeselect }));
            }
            return actions;
          }
          return [];
        }
        matchesDeselectKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Escape");
        }
      };
      exports.DeselectKeyListener = DeselectKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/move-zoom/move-handler.js
  var require_move_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/move-zoom/move-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MoveElementHandler = exports.MoveViewportHandler = exports.MoveElementAction = exports.MoveViewportAction = void 0;
      var inversify_1 = require_inversify();
      var lodash_1 = require_lodash();
      var sprotty_1 = require_lib5();
      var editor_context_service_1 = require_editor_context_service();
      var gmodel_util_1 = require_gmodel_util();
      var MoveViewportAction;
      (function(MoveViewportAction2) {
        MoveViewportAction2.KIND = "moveViewportAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, MoveViewportAction2.KIND);
        }
        MoveViewportAction2.is = is;
        function create(moveX, moveY) {
          return { kind: MoveViewportAction2.KIND, moveX, moveY };
        }
        MoveViewportAction2.create = create;
      })(MoveViewportAction || (exports.MoveViewportAction = MoveViewportAction = {}));
      var MoveElementAction;
      (function(MoveElementAction2) {
        MoveElementAction2.KIND = "moveElementAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, MoveElementAction2.KIND);
        }
        MoveElementAction2.is = is;
        function create(elementIds, moveX, moveY) {
          return { kind: MoveElementAction2.KIND, elementIds, moveX, moveY };
        }
        MoveElementAction2.create = create;
      })(MoveElementAction || (exports.MoveElementAction = MoveElementAction = {}));
      var MoveViewportHandler = class MoveViewportHandler {
        constructor() {
          this.throttledHandleViewportMove = (0, lodash_1.throttle)((action) => this.handleMoveViewport(action), 150);
        }
        handle(action) {
          if (MoveViewportAction.is(action)) {
            this.throttledHandleViewportMove(action);
          }
        }
        handleMoveViewport(action) {
          const viewport = (0, sprotty_1.findParentByFeature)(this.editorContextService.modelRoot, sprotty_1.isViewport);
          if (!viewport) {
            return;
          }
          this.dispatcher.dispatch(this.moveViewport(viewport, action.moveX, action.moveY));
        }
        moveViewport(viewport, offsetX, offSetY) {
          const newViewport = {
            scroll: {
              x: viewport.scroll.x + offsetX,
              y: viewport.scroll.y + offSetY
            },
            zoom: viewport.zoom
          };
          return sprotty_1.SetViewportAction.create(viewport.id, newViewport, { animate: true });
        }
      };
      exports.MoveViewportHandler = MoveViewportHandler;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], MoveViewportHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], MoveViewportHandler.prototype, "dispatcher", void 0);
      exports.MoveViewportHandler = MoveViewportHandler = __decorate([
        (0, inversify_1.injectable)()
      ], MoveViewportHandler);
      var MoveElementHandler = class MoveElementHandler {
        constructor() {
          this.throttledHandleElementMove = (0, lodash_1.throttle)((action) => this.handleMoveElement(action), 150);
        }
        handle(action) {
          if (MoveElementAction.is(action)) {
            this.throttledHandleElementMove(action);
          }
        }
        handleMoveElement(action) {
          const viewport = (0, sprotty_1.findParentByFeature)(this.editorContextService.modelRoot, sprotty_1.isViewport);
          if (!viewport) {
            return;
          }
          const elements = (0, gmodel_util_1.getElements)(this.editorContextService.modelRoot.index, action.elementIds, gmodel_util_1.isSelectableAndBoundsAware);
          this.dispatcher.dispatchAll(this.move(viewport, elements, action.moveX, action.moveY));
        }
        getBounds(element, offSetX, offSetY) {
          return { x: element.bounds.x + offSetX, y: element.bounds.y + offSetY };
        }
        adaptViewport(viewport, newPoint, moveX, moveY) {
          if (newPoint.x < viewport.scroll.x || newPoint.x > viewport.scroll.x + viewport.canvasBounds.width || newPoint.y < viewport.scroll.y || newPoint.y > viewport.scroll.y + viewport.canvasBounds.height) {
            return MoveViewportAction.create(moveX, moveY);
          }
          return;
        }
        moveElement(element, offSetX, offSetY) {
          return sprotty_1.ChangeBoundsOperation.create([
            {
              elementId: element.id,
              newSize: {
                width: element.bounds.width,
                height: element.bounds.height
              },
              newPosition: {
                x: element.bounds.x + offSetX,
                y: element.bounds.y + offSetY
              }
            }
          ]);
        }
        move(viewport, selectedElements, deltaX, deltaY) {
          const results = [];
          if (selectedElements.length !== 0) {
            selectedElements.forEach((currentElement) => {
              results.push(this.moveElement(currentElement, deltaX, deltaY));
              const newPosition = this.getBounds(currentElement, deltaX, deltaY);
              const viewportAction = this.adaptViewport(viewport, newPosition, deltaX, deltaY);
              if (viewportAction) {
                results.push(viewportAction);
              }
            });
          }
          return results;
        }
      };
      exports.MoveElementHandler = MoveElementHandler;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], MoveElementHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], MoveElementHandler.prototype, "dispatcher", void 0);
      exports.MoveElementHandler = MoveElementHandler = __decorate([
        (0, inversify_1.injectable)()
      ], MoveElementHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/movement-key-tool.js
  var require_movement_key_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/movement-key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var MovementKeyTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MoveKeyListener = exports.MovementKeyTool = void 0;
      var inversify_1 = require_inversify();
      var keyboard_1 = require_keyboard();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var selection_service_1 = require_selection_service();
      var snap_1 = require_snap2();
      var accessible_key_shortcut_1 = require_accessible_key_shortcut();
      var move_handler_1 = require_move_handler();
      var MovementKeyTool = MovementKeyTool_1 = class MovementKeyTool {
        constructor() {
          this.isEditTool = true;
          this.movementKeyListener = new MoveKeyListener(this);
        }
        get id() {
          return MovementKeyTool_1.ID;
        }
        enable() {
          this.keytool.register(this.movementKeyListener);
          this.movementKeyListener.registerShortcutKey();
        }
        disable() {
          this.keytool.deregister(this.movementKeyListener);
        }
      };
      exports.MovementKeyTool = MovementKeyTool;
      MovementKeyTool.ID = "glsp.movement-key-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], MovementKeyTool.prototype, "keytool", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], MovementKeyTool.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], MovementKeyTool.prototype, "snapper", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], MovementKeyTool.prototype, "actionDispatcher", void 0);
      exports.MovementKeyTool = MovementKeyTool = MovementKeyTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MovementKeyTool);
      var MoveKeyListener = class extends sprotty_1.KeyListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.token = MoveKeyListener.name;
          this.grid = { x: MoveKeyListener.defaultMoveX, y: MoveKeyListener.defaultMoveY };
          if (this.tool.snapper instanceof snap_1.GridSnapper) {
            this.grid = this.tool.snapper.grid;
          }
        }
        registerShortcutKey() {
          this.tool.actionDispatcher.dispatchOnceModelInitialized(accessible_key_shortcut_1.SetAccessibleKeyShortcutAction.create({
            token: this.token,
            keys: [{ shortcuts: ["\u2B05  \u2B06  \u27A1  \u2B07"], description: "Move element or viewport", group: "Move", position: 0 }]
          }));
        }
        keyDown(element, event) {
          const selectedElementIds = this.tool.selectionService.getSelectedElementIDs();
          if (selectedElementIds.length > 0) {
            if (this.matchesMoveUpKeystroke(event)) {
              return [move_handler_1.MoveElementAction.create(selectedElementIds, 0, -this.grid.x)];
            } else if (this.matchesMoveDownKeystroke(event)) {
              return [move_handler_1.MoveElementAction.create(selectedElementIds, 0, this.grid.x)];
            } else if (this.matchesMoveRightKeystroke(event)) {
              return [move_handler_1.MoveElementAction.create(selectedElementIds, this.grid.x, 0)];
            } else if (this.matchesMoveLeftKeystroke(event)) {
              return [move_handler_1.MoveElementAction.create(selectedElementIds, -this.grid.x, 0)];
            }
          } else {
            if (this.matchesMoveUpKeystroke(event)) {
              return [move_handler_1.MoveViewportAction.create(0, -this.grid.x)];
            } else if (this.matchesMoveDownKeystroke(event)) {
              return [move_handler_1.MoveViewportAction.create(0, this.grid.x)];
            } else if (this.matchesMoveRightKeystroke(event)) {
              return [move_handler_1.MoveViewportAction.create(this.grid.x, 0)];
            } else if (this.matchesMoveLeftKeystroke(event)) {
              return [move_handler_1.MoveViewportAction.create(-this.grid.x, 0)];
            }
          }
          return [];
        }
        matchesMoveUpKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowUp");
        }
        matchesMoveDownKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowDown");
        }
        matchesMoveRightKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowRight");
        }
        matchesMoveLeftKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowLeft");
        }
      };
      exports.MoveKeyListener = MoveKeyListener;
      MoveKeyListener.defaultMoveX = 20;
      MoveKeyListener.defaultMoveY = 20;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/move-zoom/zoom-handler.js
  var require_zoom_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/move-zoom/zoom-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoomElementHandler = exports.ZoomViewportHandler = exports.ZoomElementAction = exports.ZoomViewportAction = void 0;
      var inversify_1 = require_inversify();
      var lodash_1 = require_lodash();
      var sprotty_1 = require_lib5();
      var editor_context_service_1 = require_editor_context_service();
      var gmodel_util_1 = require_gmodel_util();
      var ZoomViewportAction;
      (function(ZoomViewportAction2) {
        ZoomViewportAction2.KIND = "zoomViewportAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ZoomViewportAction2.KIND);
        }
        ZoomViewportAction2.is = is;
        function create(zoomFactor) {
          return { kind: ZoomViewportAction2.KIND, zoomFactor };
        }
        ZoomViewportAction2.create = create;
      })(ZoomViewportAction || (exports.ZoomViewportAction = ZoomViewportAction = {}));
      var ZoomElementAction;
      (function(ZoomElementAction2) {
        ZoomElementAction2.KIND = "zoomElementAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ZoomElementAction2.KIND);
        }
        ZoomElementAction2.is = is;
        function create(elementIds, zoomFactor) {
          return { kind: ZoomElementAction2.KIND, elementIds, zoomFactor };
        }
        ZoomElementAction2.create = create;
      })(ZoomElementAction || (exports.ZoomElementAction = ZoomElementAction = {}));
      var ZoomViewportHandler = class ZoomViewportHandler {
        constructor() {
          this.throttledHandleViewportZoom = (0, lodash_1.throttle)((action) => this.handleZoomViewport(action), 150);
        }
        handle(action) {
          if (ZoomViewportAction.is(action)) {
            this.throttledHandleViewportZoom(action);
          }
        }
        handleZoomViewport(action) {
          const viewport = (0, sprotty_1.findParentByFeature)(this.editorContextService.modelRoot, sprotty_1.isViewport);
          if (!viewport) {
            return;
          }
          this.dispatcher.dispatch(this.setNewZoomFactor(viewport, action.zoomFactor));
        }
        setNewZoomFactor(viewport, zoomFactor) {
          const newZoom = viewport.zoom * zoomFactor;
          const newViewport = {
            scroll: viewport.scroll,
            zoom: newZoom
          };
          return sprotty_1.SetViewportAction.create(viewport.id, newViewport, { animate: true });
        }
      };
      exports.ZoomViewportHandler = ZoomViewportHandler;
      ZoomViewportHandler.defaultZoomInFactor = 1.1;
      ZoomViewportHandler.defaultZoomOutFactor = 0.9;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ZoomViewportHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ZoomViewportHandler.prototype, "dispatcher", void 0);
      exports.ZoomViewportHandler = ZoomViewportHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ZoomViewportHandler);
      var ZoomElementHandler = class ZoomElementHandler {
        constructor() {
          this.throttledHandleElementZoom = (0, lodash_1.throttle)((action) => this.handleZoomElement(action), 150);
        }
        handle(action) {
          if (ZoomElementAction.is(action)) {
            this.throttledHandleElementZoom(action);
          }
        }
        handleZoomElement(action) {
          const viewport = (0, sprotty_1.findParentByFeature)(this.editorContextService.modelRoot, sprotty_1.isViewport);
          if (!viewport) {
            return;
          }
          const elements = (0, gmodel_util_1.getElements)(this.editorContextService.modelRoot.index, action.elementIds, gmodel_util_1.isSelectableAndBoundsAware);
          const center = this.getCenter(viewport, elements);
          this.dispatcher.dispatch(this.setNewZoomFactor(viewport, action.zoomFactor, center));
        }
        getCenter(viewport, selectedElements) {
          const allBounds = selectedElements.map((e) => this.boundsInViewport(viewport, e, e.bounds));
          const mergedBounds = allBounds.reduce((b0, b1) => sprotty_1.Bounds.combine(b0, b1));
          return sprotty_1.Bounds.center(mergedBounds);
        }
        // copy from center-fit.ts, translates the children bounds to the viewport bounds
        boundsInViewport(viewport, element, bounds) {
          if (element instanceof sprotty_1.GChildElement && element.parent !== viewport) {
            return this.boundsInViewport(viewport, element.parent, element.parent.localToParent(bounds));
          } else {
            return bounds;
          }
        }
        setNewZoomFactor(viewport, zoomFactor, point) {
          const newZoom = viewport.zoom * zoomFactor;
          const newViewport = {
            scroll: {
              x: point.x - 0.5 * viewport.canvasBounds.width / newZoom,
              y: point.y - 0.5 * viewport.canvasBounds.height / newZoom
            },
            zoom: newZoom
          };
          return sprotty_1.SetViewportAction.create(viewport.id, newViewport, { animate: true });
        }
      };
      exports.ZoomElementHandler = ZoomElementHandler;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ZoomElementHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ZoomElementHandler.prototype, "dispatcher", void 0);
      exports.ZoomElementHandler = ZoomElementHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ZoomElementHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/action.js
  var require_action2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardGridKeyboardEventAction = exports.KeyboardGridCellSelectedAction = exports.EnableKeyboardGridAction = void 0;
      var sprotty_1 = require_lib5();
      var EnableKeyboardGridAction;
      (function(EnableKeyboardGridAction2) {
        EnableKeyboardGridAction2.KIND = "enableKeyboardGrid";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableKeyboardGridAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "options");
        }
        EnableKeyboardGridAction2.is = is;
        function create(options) {
          return {
            kind: EnableKeyboardGridAction2.KIND,
            options
          };
        }
        EnableKeyboardGridAction2.create = create;
      })(EnableKeyboardGridAction || (exports.EnableKeyboardGridAction = EnableKeyboardGridAction = {}));
      var KeyboardGridCellSelectedAction;
      (function(KeyboardGridCellSelectedAction2) {
        KeyboardGridCellSelectedAction2.KIND = "keyboardGridCellSelectedAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, KeyboardGridCellSelectedAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "options");
        }
        KeyboardGridCellSelectedAction2.is = is;
        function create(options) {
          return {
            kind: KeyboardGridCellSelectedAction2.KIND,
            options
          };
        }
        KeyboardGridCellSelectedAction2.create = create;
      })(KeyboardGridCellSelectedAction || (exports.KeyboardGridCellSelectedAction = KeyboardGridCellSelectedAction = {}));
      var KeyboardGridKeyboardEventAction;
      (function(KeyboardGridKeyboardEventAction2) {
        KeyboardGridKeyboardEventAction2.KIND = "keyboardGridKeyboardEvent";
        function is(object) {
          return sprotty_1.Action.hasKind(object, KeyboardGridKeyboardEventAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "options");
        }
        KeyboardGridKeyboardEventAction2.is = is;
        function create(options) {
          return {
            kind: KeyboardGridKeyboardEventAction2.KIND,
            options
          };
        }
        KeyboardGridKeyboardEventAction2.create = create;
      })(KeyboardGridKeyboardEventAction || (exports.KeyboardGridKeyboardEventAction = KeyboardGridKeyboardEventAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/viewpoint-util.js
  var require_viewpoint_util = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/viewpoint-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.absoluteToLocal = exports.absoluteToParent = exports.toAbsoluteSize = exports.toAbsolutePosition = exports.toAbsoluteBounds = exports.getAbsolutePositionByPoint = exports.getAbsolutePosition = void 0;
      var sprotty_1 = require_lib5();
      function getAbsolutePosition2(target, mouseEvent) {
        return getAbsolutePositionByPoint(target, { x: mouseEvent.pageX, y: mouseEvent.pageY });
      }
      exports.getAbsolutePosition = getAbsolutePosition2;
      function getAbsolutePositionByPoint(target, point) {
        let xPos = point.x;
        let yPos = point.y;
        const canvasBounds = target.root.canvasBounds;
        xPos -= canvasBounds.x;
        yPos -= canvasBounds.y;
        const viewport = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isViewport);
        const zoom = viewport ? viewport.zoom : 1;
        if (viewport) {
          const scroll = { x: viewport.scroll.x, y: viewport.scroll.y };
          xPos += scroll.x * zoom;
          yPos += scroll.y * zoom;
          xPos /= zoom;
          yPos /= zoom;
        }
        return {
          x: xPos,
          y: yPos
        };
      }
      exports.getAbsolutePositionByPoint = getAbsolutePositionByPoint;
      function toAbsoluteBounds2(element) {
        const location2 = (0, sprotty_1.isAlignable)(element) ? element.alignment : sprotty_1.Point.ORIGIN;
        const x = location2.x;
        const y = location2.y;
        const width = element.bounds.width;
        const height = element.bounds.height;
        return (0, sprotty_1.translateBounds)({ x, y, width, height }, element, element.root);
      }
      exports.toAbsoluteBounds = toAbsoluteBounds2;
      function toAbsolutePosition2(target) {
        return toAbsoluteBounds2(target);
      }
      exports.toAbsolutePosition = toAbsolutePosition2;
      function toAbsoluteSize(target) {
        return toAbsoluteBounds2(target);
      }
      exports.toAbsoluteSize = toAbsoluteSize;
      function absoluteToParent2(element, absolutePoint) {
        if ((0, sprotty_1.isBoundsAware)(element.parent)) {
          return absoluteToLocal(element.parent, absolutePoint);
        }
        return absoluteToLocal(element, absolutePoint);
      }
      exports.absoluteToParent = absoluteToParent2;
      function absoluteToLocal(element, absolutePoint) {
        const absoluteElementBounds = toAbsoluteBounds2(element);
        return { x: absolutePoint.x - absoluteElementBounds.x, y: absolutePoint.y - absoluteElementBounds.y };
      }
      exports.absoluteToLocal = absoluteToLocal;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/zoom-key-tool.js
  var require_zoom_key_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/zoom-key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var ZoomKeyTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoomKeyListener = exports.ZoomKeyTool = void 0;
      var inversify_1 = require_inversify();
      var keyboard_1 = require_keyboard();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var selection_service_1 = require_selection_service();
      var accessible_key_shortcut_1 = require_accessible_key_shortcut();
      var zoom_handler_1 = require_zoom_handler();
      var action_1 = require_action2();
      var viewpoint_util_1 = require_viewpoint_util();
      var editor_context_service_1 = require_editor_context_service();
      var toast_handler_1 = require_toast_handler();
      var diagram_navigation_tool_1 = require_diagram_navigation_tool();
      var messages = require_messages2();
      var ZoomKeyTool = ZoomKeyTool_1 = class ZoomKeyTool {
        constructor() {
          this.isEditTool = false;
          this.zoomKeyListener = new ZoomKeyListener(this);
        }
        get id() {
          return ZoomKeyTool_1.ID;
        }
        enable() {
          this.keytool.register(this.zoomKeyListener);
          this.zoomKeyListener.registerShortcutKey();
        }
        disable() {
          this.keytool.deregister(this.zoomKeyListener);
        }
        handle(action) {
          if ((0, sprotty_1.isViewport)(this.editorContextService.modelRoot)) {
            let viewportAction = void 0;
            if (action_1.KeyboardGridCellSelectedAction.is(action) && action.options.originId === ZoomKeyTool_1.ID) {
              viewportAction = this.zoomKeyListener.setNewZoomFactor(this.editorContextService.modelRoot, ZoomKeyListener.defaultZoomInFactor, (0, viewpoint_util_1.getAbsolutePositionByPoint)(this.editorContextService.modelRoot, action.options.centerCellPosition));
            } else if (action_1.KeyboardGridKeyboardEventAction.is(action) && action.options.originId === ZoomKeyTool_1.ID) {
              if ((0, keyboard_1.matchesKeystroke)(action.options.event, "Minus")) {
                viewportAction = this.zoomKeyListener.setNewZoomFactor(this.editorContextService.modelRoot, ZoomKeyListener.defaultZoomOutFactor);
              } else if ((0, keyboard_1.matchesKeystroke)(action.options.event, "Digit0", "ctrl")) {
                viewportAction = sprotty_1.CenterAction.create([]);
              }
            }
            if (viewportAction) {
              this.actionDispatcher.dispatchAll([
                viewportAction,
                toast_handler_1.HideToastAction.create({ id: Symbol.for(diagram_navigation_tool_1.ElementNavigatorKeyListener.name) })
              ]);
            }
          }
        }
      };
      exports.ZoomKeyTool = ZoomKeyTool;
      ZoomKeyTool.ID = "glsp.zoom-key-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], ZoomKeyTool.prototype, "keytool", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], ZoomKeyTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], ZoomKeyTool.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ZoomKeyTool.prototype, "editorContextService", void 0);
      exports.ZoomKeyTool = ZoomKeyTool = ZoomKeyTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ZoomKeyTool);
      var ZoomKeyListener = class extends sprotty_1.KeyListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.token = ZoomKeyListener.name;
        }
        registerShortcutKey() {
          this.tool.actionDispatcher.dispatchOnceModelInitialized(accessible_key_shortcut_1.SetAccessibleKeyShortcutAction.create({
            token: this.token,
            keys: [
              { shortcuts: ["+"], description: "Zoom in to element or viewport", group: "Zoom", position: 0 },
              { shortcuts: ["-"], description: "Zoom out to element or viewport", group: "Zoom", position: 1 },
              { shortcuts: ["CTRL", "0"], description: "Reset zoom to default", group: "Zoom", position: 2 },
              { shortcuts: ["CTRL", "+"], description: "Zoom in via Grid", group: "Zoom", position: 3 }
            ]
          }));
        }
        setNewZoomFactor(viewport, zoomFactor, point) {
          let newViewport;
          const newZoom = viewport.zoom * zoomFactor;
          if (point) {
            newViewport = {
              scroll: {
                x: point.x - 0.5 * viewport.canvasBounds.width / newZoom,
                y: point.y - 0.5 * viewport.canvasBounds.height / newZoom
              },
              zoom: newZoom
            };
          } else {
            newViewport = {
              scroll: viewport.scroll,
              zoom: newZoom
            };
          }
          return sprotty_1.SetViewportAction.create(viewport.id, newViewport, { animate: true });
        }
        keyDown(element, event) {
          const selectedElementIds = this.tool.selectionService.getSelectedElementIDs();
          if (this.matchesZoomViaGrid(event)) {
            return [
              action_1.EnableKeyboardGridAction.create({
                originId: ZoomKeyTool.ID,
                triggerActions: []
              }),
              toast_handler_1.ShowToastMessageAction.createWithTimeout({
                id: Symbol.for(diagram_navigation_tool_1.ElementNavigatorKeyListener.name),
                message: messages.grid.zoom_in_grid
              })
            ];
          } else if (this.matchesZoomOutKeystroke(event)) {
            if (selectedElementIds.length > 0) {
              return [zoom_handler_1.ZoomElementAction.create(selectedElementIds, ZoomKeyListener.defaultZoomOutFactor)];
            } else {
              return [zoom_handler_1.ZoomViewportAction.create(ZoomKeyListener.defaultZoomOutFactor)];
            }
          } else if (this.matchesZoomInKeystroke(event)) {
            if (selectedElementIds.length > 0) {
              return [zoom_handler_1.ZoomElementAction.create(selectedElementIds, ZoomKeyListener.defaultZoomInFactor)];
            } else {
              return [zoom_handler_1.ZoomViewportAction.create(ZoomKeyListener.defaultZoomInFactor)];
            }
          } else if (this.matchesMinZoomLevelKeystroke(event)) {
            return [sprotty_1.CenterAction.create(selectedElementIds)];
          }
          return [];
        }
        matchesZoomInKeystroke(event) {
          return event.key === "+" || (0, keyboard_1.matchesKeystroke)(event, "NumpadAdd");
        }
        matchesZoomViaGrid(event) {
          return event.key === "+" && event.ctrlKey;
        }
        matchesMinZoomLevelKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Digit0", "ctrl") || (0, keyboard_1.matchesKeystroke)(event, "Numpad0", "ctrl");
        }
        matchesZoomOutKeystroke(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Minus") || (0, keyboard_1.matchesKeystroke)(event, "NumpadSubtract");
        }
      };
      exports.ZoomKeyListener = ZoomKeyListener;
      ZoomKeyListener.defaultZoomInFactor = 1.1;
      ZoomKeyListener.defaultZoomOutFactor = 0.9;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/freeform-layout.js
  var require_freeform_layout = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/freeform-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FreeFormLayouter = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var FreeFormLayouter = class FreeFormLayouter extends sprotty_1.AbstractLayout {
        layout(container, layouter) {
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const maxWidth = childrenSize.width > 0 ? childrenSize.width + options.paddingLeft + options.paddingRight : 0;
          const maxHeight = childrenSize.height > 0 ? childrenSize.height + options.paddingTop + options.paddingBottom : 0;
          if (maxWidth > 0 && maxHeight > 0) {
            const offset = this.layoutChildren(container, layouter, options, maxWidth, maxHeight);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, maxWidth, maxHeight);
            boundsData.boundsChanged = true;
          } else {
            boundsData.bounds = { x: boundsData.bounds.x, y: boundsData.bounds.y, width: 0, height: 0 };
            boundsData.boundsChanged = true;
          }
        }
        getChildrenSize(container, containerOptions, layouter) {
          let maxX = 0;
          let maxY = 0;
          container.children.forEach((child) => {
            const bounds = layouter.getBoundsData(child).bounds;
            if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
              const childMaxX = bounds.x + bounds.width;
              const childMaxY = bounds.y + bounds.height;
              maxX = Math.max(maxX, childMaxX);
              maxY = Math.max(maxY, childMaxY);
            }
          });
          return {
            width: maxX,
            height: maxY
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          boundsData.bounds = {
            x: child.bounds.x,
            y: child.bounds.y,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return currentOffset;
        }
        getFinalContainerBounds(container, lastOffset, options, maxWidth, maxHeight) {
          const result = {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(options.minWidth, maxWidth + options.paddingLeft + options.paddingRight),
            height: Math.max(options.minHeight, maxHeight + options.paddingTop + options.paddingBottom)
          };
          return result;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
            paddingFactor: 1,
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a, b) {
          return Object.assign(Object.assign({}, a), b);
        }
      };
      exports.FreeFormLayouter = FreeFormLayouter;
      FreeFormLayouter.KIND = "freeform";
      exports.FreeFormLayouter = FreeFormLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], FreeFormLayouter);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/glsp-hidden-bounds-updater.js
  var require_glsp_hidden_bounds_updater = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/glsp-hidden-bounds-updater.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPHiddenBoundsUpdater = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var gmodel_util_1 = require_gmodel_util();
      var GLSPHiddenBoundsUpdater = class GLSPHiddenBoundsUpdater extends sprotty_1.HiddenBoundsUpdater {
        constructor() {
          super(...arguments);
          this.element2route = [];
          this.edges = [];
          this.nodes = [];
        }
        decorate(vnode, element) {
          super.decorate(vnode, element);
          if ((0, gmodel_util_1.isRoutable)(element)) {
            this.element2route.push((0, gmodel_util_1.calcElementAndRoute)(element, this.edgeRouterRegistry));
          }
          return vnode;
        }
        postUpdate(cause) {
          const actions = this.captureActions(() => super.postUpdate(cause));
          actions.filter((action) => sprotty_1.ComputedBoundsAction.is(action)).forEach((action) => this.actionDispatcher.dispatch(this.enhanceAction(action)));
          this.element2route = [];
        }
        captureActions(call) {
          const capturingActionDispatcher = new CapturingActionDispatcher();
          const actualActionDispatcher = this.actionDispatcher;
          this.actionDispatcher = capturingActionDispatcher;
          try {
            call();
            return capturingActionDispatcher.actions;
          } finally {
            this.actionDispatcher = actualActionDispatcher;
          }
        }
        enhanceAction(action) {
          action.routes = this.element2route.length === 0 ? void 0 : this.element2route;
          return action;
        }
      };
      exports.GLSPHiddenBoundsUpdater = GLSPHiddenBoundsUpdater;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], GLSPHiddenBoundsUpdater.prototype, "edgeRouterRegistry", void 0);
      exports.GLSPHiddenBoundsUpdater = GLSPHiddenBoundsUpdater = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPHiddenBoundsUpdater);
      var CapturingActionDispatcher = class {
        constructor() {
          this.actions = [];
        }
        async dispatch(action) {
          this.actions.push(action);
        }
        async dispatchAll(actions) {
          this.actions.push(...actions);
        }
        async request(action) {
          return new sprotty_1.Deferred().promise;
        }
      };
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/hbox-layout.js
  var require_hbox_layout2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/hbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HBoxLayouterExt = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var HBoxLayouterExt = class HBoxLayouterExt extends sprotty_1.HBoxLayouter {
        layout(container, layouter) {
          var _a, _b;
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const fixedSize = this.getFixedContainerBounds(container, options, layouter);
          const currentWidth = boundsData.bounds ? ((_a = boundsData.bounds) === null || _a === void 0 ? void 0 : _a.width) - options.paddingLeft - options.paddingRight : 0;
          const currentHeight = boundsData.bounds ? ((_b = boundsData.bounds) === null || _b === void 0 ? void 0 : _b.height) - options.paddingTop - options.paddingBottom : 0;
          const maxWidth = options.paddingFactor * (options.resizeContainer ? Math.max(fixedSize.width - options.paddingLeft - options.paddingRight, childrenSize.width) : Math.max(0, fixedSize.width - options.paddingLeft - options.paddingRight));
          const maxHeight = options.paddingFactor * (options.resizeContainer ? Math.max(fixedSize.height - options.paddingTop - options.paddingBottom, childrenSize.height) : Math.max(0, fixedSize.height - options.paddingTop - options.paddingBottom));
          const width = Math.max(currentWidth, maxWidth);
          const height = Math.max(currentHeight, maxHeight);
          const grabWidth = width - childrenSize.width;
          const grabbingChildren = container.children.map((child) => this.getChildLayoutOptions(child, options)).filter((opt) => opt.hGrab).length;
          if (width > 0 && height > 0) {
            const offset = this.layoutChildren(container, layouter, options, width, height, grabWidth, grabbingChildren);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, childrenSize.width, childrenSize.height);
            boundsData.boundsChanged = true;
          }
        }
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = 0;
          let maxHeight = -1;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, sprotty_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
                maxWidth += bounds.width;
                if (isFirst) {
                  isFirst = false;
                } else {
                  maxWidth += containerOptions.hGap;
                }
                maxHeight = Math.max(maxHeight, bounds.height);
              }
            }
          });
          const result = {
            width: maxWidth,
            height: maxHeight
          };
          return result;
        }
        layoutChildren(container, layouter, containerOptions, maxWidth, maxHeight, grabWidth, grabbingChildren) {
          let currentOffset = {
            x: containerOptions.paddingLeft + 0.5 * (maxWidth - maxWidth / containerOptions.paddingFactor),
            y: containerOptions.paddingTop + 0.5 * (maxHeight - maxHeight / containerOptions.paddingFactor)
          };
          container.children.forEach((child) => {
            if ((0, sprotty_1.isLayoutableChild)(child)) {
              const boundsData = layouter.getBoundsData(child);
              const bounds = boundsData.bounds;
              const childOptions = this.getChildLayoutOptions(child, containerOptions);
              if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
                currentOffset = this.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight, grabWidth, grabbingChildren);
              }
            }
          });
          return currentOffset;
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight, grabWidth, grabbingChildren) {
          const vAlign = childOptions.vGrab ? "top" : childOptions.vAlign;
          const dy = this.getDy(vAlign, bounds, maxHeight);
          let offset = super.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight);
          boundsData.bounds = Object.assign(Object.assign({}, boundsData.bounds), { x: currentOffset.x, y: currentOffset.y + dy });
          if (childOptions.vGrab) {
            boundsData.bounds = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y,
              width: boundsData.bounds.width,
              height: maxHeight
            };
            boundsData.boundsChanged = true;
          }
          if (childOptions.hGrab && grabWidth && grabbingChildren) {
            const width = boundsData.bounds.width + grabWidth / grabbingChildren;
            boundsData.bounds = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y,
              width,
              height: boundsData.bounds.height
            };
            boundsData.boundsChanged = true;
            offset = { x: currentOffset.x + width, y: currentOffset.y };
          }
          return offset;
        }
        getFixedContainerBounds(container, layoutOptions, layouter) {
          var _a, _b;
          const currentContainer = container;
          if ((0, sprotty_1.isBoundsAware)(currentContainer)) {
            const bounds = currentContainer.bounds;
            const elementOptions = this.getElementLayoutOptions(currentContainer);
            const width = (_a = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefWidth) !== null && _a !== void 0 ? _a : 0;
            const height = (_b = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefHeight) !== null && _b !== void 0 ? _b : 0;
            return Object.assign(Object.assign({}, bounds), { width, height });
          }
          return sprotty_1.Bounds.EMPTY;
        }
        getChildLayoutOptions(child, containerOptions) {
          return super.getChildLayoutOptions(child, this.filterContainerOptions(containerOptions));
        }
        getLayoutOptions(element) {
          return super.getLayoutOptions(element);
        }
        getElementLayoutOptions(element) {
          return element.layoutOptions;
        }
        getFinalContainerBounds(container, lastOffset, options, maxWidth, maxHeight) {
          var _a, _b;
          const elementOptions = this.getElementLayoutOptions(container);
          const width = (_a = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefWidth) !== null && _a !== void 0 ? _a : options.minWidth;
          const height = (_b = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefHeight) !== null && _b !== void 0 ? _b : options.minHeight;
          const result = {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(width, maxWidth + options.paddingLeft + options.paddingRight),
            height: Math.max(height, maxHeight + options.paddingTop + options.paddingBottom)
          };
          return result;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            hGap: 1,
            vAlign: "center",
            minWidth: 0,
            minHeight: 0,
            hGrab: false,
            vGrab: false,
            // eslint-disable-next-line no-null/no-null
            prefHeight: null,
            // eslint-disable-next-line no-null/no-null
            prefWidth: null
          };
        }
        filterContainerOptions(containerOptions) {
          const localOptions = { vGrab: false, hGrab: false, prefHeight: null, prefWidth: null };
          return Object.assign(Object.assign({}, containerOptions), localOptions);
        }
      };
      exports.HBoxLayouterExt = HBoxLayouterExt;
      HBoxLayouterExt.KIND = sprotty_1.HBoxLayouter.KIND;
      exports.HBoxLayouterExt = HBoxLayouterExt = __decorate([
        (0, inversify_1.injectable)()
      ], HBoxLayouterExt);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/layouter.js
  var require_layouter = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/layouter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatefulLayouterExt = exports.LayouterExt = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var LayouterExt = class LayouterExt extends sprotty_1.Layouter {
        layout(element2boundsData) {
          new StatefulLayouterExt(element2boundsData, this.layoutRegistry, this.logger).layout();
        }
      };
      exports.LayouterExt = LayouterExt;
      exports.LayouterExt = LayouterExt = __decorate([
        (0, inversify_1.injectable)()
      ], LayouterExt);
      var StatefulLayouterExt = class extends sprotty_1.StatefulLayouter {
        /**
         *
         * @param elementToBoundsData The map of element to bounds data. Bounds Data are computed from the hidden
         * SVG rendering pass.
         * @param layoutRegistry2 The registry of available layouts.
         * @param log The log.
         */
        constructor(elementToBoundsData, layoutRegistry2, log) {
          super(elementToBoundsData, layoutRegistry2, log);
          this.elementToBoundsData = elementToBoundsData;
          this.layoutRegistry2 = layoutRegistry2;
          this.toBeLayouted2 = [];
          elementToBoundsData.forEach((data, element) => {
            if ((0, sprotty_1.isLayoutContainer)(element)) {
              this.toBeLayouted2.push(element);
            }
          });
          for (const element of this.toBeLayouted2) {
            elementToBoundsData.delete(element);
          }
        }
        getBoundsData(element) {
          let boundsData = this.elementToBoundsData.get(element);
          let bounds = element.bounds;
          if ((0, sprotty_1.isLayoutContainer)(element) && this.toBeLayouted2.indexOf(element) >= 0) {
            bounds = this.doLayout(element);
          } else if ((0, sprotty_1.isLayoutContainer)(element)) {
            bounds = {
              x: 0,
              y: 0,
              width: -1,
              height: -1
            };
          }
          if (!boundsData) {
            boundsData = {
              bounds,
              boundsChanged: false,
              alignmentChanged: false
            };
            this.elementToBoundsData.set(element, boundsData);
          }
          return boundsData;
        }
        layout() {
          while (this.toBeLayouted2.length > 0) {
            const element = this.toBeLayouted2[0];
            this.doLayout(element);
          }
          this.toBeLayouted2 = [];
          this.elementToBoundsData.forEach((data, element) => {
            if ((0, sprotty_1.isLayoutContainer)(element)) {
              this.toBeLayouted2.push(element);
            }
          });
          while (this.toBeLayouted2.length > 0) {
            const element = this.toBeLayouted2[0];
            this.doLayout(element);
          }
        }
        doLayout(element) {
          const index = this.toBeLayouted2.indexOf(element);
          if (index >= 0) {
            this.toBeLayouted2.splice(index, 1);
          }
          const layout = this.layoutRegistry2.get(element.layout);
          if (layout) {
            layout.layout(element, this);
          }
          const boundsData = this.elementToBoundsData.get(element);
          if (boundsData !== void 0 && boundsData.bounds !== void 0) {
            return boundsData.bounds;
          } else {
            this.log.error(element, "Layout failed");
            return sprotty_1.Bounds.EMPTY;
          }
        }
      };
      exports.StatefulLayouterExt = StatefulLayouterExt;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/vbox-layout.js
  var require_vbox_layout2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/vbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VBoxLayouterExt = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var VBoxLayouterExt = class VBoxLayouterExt extends sprotty_1.VBoxLayouter {
        layout(container, layouter) {
          var _a, _b;
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const fixedSize = this.getFixedContainerBounds(container, options, layouter);
          const currentWidth = (((_a = boundsData.bounds) === null || _a === void 0 ? void 0 : _a.width) || 0) - options.paddingLeft - options.paddingRight;
          const currentHeight = (((_b = boundsData.bounds) === null || _b === void 0 ? void 0 : _b.height) || 0) - options.paddingTop - options.paddingBottom;
          const maxWidth = options.paddingFactor * (options.resizeContainer ? Math.max(fixedSize.width - options.paddingLeft - options.paddingRight, childrenSize.width) : Math.max(0, fixedSize.width - options.paddingLeft - options.paddingRight));
          const maxHeight = options.paddingFactor * (options.resizeContainer ? Math.max(fixedSize.height - options.paddingTop - options.paddingBottom, childrenSize.height) : Math.max(0, fixedSize.height - options.paddingTop - options.paddingBottom));
          const width = Math.max(currentWidth, maxWidth);
          const height = Math.max(currentHeight, maxHeight);
          const grabHeight = height - childrenSize.height;
          const grabbingChildren = container.children.map((child) => this.getChildLayoutOptions(child, options)).filter((opt) => opt.vGrab).length;
          if (maxWidth > 0 && maxHeight > 0) {
            const offset = this.layoutChildren(container, layouter, options, width, height, grabHeight, grabbingChildren);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, childrenSize.width, childrenSize.height);
            boundsData.boundsChanged = true;
          }
        }
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = -1;
          let maxHeight = 0;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, sprotty_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
                maxHeight += bounds.height;
                if (isFirst) {
                  isFirst = false;
                } else {
                  maxHeight += containerOptions.vGap;
                }
                maxWidth = Math.max(maxWidth, bounds.width);
              }
            }
          });
          const result = {
            width: maxWidth,
            height: maxHeight
          };
          return result;
        }
        layoutChildren(container, layouter, containerOptions, maxWidth, maxHeight, grabHeight, grabbingChildren) {
          let currentOffset = {
            x: containerOptions.paddingLeft + 0.5 * (maxWidth - maxWidth / containerOptions.paddingFactor),
            y: containerOptions.paddingTop + 0.5 * (maxHeight - maxHeight / containerOptions.paddingFactor)
          };
          container.children.forEach((child) => {
            if ((0, sprotty_1.isLayoutableChild)(child)) {
              const boundsData = layouter.getBoundsData(child);
              const bounds = boundsData.bounds;
              const childOptions = this.getChildLayoutOptions(child, containerOptions);
              if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
                currentOffset = this.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight, grabHeight, grabbingChildren);
              }
            }
          });
          return currentOffset;
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight, grabHeight, grabbingChildren) {
          const hAlign = childOptions.hGrab ? "left" : childOptions.hAlign;
          const dx = this.getDx(hAlign, bounds, maxWidth);
          let offset = super.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight);
          boundsData.bounds = Object.assign(Object.assign({}, boundsData.bounds), { x: currentOffset.x + dx, y: currentOffset.y });
          if (childOptions.hGrab) {
            boundsData.bounds = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y,
              width: maxWidth,
              height: boundsData.bounds.height
            };
            boundsData.boundsChanged = true;
          }
          if (childOptions.vGrab && grabHeight && grabbingChildren) {
            const height = boundsData.bounds.height + grabHeight / grabbingChildren;
            boundsData.bounds = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y,
              width: boundsData.bounds.width,
              height
            };
            boundsData.boundsChanged = true;
            offset = { x: currentOffset.x, y: currentOffset.y + height };
          }
          return offset;
        }
        getFixedContainerBounds(container, layoutOptions, layouter) {
          var _a, _b;
          const currentContainer = container;
          if ((0, sprotty_1.isBoundsAware)(currentContainer)) {
            const bounds = currentContainer.bounds;
            const elementOptions = this.getElementLayoutOptions(currentContainer);
            const width = (_a = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefWidth) !== null && _a !== void 0 ? _a : 0;
            const height = (_b = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefHeight) !== null && _b !== void 0 ? _b : 0;
            return Object.assign(Object.assign({}, bounds), { width, height });
          }
          return sprotty_1.Bounds.EMPTY;
        }
        getChildLayoutOptions(child, containerOptions) {
          return super.getChildLayoutOptions(child, this.filterContainerOptions(containerOptions));
        }
        getLayoutOptions(element) {
          return super.getLayoutOptions(element);
        }
        getElementLayoutOptions(element) {
          return element.layoutOptions;
        }
        getFinalContainerBounds(container, lastOffset, options, maxWidth, maxHeight) {
          var _a, _b;
          const elementOptions = this.getElementLayoutOptions(container);
          const width = (_a = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefWidth) !== null && _a !== void 0 ? _a : options.minWidth;
          const height = (_b = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefHeight) !== null && _b !== void 0 ? _b : options.minHeight;
          const result = {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(width, maxWidth + options.paddingLeft + options.paddingRight),
            height: Math.max(height, maxHeight + options.paddingTop + options.paddingBottom)
          };
          return result;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            vGap: 1,
            hAlign: "center",
            minWidth: 0,
            minHeight: 0,
            hGrab: false,
            vGrab: false,
            // eslint-disable-next-line no-null/no-null
            prefHeight: null,
            // eslint-disable-next-line no-null/no-null
            prefWidth: null
          };
        }
        filterContainerOptions(containerOptions) {
          const localOptions = { vGrab: false, hGrab: false, prefHeight: null, prefWidth: null };
          return Object.assign(Object.assign({}, containerOptions), localOptions);
        }
      };
      exports.VBoxLayouterExt = VBoxLayouterExt;
      VBoxLayouterExt.KIND = sprotty_1.VBoxLayouter.KIND;
      exports.VBoxLayouterExt = VBoxLayouterExt = __decorate([
        (0, inversify_1.injectable)()
      ], VBoxLayouterExt);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/movement-restrictor.js
  var require_movement_restrictor = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/movement-restrictor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.removeMovementRestrictionFeedback = exports.createMovementRestrictionFeedback = exports.NoOverlapMovementRestrictor = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var css_feedback_1 = require_css_feedback();
      var viewpoint_util_1 = require_viewpoint_util();
      var model_1 = require_model22();
      var NoOverlapMovementRestrictor = class NoOverlapMovementRestrictor {
        constructor() {
          this.cssClasses = ["movement-not-allowed"];
        }
        validate(element, newLocation) {
          if (!(0, model_1.isBoundsAwareMoveable)(element) || !newLocation) {
            return false;
          }
          const ghostElement = Object.create(element);
          ghostElement.bounds = {
            x: newLocation.x,
            y: newLocation.y,
            width: element.bounds.width,
            height: element.bounds.height
          };
          ghostElement.type = "Ghost";
          ghostElement.id = element.id;
          return !Array.from(element.root.index.all().filter((e) => e.id !== ghostElement.id && e !== ghostElement.root && e instanceof sprotty_1.GNode).map((e) => e)).some((e) => this.areOverlapping(e, ghostElement));
        }
        areOverlapping(element1, element2) {
          const b1 = (0, viewpoint_util_1.toAbsoluteBounds)(element1);
          const b2 = (0, viewpoint_util_1.toAbsoluteBounds)(element2);
          const r1TopLeft = b1;
          const r1BottomRight = { x: b1.x + b1.width, y: b1.y + b1.height };
          const r2TopLeft = b2;
          const r2BottomRight = { x: b2.x + b2.width, y: b2.y + b2.height };
          if (r1TopLeft.x > r2BottomRight.x || r2TopLeft.x > r1BottomRight.x) {
            return false;
          }
          if (r1BottomRight.y < r2TopLeft.y || r2BottomRight.y < r1TopLeft.y) {
            return false;
          }
          return true;
        }
      };
      exports.NoOverlapMovementRestrictor = NoOverlapMovementRestrictor;
      exports.NoOverlapMovementRestrictor = NoOverlapMovementRestrictor = __decorate([
        (0, inversify_1.injectable)()
      ], NoOverlapMovementRestrictor);
      function createMovementRestrictionFeedback(element, movementRestrictor) {
        const elements = [element];
        if (element instanceof sprotty_1.GParentElement) {
          element.children.filter((child) => child instanceof model_1.SResizeHandle).forEach((e) => elements.push(e));
        }
        return css_feedback_1.ModifyCSSFeedbackAction.create({ elements, add: movementRestrictor.cssClasses });
      }
      exports.createMovementRestrictionFeedback = createMovementRestrictionFeedback;
      function removeMovementRestrictionFeedback(element, movementRestrictor) {
        const elements = [element];
        if (element instanceof sprotty_1.GParentElement) {
          element.children.filter((child) => child instanceof model_1.SResizeHandle).forEach((e) => elements.push(e));
        }
        return css_feedback_1.ModifyCSSFeedbackAction.create({ elements, remove: movementRestrictor.cssClasses });
      }
      exports.removeMovementRestrictionFeedback = removeMovementRestrictionFeedback;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette-tool.js
  var require_command_palette_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var CommandPaletteTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommandPaletteTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var CommandPaletteTool = CommandPaletteTool_1 = class CommandPaletteTool {
        postConstruct() {
          this.commandPaletteKeyListener = this.createCommandPaletteKeyListener();
        }
        get id() {
          return CommandPaletteTool_1.ID;
        }
        enable() {
          this.keyTool.register(this.commandPaletteKeyListener);
        }
        disable() {
          this.keyTool.deregister(this.commandPaletteKeyListener);
        }
        createCommandPaletteKeyListener() {
          return new sprotty_1.CommandPaletteKeyListener();
        }
      };
      exports.CommandPaletteTool = CommandPaletteTool;
      CommandPaletteTool.ID = "glsp.command-palette-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], CommandPaletteTool.prototype, "keyTool", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], CommandPaletteTool.prototype, "postConstruct", null);
      exports.CommandPaletteTool = CommandPaletteTool = CommandPaletteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], CommandPaletteTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/command-palette/server-command-palette-provider.js
  var require_server_command_palette_provider = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/command-palette/server-command-palette-provider.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerCommandPaletteActionProvider = exports.ServerCommandPalette = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var editor_context_service_1 = require_editor_context_service();
      var ServerCommandPalette;
      (function(ServerCommandPalette2) {
        ServerCommandPalette2.CONTEXT_ID = "command-palette";
        ServerCommandPalette2.TEXT = "text";
        ServerCommandPalette2.INDEX = "index";
      })(ServerCommandPalette || (exports.ServerCommandPalette = ServerCommandPalette = {}));
      var ServerCommandPaletteActionProvider = class ServerCommandPaletteActionProvider {
        async getActions(_root, text, _lastMousePosition, index) {
          const requestAction = sprotty_1.RequestContextActions.create({
            contextId: ServerCommandPalette.CONTEXT_ID,
            editorContext: this.editorContext.get({
              [ServerCommandPalette.TEXT]: text,
              [ServerCommandPalette.INDEX]: index ? index : 0
            })
          });
          const response = await this.actionDispatcher.requestUntil(requestAction);
          return response ? this.getPaletteActionsFromResponse(response) : [];
        }
        getPaletteActionsFromResponse(action) {
          if (sprotty_1.SetContextActions.is(action)) {
            return action.actions;
          }
          return [];
        }
      };
      exports.ServerCommandPaletteActionProvider = ServerCommandPaletteActionProvider;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], ServerCommandPaletteActionProvider.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ServerCommandPaletteActionProvider.prototype, "editorContext", void 0);
      exports.ServerCommandPaletteActionProvider = ServerCommandPaletteActionProvider = __decorate([
        (0, inversify_1.injectable)()
      ], ServerCommandPaletteActionProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/context-menu/delete-element-context-menu.js
  var require_delete_element_context_menu = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/context-menu/delete-element-context-menu.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteElementContextMenuItemProvider = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var DeleteElementContextMenuItemProvider = class DeleteElementContextMenuItemProvider {
        async getItems(_root, _lastMousePosition) {
          const editorContextService = await this.editorContextServiceProvider();
          return [this.createDeleteMenuItem(editorContextService)];
        }
        createDeleteMenuItem(editorContextService) {
          return {
            id: "delete",
            label: "Delete",
            sortString: "d",
            group: "edit",
            actions: [sprotty_1.DeleteElementOperation.create(editorContextService.selectedElements.map((e) => e.id))],
            isEnabled: () => !editorContextService.isReadonly && editorContextService.selectedElements.length > 0
          };
        }
      };
      exports.DeleteElementContextMenuItemProvider = DeleteElementContextMenuItemProvider;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IEditorContextServiceProvider),
        __metadata("design:type", Function)
      ], DeleteElementContextMenuItemProvider.prototype, "editorContextServiceProvider", void 0);
      exports.DeleteElementContextMenuItemProvider = DeleteElementContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteElementContextMenuItemProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/context-menu/glsp-context-menu-mouse-listener.js
  var require_glsp_context_menu_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/context-menu/glsp-context-menu-mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPContextMenuMouseListener = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var action_dispatcher_1 = require_action_dispatcher2();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var GLSPContextMenuMouseListener = class GLSPContextMenuMouseListener extends sprotty_1.MouseListener {
        initialize() {
          var _a;
          (_a = this.contextMenuServiceProvider) === null || _a === void 0 ? void 0 : _a.call(this).then((menuService) => this.menuService = menuService);
        }
        /**
         * Opens the context menu.
         */
        contextMenu(target, event) {
          return this.openContextMenu(target, event);
        }
        /**
         * Opens the context menu.
         *
         *   - update selection state (if context menu target is selectable)
         *   - query the context menu service and the context menu elements
         *   - show the context menu
         *   - send a focus state change to indicate that the diagram becomes inactive, once the context menu is shown
         *
         * When the context menu is closed, we focus the diagram element again.
         */
        openContextMenu(target, event) {
          if (!this.menuService || !this.menuProvider) {
            return [];
          }
          return [this.showContextMenuItems(target, event)];
        }
        async showContextMenuItems(target, event) {
          await this.handleContextElementSelection(target, event);
          const mousePosition = { x: event.x, y: event.y };
          const menuItems = await this.menuProvider.getItems(target.root, mousePosition);
          this.menuService.show(menuItems, mousePosition, () => this.focusEventTarget(event));
          return focus_state_change_action_1.FocusStateChangedAction.create(false);
        }
        // Clear selection the context menu target is not selectable
        // Otherwise either maintain current selection if target is already selected or single select the current target.
        async handleContextElementSelection(target, event) {
          const selectableTarget = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isSelectable);
          if (!selectableTarget) {
            return this.actionDispatcher.dispatch(sprotty_1.SelectAction.setSelection([]));
          }
          if (!selectableTarget.selected) {
            return this.actionDispatcher.dispatch(sprotty_1.SelectAction.setSelection([selectableTarget.id]));
          }
          return;
        }
        focusEventTarget(event) {
          const targetElement = event.target instanceof SVGElement ? event.target : void 0;
          const svgParentElement = targetElement === null || targetElement === void 0 ? void 0 : targetElement.closest("svg");
          if (svgParentElement) {
            svgParentElement.focus();
          }
        }
      };
      exports.GLSPContextMenuMouseListener = GLSPContextMenuMouseListener;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IContextMenuServiceProvider),
        (0, inversify_1.optional)(),
        __metadata("design:type", Function)
      ], GLSPContextMenuMouseListener.prototype, "contextMenuServiceProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IContextMenuProviderRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.ContextMenuProviderRegistry)
      ], GLSPContextMenuMouseListener.prototype, "menuProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(action_dispatcher_1.GLSPActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], GLSPContextMenuMouseListener.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], GLSPContextMenuMouseListener.prototype, "initialize", null);
      exports.GLSPContextMenuMouseListener = GLSPContextMenuMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPContextMenuMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/context-menu/server-context-menu-provider.js
  var require_server_context_menu_provider = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/context-menu/server-context-menu-provider.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerContextMenuItemProvider = exports.ServerContextMenu = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var editor_context_service_1 = require_editor_context_service();
      var ServerContextMenu;
      (function(ServerContextMenu2) {
        ServerContextMenu2.CONTEXT_ID = "context-menu";
      })(ServerContextMenu || (exports.ServerContextMenu = ServerContextMenu = {}));
      var ServerContextMenuItemProvider = class ServerContextMenuItemProvider {
        async getItems(root, _lastMousePosition) {
          const selectedElementIds = Array.from(root.index.all().filter(sprotty_1.isSelected).map((e) => e.id));
          const editorContext = this.editorContext.getWithSelection(selectedElementIds);
          const requestAction = sprotty_1.RequestContextActions.create({ contextId: ServerContextMenu.CONTEXT_ID, editorContext });
          const response = await this.actionDispatcher.requestUntil(requestAction);
          return response ? this.getContextActionsFromResponse(response) : [];
        }
        getContextActionsFromResponse(action) {
          if (sprotty_1.SetContextActions.is(action)) {
            return action.actions;
          }
          return [];
        }
      };
      exports.ServerContextMenuItemProvider = ServerContextMenuItemProvider;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], ServerContextMenuItemProvider.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ServerContextMenuItemProvider.prototype, "editorContext", void 0);
      exports.ServerContextMenuItemProvider = ServerContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], ServerContextMenuItemProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-context-menu.js
  var require_copy_paste_context_menu = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-context-menu.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isNative = exports.supportsPaste = exports.supportsCut = exports.supportsCopy = exports.CopyPasteContextMenuItemProvider = exports.InvokeCopyPasteActionHandler = exports.InvokeCopyPasteAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var InvokeCopyPasteAction;
      (function(InvokeCopyPasteAction2) {
        InvokeCopyPasteAction2.KIND = "invokeCopyPaste";
        function is(object) {
          return sprotty_1.Action.hasKind(object, InvokeCopyPasteAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "command");
        }
        InvokeCopyPasteAction2.is = is;
        function create(command) {
          return { kind: InvokeCopyPasteAction2.KIND, command };
        }
        InvokeCopyPasteAction2.create = create;
      })(InvokeCopyPasteAction || (exports.InvokeCopyPasteAction = InvokeCopyPasteAction = {}));
      var InvokeCopyPasteActionHandler = class InvokeCopyPasteActionHandler {
        handle(action) {
          switch (action.command) {
            case "copy":
              if (supportsCopy()) {
                document.execCommand("copy");
              } else {
                this.notifyUserToUseShortcut("copy");
              }
              break;
            case "paste":
              if (supportsPaste()) {
                document.execCommand("paste");
              } else {
                this.notifyUserToUseShortcut("paste");
              }
              break;
            case "cut":
              if (supportsCut()) {
                document.execCommand("cut");
              } else {
                this.notifyUserToUseShortcut("cut");
              }
              break;
          }
        }
        notifyUserToUseShortcut(operation) {
          const message = `Please use the browser's ${operation} command or shortcut.`;
          const timeout = 1e4;
          const severity = "WARNING";
          this.dispatcher.dispatchAll([sprotty_1.StatusAction.create(message, { severity, timeout }), sprotty_1.MessageAction.create(message, { severity })]);
        }
      };
      exports.InvokeCopyPasteActionHandler = InvokeCopyPasteActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], InvokeCopyPasteActionHandler.prototype, "dispatcher", void 0);
      exports.InvokeCopyPasteActionHandler = InvokeCopyPasteActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], InvokeCopyPasteActionHandler);
      var CopyPasteContextMenuItemProvider = class CopyPasteContextMenuItemProvider {
        getItems(root, _lastMousePosition) {
          const hasSelectedElements = Array.from(root.index.all().filter(sprotty_1.isSelected)).length > 0;
          return Promise.resolve([
            this.createCopyMenuItem(hasSelectedElements),
            this.createCutMenuItem(hasSelectedElements),
            this.createPasteMenuItem()
          ]);
        }
        createPasteMenuItem() {
          return {
            id: "paste",
            label: "Paste",
            group: "copy-paste",
            actions: [InvokeCopyPasteAction.create("paste")],
            isEnabled: () => true
          };
        }
        createCutMenuItem(hasSelectedElements) {
          return {
            id: "cut",
            label: "Cut",
            group: "copy-paste",
            actions: [InvokeCopyPasteAction.create("cut")],
            isEnabled: () => hasSelectedElements
          };
        }
        createCopyMenuItem(hasSelectedElements) {
          return {
            id: "copy",
            label: "Copy",
            group: "copy-paste",
            actions: [InvokeCopyPasteAction.create("copy")],
            isEnabled: () => hasSelectedElements
          };
        }
      };
      exports.CopyPasteContextMenuItemProvider = CopyPasteContextMenuItemProvider;
      exports.CopyPasteContextMenuItemProvider = CopyPasteContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], CopyPasteContextMenuItemProvider);
      function supportsCopy() {
        return isNative() || document.queryCommandSupported("copy");
      }
      exports.supportsCopy = supportsCopy;
      function supportsCut() {
        return isNative() || document.queryCommandSupported("cut");
      }
      exports.supportsCut = supportsCut;
      function supportsPaste() {
        const isChrome = userAgent().indexOf("Chrome") >= 0;
        return isNative() || !isChrome && document.queryCommandSupported("paste");
      }
      exports.supportsPaste = supportsPaste;
      function isNative() {
        return typeof window.process !== "undefined";
      }
      exports.isNative = isNative;
      function userAgent() {
        return typeof navigator !== "undefined" ? navigator.userAgent : "";
      }
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-handler.js
  var require_copy_paste_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerCopyPasteHandler = exports.LocalClipboardService = void 0;
      var inversify_1 = require_inversify();
      var uuid_1 = require_dist();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var editor_context_service_1 = require_editor_context_service();
      var LocalClipboardService = class LocalClipboardService {
        clear() {
          this.currentId = void 0;
          this.data = void 0;
        }
        put(data, id) {
          this.currentId = id;
          this.data = data;
        }
        get(id) {
          if (id !== this.currentId) {
            return void 0;
          }
          return this.data;
        }
      };
      exports.LocalClipboardService = LocalClipboardService;
      exports.LocalClipboardService = LocalClipboardService = __decorate([
        (0, inversify_1.injectable)()
      ], LocalClipboardService);
      function toClipboardId(clipboardId) {
        return JSON.stringify({ clipboardId });
      }
      function isClipboardId(jsonData) {
        return jsonData !== void 0 && "clipboardId" in jsonData;
      }
      function getClipboardIdFromDataTransfer(dataTransfer) {
        const jsonString = dataTransfer.getData(CLIPBOARD_DATA_FORMAT);
        const jsonObject = jsonString ? JSON.parse(jsonString) : void 0;
        return isClipboardId(jsonObject) ? jsonObject.clipboardId : void 0;
      }
      var CLIPBOARD_DATA_FORMAT = "text/plain";
      var ServerCopyPasteHandler = class ServerCopyPasteHandler {
        handleCopy(event) {
          if (event.clipboardData && this.shouldCopy(event)) {
            const clipboardId = (0, uuid_1.v4)();
            event.clipboardData.setData(CLIPBOARD_DATA_FORMAT, toClipboardId(clipboardId));
            this.actionDispatcher.request(sprotty_1.RequestClipboardDataAction.create(this.editorContext.get())).then((action) => this.clipboardService.put(action.clipboardData, clipboardId));
            event.preventDefault();
          } else {
            if (event.clipboardData) {
              event.clipboardData.clearData();
            }
            this.clipboardService.clear();
          }
        }
        handleCut(event) {
          if (event.clipboardData && this.shouldCopy(event)) {
            this.handleCopy(event);
            this.actionDispatcher.dispatch(sprotty_1.CutOperation.create(this.editorContext.get()));
            event.preventDefault();
          }
        }
        handlePaste(event) {
          if (event.clipboardData && this.shouldPaste(event)) {
            const clipboardId = getClipboardIdFromDataTransfer(event.clipboardData);
            const clipboardData = this.clipboardService.get(clipboardId);
            if (clipboardData) {
              this.actionDispatcher.dispatch(sprotty_1.PasteOperation.create({ clipboardData, editorContext: this.editorContext.get() }));
            }
            event.preventDefault();
          }
        }
        shouldCopy(_event) {
          return this.editorContext.get().selectedElementIds.length > 0 && this.isDiagramActive();
        }
        shouldPaste(_event) {
          return this.isDiagramActive();
        }
        isDiagramActive() {
          var _a, _b;
          return ((_b = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.id) === this.viewerOptions.baseDiv;
        }
      };
      exports.ServerCopyPasteHandler = ServerCopyPasteHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], ServerCopyPasteHandler.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ServerCopyPasteHandler.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IAsyncClipboardService),
        __metadata("design:type", Object)
      ], ServerCopyPasteHandler.prototype, "clipboardService", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ServerCopyPasteHandler.prototype, "editorContext", void 0);
      exports.ServerCopyPasteHandler = ServerCopyPasteHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ServerCopyPasteHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/decoration/decoration-placer.js
  var require_decoration_placer2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/decoration/decoration-placer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var GlspDecorationPlacer_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GlspDecorationPlacer = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var GlspDecorationPlacer = GlspDecorationPlacer_1 = class GlspDecorationPlacer extends sprotty_1.DecorationPlacer {
        getPosition(element) {
          if (element instanceof sprotty_1.GChildElement && element.parent instanceof sprotty_1.GRoutableElement) {
            return super.getPosition(element);
          }
          if ((0, sprotty_1.isSizeable)(element)) {
            return {
              x: GlspDecorationPlacer_1.DECORATION_OFFSET.x * element.bounds.width,
              y: GlspDecorationPlacer_1.DECORATION_OFFSET.y * element.bounds.height
            };
          }
          return sprotty_1.Point.ORIGIN;
        }
      };
      exports.GlspDecorationPlacer = GlspDecorationPlacer;
      GlspDecorationPlacer.DECORATION_OFFSET = { x: 12, y: 10 };
      exports.GlspDecorationPlacer = GlspDecorationPlacer = GlspDecorationPlacer_1 = __decorate([
        (0, inversify_1.injectable)()
      ], GlspDecorationPlacer);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/export/glsp-svg-exporter.js
  var require_glsp_svg_exporter = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/export/glsp-svg-exporter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPSvgExporter = void 0;
      var inversify_1 = require_inversify();
      var uuid_1 = require_dist();
      var sprotty_1 = require_lib5();
      var GLSPSvgExporter = class GLSPSvgExporter extends sprotty_1.SvgExporter {
        export(root, _request) {
          if (typeof document !== "undefined") {
            const svgElement = this.findSvgElement();
            if (svgElement) {
              const originalId = svgElement.id;
              try {
                svgElement.id = originalId || (0, uuid_1.v4)();
                const bounds = this.getBounds(root);
                const svg3 = this.createSvg(svgElement, root).replace('style="', `style="width: ${bounds.width}px !important;height: ${bounds.height}px !important;border: none !important;`);
                this.actionDispatcher.dispatch(sprotty_1.ExportSvgAction.create(svg3));
              } finally {
                svgElement.id = originalId;
              }
            }
          }
        }
        findSvgElement() {
          const div = document.getElementById(this.options.hiddenDiv);
          return div && div.querySelector("svg");
        }
      };
      exports.GLSPSvgExporter = GLSPSvgExporter;
      exports.GLSPSvgExporter = GLSPSvgExporter = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPSvgExporter);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/reconnect/model.js
  var require_model23 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/reconnect/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GReconnectHandle = exports.createReconnectHandle = exports.isTargetRoutingHandle = exports.isSourceRoutingHandle = exports.removeReconnectHandles = exports.addReconnectHandles = exports.isReconnectHandle = exports.isReconnectable = exports.reconnectFeature = void 0;
      var sprotty_1 = require_lib5();
      exports.reconnectFeature = Symbol("reconnectFeature");
      function isReconnectable(element) {
        return element instanceof sprotty_1.GRoutableElement && element.hasFeature(exports.reconnectFeature);
      }
      exports.isReconnectable = isReconnectable;
      var ROUTING_HANDLE_SOURCE_INDEX = -2;
      function isReconnectHandle(element) {
        return element !== void 0 && element instanceof GReconnectHandle;
      }
      exports.isReconnectHandle = isReconnectHandle;
      function addReconnectHandles(element) {
        removeReconnectHandles(element);
        createReconnectHandle(element, "source", ROUTING_HANDLE_SOURCE_INDEX);
        createReconnectHandle(element, "target", element.routingPoints.length);
      }
      exports.addReconnectHandles = addReconnectHandles;
      function removeReconnectHandles(element) {
        element.removeAll((child) => child instanceof GReconnectHandle);
      }
      exports.removeReconnectHandles = removeReconnectHandles;
      function isSourceRoutingHandle(edge, routingHandle) {
        return routingHandle.pointIndex === ROUTING_HANDLE_SOURCE_INDEX;
      }
      exports.isSourceRoutingHandle = isSourceRoutingHandle;
      function isTargetRoutingHandle(edge, routingHandle) {
        return routingHandle.pointIndex === edge.routingPoints.length;
      }
      exports.isTargetRoutingHandle = isTargetRoutingHandle;
      function createReconnectHandle(edge, kind, routingPointIndex) {
        const handle = new GReconnectHandle();
        handle.kind = kind;
        handle.pointIndex = routingPointIndex;
        handle.type = "routing-point";
        if (kind === "target" && edge.id === sprotty_1.edgeInProgressID) {
          handle.id = sprotty_1.edgeInProgressTargetHandleID;
        }
        edge.add(handle);
        return handle;
      }
      exports.createReconnectHandle = createReconnectHandle;
      var GReconnectHandle = class extends sprotty_1.GRoutingHandle {
        hasFeature(feature) {
          return feature !== sprotty_1.selectFeature && super.hasFeature(feature);
        }
      };
      exports.GReconnectHandle = GReconnectHandle;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hints/type-hint-provider.js
  var require_type_hint_provider = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hints/type-hint-provider.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeHintProvider = exports.ApplyTypeHintsCommand = exports.ApplyTypeHintsAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model22();
      var model_2 = require_model23();
      var model_3 = require_model20();
      var model_4 = require_model21();
      var ApplyTypeHintsAction;
      (function(ApplyTypeHintsAction2) {
        ApplyTypeHintsAction2.KIND = "applyTypeHints";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ApplyTypeHintsAction2.KIND);
        }
        ApplyTypeHintsAction2.is = is;
        function create() {
          return { kind: ApplyTypeHintsAction2.KIND };
        }
        ApplyTypeHintsAction2.create = create;
      })(ApplyTypeHintsAction || (exports.ApplyTypeHintsAction = ApplyTypeHintsAction = {}));
      var ApplyTypeHintsCommand = class ApplyTypeHintsCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
          this.priority = 10;
        }
        execute(context) {
          context.root.index.all().forEach((element) => {
            if (element instanceof sprotty_1.GShapeElement || element instanceof sprotty_1.GModelRoot) {
              return this.applyShapeTypeHint(element);
            }
            if (element instanceof model_4.GEdge) {
              this.applyEdgeTypeHint(element);
            }
          });
          return context.root;
        }
        applyEdgeTypeHint(element) {
          const hint = this.typeHintProvider.getEdgeTypeHint(element);
          if (hint && element.features instanceof Set) {
            addOrRemove(element.features, sprotty_1.deletableFeature, hint.deletable);
            addOrRemove(element.features, sprotty_1.editFeature, hint.routable);
            addOrRemove(element.features, model_2.reconnectFeature, hint.repositionable);
          }
        }
        applyShapeTypeHint(element) {
          const hint = this.typeHintProvider.getShapeTypeHint(element);
          if (hint && element.features instanceof Set) {
            addOrRemove(element.features, sprotty_1.deletableFeature, hint.deletable);
            addOrRemove(element.features, sprotty_1.moveFeature, hint.repositionable);
            addOrRemove(element.features, model_1.resizeFeature, hint.resizable);
            addOrRemove(element.features, model_3.reparentFeature, hint.reparentable);
            addOrRemove(element.features, model_3.containerFeature, true);
            if ((0, model_3.isContainable)(element)) {
              element.isContainableElement = (input) => this.isContainableElement(input, hint);
            }
            const fallbackCanConnect = (0, sprotty_1.isConnectable)(element) ? element.canConnect.bind(element) : void 0;
            addOrRemove(element.features, sprotty_1.connectableFeature, true);
            if ((0, sprotty_1.isConnectable)(element)) {
              element.canConnect = (routable, role) => this.canConnect(routable, role, element, fallbackCanConnect);
            }
          }
        }
        /**
         * Type hints aware wrapper function for  `Connectable.canConnect`. After type hints have been applied
         * the `canConnect` implementation of `connectable` model elements  (with a matching hint) will forward to this method.
         */
        canConnect(routable, role, element, fallbackCanConnect) {
          var _a;
          const edgeHint = this.typeHintProvider.getEdgeTypeHint(routable.type);
          if (!edgeHint) {
            return (_a = fallbackCanConnect === null || fallbackCanConnect === void 0 ? void 0 : fallbackCanConnect(routable, role)) !== null && _a !== void 0 ? _a : false;
          }
          const validElementIds = role === "source" ? edgeHint.sourceElementTypeIds : edgeHint.targetElementTypeIds;
          if (!validElementIds) {
            return true;
          }
          const elementType = element.type + ":";
          return validElementIds.some((type) => elementType.startsWith(type));
        }
        /**
         * Type hints aware wrapper function for  `Containable.isContainableElement`. After type hints have been applied
         * the `isContainableElement` implementation of `containable` model elements (with a matching hint) will forward to this method.
         */
        isContainableElement(input, hint) {
          var _a, _b;
          const elemenType = (0, gmodel_util_1.getElementTypeId)(input) + ":";
          return (_b = (_a = hint.containableElementTypeIds) === null || _a === void 0 ? void 0 : _a.some((type) => elemenType.startsWith(type))) !== null && _b !== void 0 ? _b : false;
        }
      };
      exports.ApplyTypeHintsCommand = ApplyTypeHintsCommand;
      ApplyTypeHintsCommand.KIND = ApplyTypeHintsAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ITypeHintProvider),
        __metadata("design:type", Object)
      ], ApplyTypeHintsCommand.prototype, "typeHintProvider", void 0);
      exports.ApplyTypeHintsCommand = ApplyTypeHintsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ApplyTypeHintsCommand);
      function addOrRemove(features, feature, add) {
        if (add && !features.has(feature)) {
          features.add(feature);
        } else if (!add && features.has(feature)) {
          features.delete(feature);
        }
      }
      var TypeHintProvider = class TypeHintProvider {
        constructor() {
          this.shapeHints = /* @__PURE__ */ new Map();
          this.edgeHints = /* @__PURE__ */ new Map();
        }
        handle(action) {
          this.shapeHints.clear();
          this.edgeHints.clear();
          action.shapeHints.forEach((hint) => this.shapeHints.set(hint.elementTypeId, hint));
          action.edgeHints.forEach((hint) => this.edgeHints.set(hint.elementTypeId, hint));
          this.feedbackActionDispatcher.registerFeedback(this, [ApplyTypeHintsAction.create()]);
        }
        getShapeTypeHint(input) {
          return this.getTypeHint(input, this.shapeHints);
        }
        getEdgeTypeHint(input) {
          return this.getTypeHint(input, this.edgeHints);
        }
        getTypeHint(input, hints) {
          const type = (0, gmodel_util_1.getElementTypeId)(input);
          let hint = hints.get(type);
          if (hint === void 0) {
            const subtypes = type.split(":");
            while (hint === void 0 && subtypes.length > 0) {
              subtypes.pop();
              hint = hints.get(subtypes.join(":"));
              if (hint) {
                hints.set(type, hint);
                break;
              }
            }
          }
          return hint;
        }
        async postRequestModel() {
          const setTypeHintsAction = await this.actionDispatcher.request(sprotty_1.RequestTypeHintsAction.create());
          this.handle(setTypeHintsAction);
        }
      };
      exports.TypeHintProvider = TypeHintProvider;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], TypeHintProvider.prototype, "feedbackActionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(action_dispatcher_1.GLSPActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], TypeHintProvider.prototype, "actionDispatcher", void 0);
      exports.TypeHintProvider = TypeHintProvider = __decorate([
        (0, inversify_1.injectable)()
      ], TypeHintProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/view.js
  var require_view2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackEdgeEndView = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var JSX = { createElement: sprotty_1.svg };
      var FeedbackEdgeEndView2 = class FeedbackEdgeEndView {
        render(model, context) {
          var _a;
          const position = (_a = model.position) !== null && _a !== void 0 ? _a : sprotty_1.Point.ORIGIN;
          return JSX.createElement("g", { x: position.x, y: position.y });
        }
      };
      exports.FeedbackEdgeEndView = FeedbackEdgeEndView2;
      exports.FeedbackEdgeEndView = FeedbackEdgeEndView2 = __decorate([
        (0, inversify_1.injectable)()
      ], FeedbackEdgeEndView2);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/dangling-edge-feedback.js
  var require_dangling_edge_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/dangling-edge-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureDanglingFeedbackEdge = exports.removeDanglingFeedbackEdge = exports.drawFeedbackEdge = exports.defaultFeedbackEdgeSchema = exports.feedbackEdgeEndId = exports.feedbackEdgeId = exports.FeedbackEdgeEnd = exports.RemoveFeedbackEdgeCommand = exports.RemoveFeedbackEdgeAction = exports.DrawFeedbackEdgeCommand = exports.DrawFeedbackEdgeAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var viewpoint_util_1 = require_viewpoint_util();
      var view_1 = require_view2();
      var DrawFeedbackEdgeAction2;
      (function(DrawFeedbackEdgeAction3) {
        DrawFeedbackEdgeAction3.KIND = "drawFeedbackEdge";
        function is(object) {
          return sprotty_1.Action.hasKind(object, DrawFeedbackEdgeAction3.KIND);
        }
        DrawFeedbackEdgeAction3.is = is;
        function create(options) {
          return Object.assign({ kind: DrawFeedbackEdgeAction3.KIND }, options);
        }
        DrawFeedbackEdgeAction3.create = create;
      })(DrawFeedbackEdgeAction2 || (exports.DrawFeedbackEdgeAction = DrawFeedbackEdgeAction2 = {}));
      var DrawFeedbackEdgeCommand2 = class DrawFeedbackEdgeCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          drawFeedbackEdge2(context, this.action.sourceId, this.action.elementTypeId, this.action.edgeSchema);
          return context.root;
        }
      };
      exports.DrawFeedbackEdgeCommand = DrawFeedbackEdgeCommand2;
      DrawFeedbackEdgeCommand2.KIND = DrawFeedbackEdgeAction2.KIND;
      exports.DrawFeedbackEdgeCommand = DrawFeedbackEdgeCommand2 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DrawFeedbackEdgeCommand2);
      var RemoveFeedbackEdgeAction2;
      (function(RemoveFeedbackEdgeAction3) {
        RemoveFeedbackEdgeAction3.KIND = "removeFeedbackEdgeCommand";
        function is(object) {
          return sprotty_1.Action.hasKind(object, RemoveFeedbackEdgeAction3.KIND);
        }
        RemoveFeedbackEdgeAction3.is = is;
        function create() {
          return { kind: RemoveFeedbackEdgeAction3.KIND };
        }
        RemoveFeedbackEdgeAction3.create = create;
      })(RemoveFeedbackEdgeAction2 || (exports.RemoveFeedbackEdgeAction = RemoveFeedbackEdgeAction2 = {}));
      var RemoveFeedbackEdgeCommand2 = class RemoveFeedbackEdgeCommand extends feedback_command_1.FeedbackCommand {
        execute(context) {
          removeDanglingFeedbackEdge2(context.root);
          return context.root;
        }
      };
      exports.RemoveFeedbackEdgeCommand = RemoveFeedbackEdgeCommand2;
      RemoveFeedbackEdgeCommand2.KIND = RemoveFeedbackEdgeAction2.KIND;
      exports.RemoveFeedbackEdgeCommand = RemoveFeedbackEdgeCommand2 = __decorate([
        (0, inversify_1.injectable)()
      ], RemoveFeedbackEdgeCommand2);
      var FeedbackEdgeEnd2 = class extends sprotty_1.GDanglingAnchor {
        constructor(sourceId, elementTypeId, feedbackEdge = void 0, type = FeedbackEdgeEnd2.TYPE) {
          super();
          this.sourceId = sourceId;
          this.elementTypeId = elementTypeId;
          this.feedbackEdge = feedbackEdge;
          this.type = type;
        }
      };
      exports.FeedbackEdgeEnd = FeedbackEdgeEnd2;
      FeedbackEdgeEnd2.TYPE = "feedback-edge-end";
      function feedbackEdgeId2(root) {
        return root.id + "_feedback_edge";
      }
      exports.feedbackEdgeId = feedbackEdgeId2;
      function feedbackEdgeEndId2(root) {
        return root.id + "_feedback_anchor";
      }
      exports.feedbackEdgeEndId = feedbackEdgeEndId2;
      exports.defaultFeedbackEdgeSchema = {
        cssClasses: ["feedback-edge"],
        opacity: 0.3
      };
      function drawFeedbackEdge2(context, sourceId, elementTypeId, edgeTemplate) {
        const root = context.root;
        const sourceChild = root.index.getById(sourceId);
        if (!sourceChild) {
          return;
        }
        const source = (0, sprotty_1.findParentByFeature)(sourceChild, sprotty_1.isConnectable);
        if (!source || !(0, sprotty_1.isBoundsAware)(source)) {
          return;
        }
        const edgeEnd = new FeedbackEdgeEnd2(source.id, elementTypeId);
        edgeEnd.id = feedbackEdgeEndId2(root);
        edgeEnd.position = (0, viewpoint_util_1.toAbsolutePosition)(source);
        const edgeSchema = Object.assign(Object.assign({ id: feedbackEdgeId2(root), type: elementTypeId, sourceId: source.id, targetId: edgeEnd.id }, exports.defaultFeedbackEdgeSchema), edgeTemplate);
        const feedbackEdge = context.modelFactory.createElement(edgeSchema);
        if ((0, gmodel_util_1.isRoutable)(feedbackEdge)) {
          edgeEnd.feedbackEdge = feedbackEdge;
          root.add(edgeEnd);
          root.add(feedbackEdge);
        }
      }
      exports.drawFeedbackEdge = drawFeedbackEdge2;
      function removeDanglingFeedbackEdge2(root) {
        const feedbackEdge = root.index.getById(feedbackEdgeId2(root));
        const feedbackEdgeEnd = root.index.getById(feedbackEdgeEndId2(root));
        if (feedbackEdge instanceof sprotty_1.GChildElement) {
          root.remove(feedbackEdge);
        }
        if (feedbackEdgeEnd instanceof sprotty_1.GChildElement) {
          root.remove(feedbackEdgeEnd);
        }
      }
      exports.removeDanglingFeedbackEdge = removeDanglingFeedbackEdge2;
      function configureDanglingFeedbackEdge2(context) {
        if (!context.isBound(DrawFeedbackEdgeCommand2) && !context.isBound(RemoveFeedbackEdgeCommand2) && !context.isBound(view_1.FeedbackEdgeEndView)) {
          (0, sprotty_1.configureCommand)(context, DrawFeedbackEdgeCommand2);
          (0, sprotty_1.configureCommand)(context, RemoveFeedbackEdgeCommand2);
          (0, sprotty_1.configureView)(context, FeedbackEdgeEnd2.TYPE, view_1.FeedbackEdgeEndView);
        }
      }
      exports.configureDanglingFeedbackEdge = configureDanglingFeedbackEdge2;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edge-creation-tool-feedback.js
  var require_edge_creation_tool_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edge-creation-tool-feedback.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackEdgeEndMovingMouseListener = void 0;
      var sprotty_1 = require_lib5();
      var viewpoint_util_1 = require_viewpoint_util();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var FeedbackEdgeEndMovingMouseListener = class extends sprotty_1.MouseListener {
        constructor(anchorRegistry, feedbackDispatcher) {
          super();
          this.anchorRegistry = anchorRegistry;
          this.feedbackDispatcher = feedbackDispatcher;
        }
        mouseMove(target, event) {
          const root = target.root;
          const edgeEnd = root.index.getById((0, dangling_edge_feedback_1.feedbackEdgeEndId)(root));
          if (!(edgeEnd instanceof dangling_edge_feedback_1.FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
            return [];
          }
          const edge = edgeEnd.feedbackEdge;
          const position = (0, viewpoint_util_1.getAbsolutePosition)(edgeEnd, event);
          const endAtMousePosition = (0, sprotty_1.findChildrenAtPosition)(target.root, position).reverse().find((element) => (0, sprotty_1.isConnectable)(element) && element.canConnect(edge, "target"));
          if (endAtMousePosition instanceof sprotty_1.GConnectableElement && edge.source && (0, sprotty_1.isBoundsAware)(edge.source)) {
            const anchor = this.computeAbsoluteAnchor(endAtMousePosition, sprotty_1.Bounds.center((0, viewpoint_util_1.toAbsoluteBounds)(edge.source)));
            if (sprotty_1.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
              this.feedbackDispatcher.registerFeedback(this, [
                sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], { animate: false })
              ]);
            }
          } else {
            this.feedbackDispatcher.registerFeedback(this, [
              sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], { animate: false })
            ]);
          }
          return [];
        }
        computeAbsoluteAnchor(element, absoluteReferencePoint, offset) {
          const referencePointInParent = (0, viewpoint_util_1.absoluteToParent)(element, absoluteReferencePoint);
          const anchorComputer = this.anchorRegistry.get(sprotty_1.PolylineEdgeRouter.KIND, element.anchorKind);
          let anchor = anchorComputer.getAnchor(element, referencePointInParent, offset);
          if (element.parent !== element.root) {
            const parent = (0, sprotty_1.findParentByFeature)(element.parent, sprotty_1.isBoundsAware);
            if (parent) {
              const absoluteParentPosition = (0, viewpoint_util_1.toAbsoluteBounds)(parent);
              anchor = sprotty_1.Point.add(absoluteParentPosition, anchor);
            }
          }
          return anchor;
        }
        dispose() {
          this.feedbackDispatcher.deregisterFeedback(this);
        }
      };
      exports.FeedbackEdgeEndMovingMouseListener = FeedbackEdgeEndMovingMouseListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edge-creation-tool.js
  var require_edge_creation_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edge-creation-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var EdgeCreationTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeCreationToolMouseListener = exports.EdgeCreationTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var base_tools_1 = require_base_tools();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_creation_tool_feedback_1 = require_edge_creation_tool_feedback();
      var model_1 = require_model21();
      var EdgeCreationTool = EdgeCreationTool_1 = class EdgeCreationTool extends base_tools_1.BaseCreationTool {
        constructor() {
          super(...arguments);
          this.isTriggerAction = sprotty_1.TriggerEdgeCreationAction.is;
        }
        get id() {
          return EdgeCreationTool_1.ID;
        }
        doEnable() {
          const mouseMovingFeedback = new edge_creation_tool_feedback_1.FeedbackEdgeEndMovingMouseListener(this.anchorRegistry, this.feedbackDispatcher);
          this.toDisposeOnDisable.push(mouseMovingFeedback, this.mouseTool.registerListener(new EdgeCreationToolMouseListener(this.triggerAction, this.actionDispatcher, this.typeHintProvider, this)), this.mouseTool.registerListener(mouseMovingFeedback), this.registerFeedback([(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED)], this, [
            dangling_edge_feedback_1.RemoveFeedbackEdgeAction.create(),
            (0, css_feedback_1.cursorFeedbackAction)()
          ]));
        }
      };
      exports.EdgeCreationTool = EdgeCreationTool;
      EdgeCreationTool.ID = "tool_create_edge";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.AnchorComputerRegistry),
        __metadata("design:type", sprotty_1.AnchorComputerRegistry)
      ], EdgeCreationTool.prototype, "anchorRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ITypeHintProvider),
        __metadata("design:type", Object)
      ], EdgeCreationTool.prototype, "typeHintProvider", void 0);
      exports.EdgeCreationTool = EdgeCreationTool = EdgeCreationTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeCreationTool);
      var EdgeCreationToolMouseListener = class EdgeCreationToolMouseListener extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(triggerAction, actionDispatcher, typeHintProvider, tool) {
          super();
          this.triggerAction = triggerAction;
          this.actionDispatcher = actionDispatcher;
          this.typeHintProvider = typeHintProvider;
          this.tool = tool;
          this.allowedTarget = false;
          this.pendingDynamicCheck = false;
          this.proxyEdge = new model_1.GEdge();
          this.proxyEdge.type = triggerAction.elementTypeId;
        }
        reinitialize() {
          this.source = void 0;
          this.target = void 0;
          this.currentTarget = void 0;
          this.allowedTarget = false;
          this.tool.registerFeedback([dangling_edge_feedback_1.RemoveFeedbackEdgeAction.create()]);
        }
        nonDraggingMouseUp(_element, event) {
          const result = [];
          if (event.button === 0) {
            if (!this.isSourceSelected()) {
              if (this.currentTarget && this.allowedTarget) {
                this.source = this.currentTarget.id;
                this.tool.registerFeedback([
                  dangling_edge_feedback_1.DrawFeedbackEdgeAction.create({ elementTypeId: this.triggerAction.elementTypeId, sourceId: this.source })
                ]);
              }
            } else if (this.currentTarget && this.allowedTarget) {
              this.target = this.currentTarget.id;
            }
            if (this.source && this.target) {
              result.push(sprotty_1.CreateEdgeOperation.create({
                elementTypeId: this.triggerAction.elementTypeId,
                sourceElementId: this.source,
                targetElementId: this.target,
                args: this.triggerAction.args
              }));
              if (!(0, sprotty_1.isCtrlOrCmd)(event)) {
                result.push(tool_1.EnableDefaultToolsAction.create());
              } else {
                this.reinitialize();
              }
            }
          } else if (event.button === 2) {
            this.reinitialize();
            result.push(tool_1.EnableDefaultToolsAction.create());
          }
          return result;
        }
        isSourceSelected() {
          return this.source !== void 0;
        }
        isTargetSelected() {
          return this.target !== void 0;
        }
        mouseOver(target, event) {
          const newCurrentTarget = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isConnectable);
          if (newCurrentTarget !== this.currentTarget) {
            this.pendingDynamicCheck = false;
            this.currentTarget = newCurrentTarget;
            if (this.currentTarget) {
              if (!this.isSourceSelected()) {
                this.allowedTarget = this.canConnect(newCurrentTarget, "source");
              } else if (!this.isTargetSelected()) {
                this.allowedTarget = this.canConnect(newCurrentTarget, "target");
              }
              if (this.pendingDynamicCheck) {
                return [(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_CHECK_PENDING)];
              }
            } else {
              this.allowedTarget = false;
            }
            return [this.updateEdgeFeedback()];
          }
          return [];
        }
        updateEdgeFeedback() {
          if (this.allowedTarget) {
            const action = !this.isSourceSelected() ? (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_CREATION_SOURCE) : (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_CREATION_TARGET);
            return action;
          }
          return (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED);
        }
        canConnect(element, role) {
          var _a;
          if (!element || !(0, sprotty_1.isConnectable)(element) || !element.canConnect(this.proxyEdge, role)) {
            return false;
          }
          if (!this.isDynamic(this.proxyEdge.type)) {
            return true;
          }
          const sourceElement = (_a = this.source) !== null && _a !== void 0 ? _a : element;
          const targetElement = this.source ? element : void 0;
          this.pendingDynamicCheck = true;
          this.actionDispatcher.request(sprotty_1.RequestCheckEdgeAction.create({ sourceElement, targetElement, edgeType: this.proxyEdge.type })).then((result) => {
            if (this.pendingDynamicCheck) {
              this.allowedTarget = result.isValid;
              this.actionDispatcher.dispatch(this.updateEdgeFeedback());
              this.pendingDynamicCheck = false;
            }
          }).catch((err) => console.error("Dynamic edge check failed with: ", err));
          return false;
        }
        isDynamic(edgeTypeId) {
          var _a;
          const typeHint = this.typeHintProvider.getEdgeTypeHint(edgeTypeId);
          return (_a = typeHint === null || typeHint === void 0 ? void 0 : typeHint.dynamic) !== null && _a !== void 0 ? _a : false;
        }
      };
      exports.EdgeCreationToolMouseListener = EdgeCreationToolMouseListener;
      exports.EdgeCreationToolMouseListener = EdgeCreationToolMouseListener = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [Object, action_dispatcher_1.GLSPActionDispatcher, Object, EdgeCreationTool])
      ], EdgeCreationToolMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/validation/issue-marker.js
  var require_issue_marker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/validation/issue-marker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSeverity = exports.createGIssue = exports.getGIssueMarker = exports.getOrCreateGIssueMarker = exports.GIssueMarker = void 0;
      var sprotty_1 = require_lib5();
      var GIssueMarker = class extends sprotty_1.SIssueMarker {
        constructor() {
          super();
          this.issues = [];
          this.type = "marker";
          this.features = new Set(sprotty_1.GDecoration.DEFAULT_FEATURES);
        }
        computeProjectionCssClasses() {
          const severityCss = getSeverity(this);
          this.projectionCssClasses = ["sprotty-issue", "sprotty-" + severityCss];
        }
      };
      exports.GIssueMarker = GIssueMarker;
      function getOrCreateGIssueMarker(modelElement) {
        let issueMarker;
        issueMarker = getGIssueMarker(modelElement);
        if (issueMarker === void 0) {
          issueMarker = new GIssueMarker();
          if ((0, sprotty_1.isBoundsAware)(modelElement)) {
            issueMarker.projectedBounds = modelElement.parentToLocal(modelElement.bounds);
          }
          modelElement.add(issueMarker);
        }
        return issueMarker;
      }
      exports.getOrCreateGIssueMarker = getOrCreateGIssueMarker;
      function getGIssueMarker(modelElement) {
        let issueMarker;
        for (const child of modelElement.children) {
          if (child instanceof GIssueMarker) {
            issueMarker = child;
          }
        }
        return issueMarker;
      }
      exports.getGIssueMarker = getGIssueMarker;
      function createGIssue(marker, parent) {
        const issue = new sprotty_1.GIssue();
        issue.message = marker.description;
        switch (marker.kind) {
          case sprotty_1.MarkerKind.ERROR: {
            issue.severity = "error";
            break;
          }
          case sprotty_1.MarkerKind.INFO: {
            issue.severity = "info";
            break;
          }
          case sprotty_1.MarkerKind.WARNING: {
            issue.severity = "warning";
            break;
          }
        }
        return issue;
      }
      exports.createGIssue = createGIssue;
      function getSeverity(marker) {
        let currentSeverity = "info";
        for (const severity of marker.issues.map((s) => s.severity)) {
          if (severity === "error") {
            return severity;
          }
          if (severity === "warning" && currentSeverity === "info") {
            currentSeverity = severity;
          }
        }
        return currentSeverity;
      }
      exports.getSeverity = getSeverity;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hover/hover.js
  var require_hover2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hover/hover.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GlspHoverMouseListener = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var tool_1 = require_tool();
      var edge_creation_tool_1 = require_edge_creation_tool();
      var issue_marker_1 = require_issue_marker();
      var GlspHoverMouseListener = class GlspHoverMouseListener extends sprotty_1.HoverMouseListener {
        constructor() {
          super(...arguments);
          this.enableHover = true;
        }
        /**
         * Stops mouse over timer and remove hover feedback, if focus is lost.
         *
         * This fixes strange effects that appear if the mouse left the element via e.g. a context menu,
         * which explicitly removes the focus of the diagram.
         * @see SelectionServiceAwareContextMenuMouseListener
         * @param action should be a `FocusStateChangedAction`
         * @returns a `HoverFeedbackAction` resetting the state, if the specified action indicates lost focus
         */
        handle(action) {
          if (focus_state_change_action_1.FocusStateChangedAction.is(action) && !action.hasFocus) {
            this.stopMouseOverTimer();
            if (this.lastHoverFeedbackElementId) {
              const previousTargetId = this.lastHoverFeedbackElementId;
              this.lastHoverFeedbackElementId = void 0;
              return sprotty_1.HoverFeedbackAction.create({ mouseoverElement: previousTargetId, mouseIsOver: false });
            }
          } else if (tool_1.EnableToolsAction.is(action)) {
            this.enableHover = !action.toolIds.includes(edge_creation_tool_1.EdgeCreationTool.ID);
          } else if (tool_1.EnableDefaultToolsAction.is(action)) {
            this.enableHover = true;
          }
        }
        mouseOver(target, event) {
          if (this.enableHover) {
            return super.mouseOver(target, event);
          }
          return [];
        }
        startMouseOverTimer(target, event) {
          this.stopMouseOverTimer();
          return new Promise((resolve) => {
            this.state.mouseOverTimer = window.setTimeout(() => {
              const popupBounds = this.computePopupBounds(target, { x: event.pageX, y: event.pageY });
              if (target instanceof issue_marker_1.GIssueMarker) {
                resolve(sprotty_1.SetPopupModelAction.create(this.createPopupModel(target, popupBounds)));
              } else {
                resolve(sprotty_1.RequestPopupModelAction.create({ elementId: target.id, bounds: popupBounds }));
              }
              this.state.popupOpen = true;
              this.state.previousPopupElement = target;
            }, this.options.popupOpenDelay);
          });
        }
        createPopupModel(marker, bounds) {
          if (marker.issues !== void 0 && marker.issues.length > 0) {
            return {
              type: "html",
              id: "sprotty-popup",
              children: [this.createMarkerIssuePopup(marker)],
              canvasBounds: this.modifyBounds(bounds)
            };
          }
          return { type: sprotty_1.EMPTY_ROOT.type, id: sprotty_1.EMPTY_ROOT.id };
        }
        createMarkerIssuePopup(marker) {
          const message = this.createIssueMessage(marker);
          return {
            type: "pre-rendered",
            id: "popup-title",
            code: `<div class="${(0, issue_marker_1.getSeverity)(marker)}"><div class="sprotty-popup-title">${message}</div></div>`
          };
        }
        createIssueMessage(marker) {
          return "<ul>" + marker.issues.map((i) => "<li>" + i.severity.toUpperCase() + ": " + i.message + "</li>").join("") + "</ul>";
        }
        modifyBounds(bounds) {
          return bounds;
        }
      };
      exports.GlspHoverMouseListener = GlspHoverMouseListener;
      exports.GlspHoverMouseListener = GlspHoverMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], GlspHoverMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/label-edit/edit-label-tool.js
  var require_edit_label_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/label-edit/edit-label-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var DirectLabelEditTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DirectLabelEditTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var base_tools_1 = require_base_tools();
      var DirectLabelEditTool = DirectLabelEditTool_1 = class DirectLabelEditTool extends base_tools_1.BaseEditTool {
        get id() {
          return DirectLabelEditTool_1.ID;
        }
        createEditLabelMouseListener() {
          return new sprotty_1.EditLabelMouseListener();
        }
        createEditLabelKeyListener() {
          return new sprotty_1.EditLabelKeyListener();
        }
        enable() {
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(this.createEditLabelMouseListener()), this.keyTool.registerListener(this.createEditLabelKeyListener()));
        }
      };
      exports.DirectLabelEditTool = DirectLabelEditTool;
      DirectLabelEditTool.ID = "glsp.direct-label-edit-tool";
      exports.DirectLabelEditTool = DirectLabelEditTool = DirectLabelEditTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], DirectLabelEditTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/label-edit/edit-label-validator.js
  var require_edit_label_validator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/label-edit/edit-label-validator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BalloonLabelValidationDecorator = exports.ServerEditLabelValidator = exports.LabelEditValidation = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var LabelEditValidation;
      (function(LabelEditValidation2) {
        LabelEditValidation2.CONTEXT_ID = "label-edit";
        function toEditLabelValidationResult(status) {
          const message = status.message;
          let severity = "ok";
          if (sprotty_1.ValidationStatus.isError(status)) {
            severity = "error";
          } else if (sprotty_1.ValidationStatus.isWarning(status)) {
            severity = "warning";
          }
          return { message, severity };
        }
        LabelEditValidation2.toEditLabelValidationResult = toEditLabelValidationResult;
        function createValidationRequestAction(value, labelId) {
          return sprotty_1.RequestEditValidationAction.create({ contextId: LabelEditValidation2.CONTEXT_ID, modelElementId: labelId, text: value });
        }
        LabelEditValidation2.createValidationRequestAction = createValidationRequestAction;
      })(LabelEditValidation || (exports.LabelEditValidation = LabelEditValidation = {}));
      var ServerEditLabelValidator = class ServerEditLabelValidator {
        async validate(value, label) {
          const action = LabelEditValidation.createValidationRequestAction(value, label.id);
          const response = await this.actionDispatcher.requestUntil(action);
          return response ? this.getValidationResultFromResponse(response) : { severity: "ok" };
        }
        getValidationResultFromResponse(action) {
          if (sprotty_1.SetEditValidationResultAction.is(action)) {
            return LabelEditValidation.toEditLabelValidationResult(action.status);
          }
          return { severity: "ok" };
        }
      };
      exports.ServerEditLabelValidator = ServerEditLabelValidator;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], ServerEditLabelValidator.prototype, "actionDispatcher", void 0);
      exports.ServerEditLabelValidator = ServerEditLabelValidator = __decorate([
        (0, inversify_1.injectable)()
      ], ServerEditLabelValidator);
      var BalloonLabelValidationDecorator = class BalloonLabelValidationDecorator {
        decorate(input, result) {
          const containerElement = input.parentElement;
          if (!containerElement) {
            return;
          }
          if (result.message) {
            containerElement.setAttribute("data-balloon", result.message);
            containerElement.setAttribute("data-balloon-pos", "up-left");
            containerElement.setAttribute("data-balloon-visible", "true");
          }
          switch (result.severity) {
            case "ok":
              containerElement.classList.add("validation-ok");
              break;
            case "warning":
              containerElement.classList.add("validation-warning");
              break;
            case "error":
              containerElement.classList.add("validation-error");
              break;
          }
        }
        dispose(input) {
          const containerElement = input.parentElement;
          if (containerElement) {
            containerElement.removeAttribute("data-balloon");
            containerElement.removeAttribute("data-balloon-pos");
            containerElement.removeAttribute("data-balloon-visible");
            containerElement.classList.remove("validation-ok", "validation-warning", "validation-error");
          }
        }
      };
      exports.BalloonLabelValidationDecorator = BalloonLabelValidationDecorator;
      exports.BalloonLabelValidationDecorator = BalloonLabelValidationDecorator = __decorate([
        (0, inversify_1.injectable)()
      ], BalloonLabelValidationDecorator);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/layout/layout-elements-action.js
  var require_layout_elements_action = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/layout/layout-elements-action.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AlignElementsActionHandler = exports.AlignElementsAction = exports.SelectFunction = exports.Alignment = exports.ResizeElementsActionHandler = exports.LayoutElementsActionHandler = exports.ResizeElementsAction = exports.ReduceFunction = exports.ResizeDimension = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var selection_service_1 = require_selection_service();
      var layout_utils_1 = require_layout_utils();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model22();
      var ResizeDimension;
      (function(ResizeDimension2) {
        ResizeDimension2[ResizeDimension2["Width"] = 0] = "Width";
        ResizeDimension2[ResizeDimension2["Height"] = 1] = "Height";
        ResizeDimension2[ResizeDimension2["Width_And_Height"] = 2] = "Width_And_Height";
      })(ResizeDimension || (exports.ResizeDimension = ResizeDimension = {}));
      var ReduceFunction;
      (function(ReduceFunction2) {
        function min(...values) {
          return Math.min(...values);
        }
        ReduceFunction2.min = min;
        function max(...values) {
          return Math.max(...values);
        }
        ReduceFunction2.max = max;
        function avg(...values) {
          return values.reduce((a, b) => a + b, 0) / values.length;
        }
        ReduceFunction2.avg = avg;
        function first(...values) {
          return values[0];
        }
        ReduceFunction2.first = first;
        function last(...values) {
          return values[values.length - 1];
        }
        ReduceFunction2.last = last;
        function get(type) {
          return ReduceFunction2[type];
        }
        ReduceFunction2.get = get;
      })(ReduceFunction || (exports.ReduceFunction = ReduceFunction = {}));
      var ResizeElementsAction;
      (function(ResizeElementsAction2) {
        ResizeElementsAction2.KIND = "resizeElementAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ResizeElementsAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "elementIds") && (0, sprotty_1.hasNumberProp)(object, "dimension") && (0, sprotty_1.hasStringProp)(object, "reduceFunction");
        }
        ResizeElementsAction2.is = is;
        function create(options) {
          return Object.assign({ kind: ResizeElementsAction2.KIND, dimension: ResizeDimension.Width, elementIds: [] }, options);
        }
        ResizeElementsAction2.create = create;
      })(ResizeElementsAction || (exports.ResizeElementsAction = ResizeElementsAction = {}));
      var LayoutElementsActionHandler = class LayoutElementsActionHandler {
        getSelectedElements(selection) {
          const index = this.selectionService.getModelRoot().index;
          const selectedElements = selection.elementIds.length > 0 ? selection.elementIds : this.selectionService.getSelectedElementIDs();
          return (0, gmodel_util_1.getElements)(index, selectedElements, this.isActionElement);
        }
        dispatchAction(action) {
          this.actionDispatcher.dispatch(action);
        }
        dispatchActions(actions) {
          this.actionDispatcher.dispatchAll(actions);
        }
      };
      exports.LayoutElementsActionHandler = LayoutElementsActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], LayoutElementsActionHandler.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], LayoutElementsActionHandler.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], LayoutElementsActionHandler.prototype, "movementRestrictor", void 0);
      exports.LayoutElementsActionHandler = LayoutElementsActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], LayoutElementsActionHandler);
      var ResizeElementsActionHandler = class ResizeElementsActionHandler extends LayoutElementsActionHandler {
        handle(action) {
          const elements = this.getSelectedElements(action);
          if (elements.length > 1) {
            const reduceFn = ReduceFunction.get(action.reduceFunction);
            switch (action.dimension) {
              case ResizeDimension.Width:
                return this.resizeWidth(elements, reduceFn);
              case ResizeDimension.Height:
                return this.resizeHeight(elements, reduceFn);
              case ResizeDimension.Width_And_Height:
                return this.resizeWidthAndHeight(elements, reduceFn);
            }
          }
        }
        resizeWidth(elements, reduceFn) {
          const targetWidth = reduceFn(...elements.map((element) => element.bounds.width));
          this.dispatchResizeActions(elements, (element, bounds) => {
            const halfDiffWidth = 0.5 * (targetWidth - element.bounds.width);
            bounds.newPosition.x = element.bounds.x - halfDiffWidth;
            bounds.newSize.width = targetWidth;
          });
        }
        resizeHeight(elements, reduceFn) {
          const targetHeight = reduceFn(...elements.map((element) => element.bounds.height));
          this.dispatchResizeActions(elements, (element, bounds) => {
            const halfDiffHeight = 0.5 * (targetHeight - element.bounds.height);
            bounds.newPosition.y = element.bounds.y - halfDiffHeight;
            bounds.newSize.height = targetHeight;
          });
        }
        resizeWidthAndHeight(elements, reduceFn) {
          const targetWidth = reduceFn(...elements.map((element) => element.bounds.width));
          const targetHeight = reduceFn(...elements.map((element) => element.bounds.height));
          this.dispatchResizeActions(elements, (element, bounds) => {
            const halfDiffWidth = 0.5 * (targetWidth - element.bounds.width);
            const halfDiffHeight = 0.5 * (targetHeight - element.bounds.height);
            bounds.newPosition = { x: element.bounds.x - halfDiffWidth, y: element.bounds.y - halfDiffHeight };
            bounds.newSize = { width: targetWidth, height: targetHeight };
          });
        }
        dispatchResizeActions(elements, change) {
          const elementAndBounds = [];
          elements.forEach((element) => {
            const elementChange = this.createElementAndBounds(element, change);
            if (elementChange) {
              elementAndBounds.push(elementChange);
            }
          });
          this.dispatchActions([sprotty_1.SetBoundsAction.create(elementAndBounds), sprotty_1.ChangeBoundsOperation.create(elementAndBounds)]);
        }
        createElementAndBounds(element, change) {
          const bounds = {
            elementId: element.id,
            newPosition: {
              x: element.bounds.x,
              y: element.bounds.y
            },
            newSize: {
              width: element.bounds.width,
              height: element.bounds.height
            }
          };
          change(element, bounds);
          return (0, layout_utils_1.toValidElementAndBounds)(element, bounds, this.movementRestrictor);
        }
        isActionElement(element) {
          return (0, model_1.isResizable)(element);
        }
      };
      exports.ResizeElementsActionHandler = ResizeElementsActionHandler;
      exports.ResizeElementsActionHandler = ResizeElementsActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ResizeElementsActionHandler);
      var Alignment;
      (function(Alignment2) {
        Alignment2[Alignment2["Left"] = 0] = "Left";
        Alignment2[Alignment2["Center"] = 1] = "Center";
        Alignment2[Alignment2["Right"] = 2] = "Right";
        Alignment2[Alignment2["Top"] = 3] = "Top";
        Alignment2[Alignment2["Middle"] = 4] = "Middle";
        Alignment2[Alignment2["Bottom"] = 5] = "Bottom";
      })(Alignment || (exports.Alignment = Alignment = {}));
      var SelectFunction;
      (function(SelectFunction2) {
        function all(elements) {
          return elements;
        }
        SelectFunction2.all = all;
        function first(elements) {
          return [elements[0]];
        }
        SelectFunction2.first = first;
        function last(elements) {
          return [elements[elements.length - 1]];
        }
        SelectFunction2.last = last;
        function get(kind) {
          return SelectFunction2[kind];
        }
        SelectFunction2.get = get;
      })(SelectFunction || (exports.SelectFunction = SelectFunction = {}));
      var AlignElementsAction;
      (function(AlignElementsAction2) {
        AlignElementsAction2.KIND = "alignElements";
        function is(object) {
          return sprotty_1.Action.hasKind(object, AlignElementsAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "elementIds") && (0, sprotty_1.hasNumberProp)(object, "alignment") && (0, sprotty_1.hasStringProp)(object, "selectFunction");
        }
        AlignElementsAction2.is = is;
        function create(options = {}) {
          return Object.assign({ kind: AlignElementsAction2.KIND, elementIds: [], alignment: Alignment.Left, selectFunction: "all" }, options);
        }
        AlignElementsAction2.create = create;
      })(AlignElementsAction || (exports.AlignElementsAction = AlignElementsAction = {}));
      var AlignElementsActionHandler = class AlignElementsActionHandler extends LayoutElementsActionHandler {
        handle(action) {
          const elements = this.getSelectedElements(action);
          const selectFn = SelectFunction.get(action.selectFunction);
          const calculatedElements = selectFn(elements);
          if (elements.length > 1) {
            switch (action.alignment) {
              case Alignment.Left:
                return this.alignLeft(calculatedElements);
              case Alignment.Center:
                return this.alignCenter(calculatedElements);
              case Alignment.Right:
                return this.alignRight(calculatedElements);
              case Alignment.Top:
                return this.alignTop(calculatedElements);
              case Alignment.Middle:
                return this.alignMiddle(calculatedElements);
              case Alignment.Bottom:
                return this.alignBottom(calculatedElements);
            }
          }
        }
        alignLeft(elements) {
          const minX = elements.map((element) => element.bounds.x).reduce((a, b) => Math.min(a, b));
          this.dispatchAlignActions(elements, (_, move) => move.toPosition.x = minX);
        }
        alignCenter(elements) {
          const minX = elements.map((element) => element.bounds.x).reduce((a, b) => Math.min(a, b));
          const maxX = elements.map((element) => element.bounds.x + element.bounds.width).reduce((a, b) => Math.max(a, b));
          const diffX = maxX - minX;
          const centerX = minX + 0.5 * diffX;
          this.dispatchAlignActions(elements, (element, move) => move.toPosition.x = centerX - 0.5 * element.bounds.width);
        }
        alignRight(elements) {
          const maxX = elements.map((element) => element.bounds.x + element.bounds.width).reduce((a, b) => Math.max(a, b));
          this.dispatchAlignActions(elements, (element, move) => move.toPosition.x = maxX - element.bounds.width);
        }
        alignTop(elements) {
          const minY = elements.map((element) => element.bounds.y).reduce((a, b) => Math.min(a, b));
          this.dispatchAlignActions(elements, (_, move) => move.toPosition.y = minY);
        }
        alignMiddle(elements) {
          const minY = elements.map((element) => element.bounds.y).reduce((a, b) => Math.min(a, b));
          const maxY = elements.map((element) => element.bounds.y + element.bounds.height).reduce((a, b) => Math.max(a, b));
          const diffY = maxY - minY;
          const middleY = minY + 0.5 * diffY;
          this.dispatchAlignActions(elements, (element, move) => move.toPosition.y = middleY - 0.5 * element.bounds.height);
        }
        alignBottom(elements) {
          const maxY = elements.map((element) => element.bounds.y + element.bounds.height).reduce((a, b) => Math.max(a, b));
          this.dispatchAlignActions(elements, (element, move) => move.toPosition.y = maxY - element.bounds.height);
        }
        dispatchAlignActions(elements, change) {
          const moves = [];
          const elementAndBounds = [];
          elements.forEach((element) => {
            const move = this.createElementMove(element, change);
            if (move) {
              moves.push(move);
              const elementAndBound = this.createElementAndBounds(element, move);
              elementAndBounds.push(elementAndBound);
            }
          });
          this.dispatchActions([sprotty_1.MoveAction.create(moves), sprotty_1.ChangeBoundsOperation.create(elementAndBounds)]);
        }
        createElementMove(element, change) {
          const move = {
            elementId: element.id,
            fromPosition: {
              x: element.bounds.x,
              y: element.bounds.y
            },
            toPosition: {
              x: element.bounds.x,
              y: element.bounds.y
            }
          };
          change(element, move);
          return (0, layout_utils_1.toValidElementMove)(element, move, this.movementRestrictor);
        }
        createElementAndBounds(element, move) {
          return {
            elementId: element.id,
            newPosition: {
              x: move.toPosition.x,
              y: move.toPosition.y
            },
            newSize: {
              width: element.bounds.width,
              height: element.bounds.height
            }
          };
        }
        isActionElement(element) {
          return (0, model_1.isBoundsAwareMoveable)(element);
        }
      };
      exports.AlignElementsActionHandler = AlignElementsActionHandler;
      exports.AlignElementsActionHandler = AlignElementsActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], AlignElementsActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-target-resolver.js
  var require_navigation_target_resolver = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-target-resolver.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NavigationTargetResolver = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var NavigationTargetResolver = class NavigationTargetResolver {
        async resolve(navigationTarget) {
          return this.resolveWithSourceUri(this.diagramOptions.sourceUri, navigationTarget);
        }
        async resolveWithSourceUri(sourceUri, target) {
          const targetUri = decodeURIComponent(target.uri);
          if (sourceUri && sourceUri !== targetUri && `file://${sourceUri}` !== targetUri) {
            this.logger.info("Source and Target URI are different. Can't resolve locally.", sourceUri, targetUri);
            return void 0;
          }
          if (sprotty_1.NavigationTarget.getElementIds(target).length > 0) {
            return sprotty_1.SetResolvedNavigationTargetAction.create(sprotty_1.NavigationTarget.getElementIds(target));
          }
          const response = await this.requestResolution(target);
          if (sprotty_1.SetResolvedNavigationTargetAction.is(response)) {
            return response;
          }
          return void 0;
        }
        requestResolution(target) {
          return this.dispatcher.request(sprotty_1.ResolveNavigationTargetAction.create(target));
        }
      };
      exports.NavigationTargetResolver = NavigationTargetResolver;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], NavigationTargetResolver.prototype, "dispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], NavigationTargetResolver.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], NavigationTargetResolver.prototype, "diagramOptions", void 0);
      exports.NavigationTargetResolver = NavigationTargetResolver = __decorate([
        (0, inversify_1.injectable)()
      ], NavigationTargetResolver);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-action-handler.js
  var require_navigation_action_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NavigationActionHandler = exports.ProcessNavigationArgumentsAction = exports.NavigateAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var navigation_target_resolver_1 = require_navigation_target_resolver();
      var NavigateAction;
      (function(NavigateAction2) {
        NavigateAction2.KIND = "navigate";
        function is(object) {
          return sprotty_1.Action.hasKind(object, NavigateAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "targetTypeId");
        }
        NavigateAction2.is = is;
        function create(targetTypeId, options = {}) {
          return Object.assign({ kind: NavigateAction2.KIND, targetTypeId }, options);
        }
        NavigateAction2.create = create;
      })(NavigateAction || (exports.NavigateAction = NavigateAction = {}));
      var ProcessNavigationArgumentsAction;
      (function(ProcessNavigationArgumentsAction2) {
        ProcessNavigationArgumentsAction2.KIND = "processNavigationArguments";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ProcessNavigationArgumentsAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "args");
        }
        ProcessNavigationArgumentsAction2.is = is;
        function create(args) {
          return {
            kind: ProcessNavigationArgumentsAction2.KIND,
            args
          };
        }
        ProcessNavigationArgumentsAction2.create = create;
      })(ProcessNavigationArgumentsAction || (exports.ProcessNavigationArgumentsAction = ProcessNavigationArgumentsAction = {}));
      var NavigationActionHandler = class NavigationActionHandler {
        constructor() {
          this.notificationTimeout = 5e3;
        }
        handle(action) {
          if (NavigateAction.is(action)) {
            this.handleNavigateAction(action);
          } else if (sprotty_1.NavigateToTargetAction.is(action)) {
            this.handleNavigateToTarget(action);
          } else if (ProcessNavigationArgumentsAction.is(action)) {
            this.processNavigationArguments(action.args);
          } else if (sprotty_1.NavigateToExternalTargetAction.is(action)) {
            this.handleNavigateToExternalTarget(action);
          }
        }
        async handleNavigateAction(action) {
          try {
            const editorContextService = await this.editorContextService();
            const editorContext = editorContextService.get(action.args);
            const response = await this.dispatcher.request(sprotty_1.RequestNavigationTargetsAction.create({ targetTypeId: action.targetTypeId, editorContext }));
            if (sprotty_1.SetNavigationTargetsAction.is(response) && response.targets && response.targets.length === 1) {
              if (response.targets.length > 1) {
                this.logger.warn(this, "Processing of multiple targets is not supported yet. Only the first is being processed.", response.targets);
              }
              return this.dispatcher.dispatch(sprotty_1.NavigateToTargetAction.create(response.targets[0]));
            }
            this.warnAboutFailedNavigation("No valid navigation target found");
          } catch (reason) {
            this.logger.error(this, "Failed to obtain navigation target", reason, action);
          }
        }
        async handleNavigateToTarget(action) {
          try {
            const resolvedElements = await this.resolveElements(action);
            if (this.containsElementIdsOrArguments(resolvedElements)) {
              this.navigateTo(resolvedElements);
              this.handleResolutionArguments(resolvedElements);
              return;
            } else {
              this.navigateToExternal(action.target);
              return;
            }
          } catch (reason) {
            this.logger.error(this, "Failed to navigate", reason, action);
          }
        }
        resolveElements(action) {
          return this.resolver.resolve(action.target);
        }
        containsElementIdsOrArguments(target) {
          return target !== void 0 && (this.containsElementIds(target.elementIds) || this.containsArguments(target.args));
        }
        containsElementIds(elementIds) {
          return elementIds !== void 0 && elementIds.length > 0;
        }
        containsArguments(args) {
          return args !== void 0 && args !== void 0 && Object.keys(args).length > 0;
        }
        navigateTo(target) {
          const elementIds = target.elementIds;
          if (!this.containsElementIds(elementIds)) {
            return;
          }
          this.dispatcher.dispatchAll([
            sprotty_1.SelectAllAction.create(false),
            sprotty_1.SelectAction.create({ selectedElementsIDs: elementIds }),
            sprotty_1.CenterAction.create(elementIds)
          ]);
        }
        handleResolutionArguments(target) {
          const args = target.args;
          if (!this.containsArguments(args)) {
            return;
          }
          this.dispatcher.dispatch(ProcessNavigationArgumentsAction.create(args));
        }
        navigateToExternal(target) {
          return this.dispatcher.dispatch(sprotty_1.NavigateToExternalTargetAction.create(target));
        }
        processNavigationArguments(args) {
          if (args.info && args.info.toString().length > 0) {
            this.notify("INFO", args.info.toString());
          }
          if (args.warning && args.warning.toString().length > 0) {
            this.notify("WARNING", args.warning.toString());
          }
          if (args.error && args.error.toString().length > 0) {
            this.notify("ERROR", args.error.toString());
          }
        }
        async handleNavigateToExternalTarget(action) {
          const registry = await this.actionHandlerRegistryProvider();
          const handlers = registry.get(sprotty_1.NavigateToExternalTargetAction.KIND);
          if (handlers.length === 1) {
            this.warnAboutFailedNavigation("Could not resolve or navigate to target", action.target);
          }
        }
        warnAboutFailedNavigation(msg, target) {
          const message = `${msg}` + (target ? `: '${target.uri}' (arguments: ${JSON.stringify(target.args)})` : "");
          this.logger.warn(this, msg, target);
          this.notify("WARNING", message);
        }
        notify(severity, message) {
          const timeout = this.notificationTimeout;
          this.dispatcher.dispatchAll([sprotty_1.StatusAction.create(message, { severity, timeout }), sprotty_1.MessageAction.create(message, { severity })]);
        }
      };
      exports.NavigationActionHandler = NavigationActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], NavigationActionHandler.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], NavigationActionHandler.prototype, "dispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ActionHandlerRegistryProvider),
        __metadata("design:type", Function)
      ], NavigationActionHandler.prototype, "actionHandlerRegistryProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IEditorContextServiceProvider),
        __metadata("design:type", Function)
      ], NavigationActionHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(navigation_target_resolver_1.NavigationTargetResolver),
        __metadata("design:type", navigation_target_resolver_1.NavigationTargetResolver)
      ], NavigationActionHandler.prototype, "resolver", void 0);
      exports.NavigationActionHandler = NavigationActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], NavigationActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/routing/glsp-manhattan-edge-router.js
  var require_glsp_manhattan_edge_router = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/routing/glsp-manhattan-edge-router.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPManhattanEdgeRouter = void 0;
      var sprotty_1 = require_lib5();
      var GLSPManhattanEdgeRouter = class extends sprotty_1.ManhattanEdgeRouter {
        applyInnerHandleMoves(edge, moves) {
          const route = this.route(edge);
          const routingPoints = edge.routingPoints;
          const minimalPointDistance = this.getOptions(edge).minimalPointDistance;
          moves.forEach((move) => {
            const handle = move.handle;
            const index = handle.pointIndex;
            const correctedX = this.correctX(routingPoints, index, move.toPosition.x, minimalPointDistance);
            const correctedY = this.correctY(routingPoints, index, move.toPosition.y, minimalPointDistance);
            switch (handle.kind) {
              case "manhattan-50%":
                if (index < 0) {
                  if (routingPoints.length === 0) {
                    routingPoints.push({ x: correctedX, y: correctedY });
                    move.handle.pointIndex = 0;
                  } else if ((0, sprotty_1.almostEquals)(route[0].x, route[1].x)) {
                    this.alignX(routingPoints, 0, correctedX);
                  } else {
                    this.alignY(routingPoints, 0, correctedY);
                  }
                } else if (index < routingPoints.length - 1) {
                  if ((0, sprotty_1.almostEquals)(routingPoints[index].x, routingPoints[index + 1].x)) {
                    this.alignX(routingPoints, index, correctedX);
                    this.alignX(routingPoints, index + 1, correctedX);
                  } else {
                    this.alignY(routingPoints, index, correctedY);
                    this.alignY(routingPoints, index + 1, correctedY);
                  }
                } else {
                  if ((0, sprotty_1.almostEquals)(route[route.length - 2].x, route[route.length - 1].x)) {
                    this.alignX(routingPoints, routingPoints.length - 1, correctedX);
                  } else {
                    this.alignY(routingPoints, routingPoints.length - 1, correctedY);
                  }
                }
                break;
            }
          });
        }
      };
      exports.GLSPManhattanEdgeRouter = GLSPManhattanEdgeRouter;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/save/save-keylistener.js
  var require_save_keylistener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/save/save-keylistener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SaveModelKeyboardListener = void 0;
      var sprotty_1 = require_lib5();
      var SaveModelKeyboardListener = class extends sprotty_1.KeyListener {
        keyDown(_element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyS", "ctrlCmd")) {
            return [sprotty_1.SaveModelAction.create()];
          }
          return [];
        }
      };
      exports.SaveModelKeyboardListener = SaveModelKeyboardListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/select/select-feedback-command.js
  var require_select_feedback_command = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/select/select-feedback-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectFeedbackCommand = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var selection_service_1 = require_selection_service();
      var SelectFeedbackCommand = class SelectFeedbackCommand extends sprotty_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.sprottySelectCommand = new sprotty_1.SprottySelectCommand(Object.assign(Object.assign({}, action), { kind: sprotty_1.SelectAction.KIND }));
        }
        execute(context) {
          return this.sprottySelectCommand.execute(context);
        }
        undo(context) {
          return this.sprottySelectCommand.undo(context);
        }
        redo(context) {
          return this.sprottySelectCommand.redo(context);
        }
      };
      exports.SelectFeedbackCommand = SelectFeedbackCommand;
      SelectFeedbackCommand.KIND = selection_service_1.SelectFeedbackAction.KIND;
      exports.SelectFeedbackCommand = SelectFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SelectFeedbackCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/select/select-mouse-listener.js
  var require_select_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/select/select-mouse-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RankedSelectMouseListener = void 0;
      var sprotty_1 = require_lib5();
      var ranked_1 = require_ranked();
      var RankedSelectMouseListener = class extends sprotty_1.SelectMouseListener {
        constructor() {
          super(...arguments);
          this.rank = ranked_1.Ranked.DEFAULT_RANK - 100;
        }
        handleSelectTarget(selectableTarget, deselectedElements, event) {
          const result = [];
          result.push(sprotty_1.SelectAction.create({
            selectedElementsIDs: [selectableTarget.id],
            deselectedElementsIDs: deselectedElements.map((e) => e.id)
          }));
          result.push(sprotty_1.BringToFrontAction.create([selectableTarget.id]));
          return result;
        }
        handleDeselectTarget(selectableTarget, event) {
          const result = [];
          result.push(sprotty_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: [selectableTarget.id] }));
          return result;
        }
        handleDeselectAll(deselectedElements, event) {
          const result = [];
          result.push(sprotty_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: deselectedElements.map((e) => e.id) }));
          return result;
        }
      };
      exports.RankedSelectMouseListener = RankedSelectMouseListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/source-model-watcher/source-model-changed-action-handler.js
  var require_source_model_changed_action_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/source-model-watcher/source-model-changed-action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SourceModelChangedActionHandler = exports.ExternalSourceModelChangedHandler = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var ExternalSourceModelChangedHandler = class ExternalSourceModelChangedHandler {
      };
      exports.ExternalSourceModelChangedHandler = ExternalSourceModelChangedHandler;
      exports.ExternalSourceModelChangedHandler = ExternalSourceModelChangedHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ExternalSourceModelChangedHandler);
      var SourceModelChangedActionHandler = class SourceModelChangedActionHandler {
        handle(action) {
          if (sprotty_1.SourceModelChangedAction.is(action)) {
            if (this.externalModelSourceChangedHandler) {
              this.externalModelSourceChangedHandler.notifySourceModelChange(action.sourceModelName, this.options).then((actions) => this.dispatcher.dispatchAll(actions));
              return;
            }
            this.showSimpleNotification(action);
          }
        }
        showSimpleNotification(action) {
          const message = `The source model ${action.sourceModelName} has changed. You might want to consider reloading.`;
          const timeout = 0;
          const severity = "WARNING";
          this.dispatcher.dispatchAll([sprotty_1.StatusAction.create(message, { severity, timeout }), sprotty_1.MessageAction.create(message, { severity })]);
        }
      };
      exports.SourceModelChangedActionHandler = SourceModelChangedActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], SourceModelChangedActionHandler.prototype, "dispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], SourceModelChangedActionHandler.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(ExternalSourceModelChangedHandler),
        (0, inversify_1.optional)(),
        __metadata("design:type", ExternalSourceModelChangedHandler)
      ], SourceModelChangedActionHandler.prototype, "externalModelSourceChangedHandler", void 0);
      exports.SourceModelChangedActionHandler = SourceModelChangedActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], SourceModelChangedActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/status/status-overlay.js
  var require_status_overlay = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/status/status-overlay.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var StatusOverlay_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatusOverlay = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var editor_context_service_1 = require_editor_context_service();
      var StatusOverlay = StatusOverlay_1 = class StatusOverlay extends sprotty_1.AbstractUIExtension {
        id() {
          return StatusOverlay_1.ID;
        }
        containerClass() {
          return "sprotty-status";
        }
        initializeContents(containerElement) {
          this.statusIconDiv = document.createElement("div");
          containerElement.appendChild(this.statusIconDiv);
          this.statusMessageDiv = document.createElement("div");
          this.statusMessageDiv.classList.add("sprotty-status-message");
          containerElement.appendChild(this.statusMessageDiv);
        }
        setStatus(status) {
          if (this.statusMessageDiv) {
            this.statusMessageDiv.textContent = status.message;
            this.removeClasses(this.statusMessageDiv, 1);
            this.statusMessageDiv.classList.add(status.severity.toLowerCase());
          }
          if (this.statusIconDiv) {
            this.removeClasses(this.statusIconDiv, 0);
            const classes = this.statusIconDiv.classList;
            classes.add(status.severity.toLowerCase());
            switch (status.severity) {
              case "FATAL":
                classes.add(...(0, sprotty_1.codiconCSSClasses)("error"));
                break;
              case "ERROR":
                classes.add(...(0, sprotty_1.codiconCSSClasses)("warning"));
                break;
              case "WARNING":
                classes.add(...(0, sprotty_1.codiconCSSClasses)("warning"));
                break;
              case "INFO":
                classes.add(...(0, sprotty_1.codiconCSSClasses)("info"));
                break;
            }
          }
        }
        clearStatus() {
          this.setStatus(sprotty_1.StatusAction.create("", { severity: "NONE" }));
        }
        clearTimeout() {
          if (this.pendingTimeout) {
            window.clearTimeout(this.pendingTimeout);
            this.pendingTimeout = void 0;
          }
        }
        removeClasses(element, keep) {
          const classes = element.classList;
          while (classes.length > keep) {
            const item = classes.item(classes.length - 1);
            if (item) {
              classes.remove(item);
            }
          }
        }
        handle(action) {
          var _a;
          this.clearTimeout();
          if (action.severity === "NONE") {
            this.clearStatus();
            return;
          }
          this.setStatus(action);
          const statusTimeout = (_a = action.timeout) !== null && _a !== void 0 ? _a : -1;
          if (statusTimeout > 0) {
            this.pendingTimeout = window.setTimeout(() => this.clearStatus(), statusTimeout);
          }
        }
        preInitialize() {
          this.show(this.editorContext.modelRoot);
        }
      };
      exports.StatusOverlay = StatusOverlay;
      StatusOverlay.ID = "glsp.server.status.overlay";
      __decorate([
        (0, inversify_1.inject)(action_dispatcher_1.GLSPActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], StatusOverlay.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], StatusOverlay.prototype, "editorContext", void 0);
      exports.StatusOverlay = StatusOverlay = StatusOverlay_1 = __decorate([
        (0, inversify_1.injectable)()
      ], StatusOverlay);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/svg-metadata/metadata-placer.js
  var require_metadata_placer = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/svg-metadata/metadata-placer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MetadataPlacer = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var model_1 = require_model21();
      var MetadataPlacer = class MetadataPlacer {
        decorate(vnode, element) {
          if (element instanceof sprotty_1.GModelRoot) {
            (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-api", true);
          }
          (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-type", element.type);
          if (element instanceof sprotty_1.GChildElement) {
            (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-parent-id", this.domHelper.createUniqueDOMElementId(element.parent));
          }
          if (element instanceof model_1.GEdge) {
            if (element.source !== void 0) {
              (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-edge-source-id", this.domHelper.createUniqueDOMElementId(element.source));
            }
            if (element.target !== void 0) {
              (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-edge-target-id", this.domHelper.createUniqueDOMElementId(element.target));
            }
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.MetadataPlacer = MetadataPlacer;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.DOMHelper),
        __metadata("design:type", sprotty_1.DOMHelper)
      ], MetadataPlacer.prototype, "domHelper", void 0);
      exports.MetadataPlacer = MetadataPlacer = __decorate([
        (0, inversify_1.injectable)()
      ], MetadataPlacer);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/deletion/delete-tool.js
  var require_delete_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/deletion/delete-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var DelKeyDeleteTool_1;
      var MouseDeleteTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteToolMouseListener = exports.MouseDeleteTool = exports.DeleteKeyListener = exports.DelKeyDeleteTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var base_tools_1 = require_base_tools();
      var DelKeyDeleteTool = DelKeyDeleteTool_1 = class DelKeyDeleteTool {
        constructor() {
          this.isEditTool = true;
          this.deleteKeyListener = new DeleteKeyListener();
        }
        get id() {
          return DelKeyDeleteTool_1.ID;
        }
        enable() {
          this.keytool.register(this.deleteKeyListener);
        }
        disable() {
          this.keytool.deregister(this.deleteKeyListener);
        }
      };
      exports.DelKeyDeleteTool = DelKeyDeleteTool;
      DelKeyDeleteTool.ID = "glsp.delete-keyboard";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], DelKeyDeleteTool.prototype, "keytool", void 0);
      exports.DelKeyDeleteTool = DelKeyDeleteTool = DelKeyDeleteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], DelKeyDeleteTool);
      var DeleteKeyListener = class DeleteKeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Delete")) {
            const deleteElementIds = Array.from(element.root.index.all().filter((e) => (0, sprotty_1.isDeletable)(e) && (0, sprotty_1.isSelectable)(e) && e.selected).filter((e) => e.id !== e.root.id).map((e) => e.id));
            if (deleteElementIds.length > 0) {
              return [sprotty_1.DeleteElementOperation.create(deleteElementIds)];
            }
          }
          return [];
        }
      };
      exports.DeleteKeyListener = DeleteKeyListener;
      exports.DeleteKeyListener = DeleteKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteKeyListener);
      var MouseDeleteTool = MouseDeleteTool_1 = class MouseDeleteTool extends base_tools_1.BaseEditTool {
        constructor() {
          super(...arguments);
          this.deleteToolMouseListener = new DeleteToolMouseListener();
        }
        get id() {
          return MouseDeleteTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(this.deleteToolMouseListener), this.registerFeedback([(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.ELEMENT_DELETION)], this, [(0, css_feedback_1.cursorFeedbackAction)()]));
        }
      };
      exports.MouseDeleteTool = MouseDeleteTool;
      MouseDeleteTool.ID = "glsp.delete-mouse";
      exports.MouseDeleteTool = MouseDeleteTool = MouseDeleteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MouseDeleteTool);
      var DeleteToolMouseListener = class DeleteToolMouseListener extends sprotty_1.MouseListener {
        mouseUp(target, event) {
          const deletableParent = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isDeletable);
          if (deletableParent === void 0) {
            return [];
          }
          const result = [];
          result.push(sprotty_1.DeleteElementOperation.create([deletableParent.id]));
          if (!(0, sprotty_1.isCtrlOrCmd)(event)) {
            result.push(tool_1.EnableDefaultToolsAction.create());
          }
          return result;
        }
      };
      exports.DeleteToolMouseListener = DeleteToolMouseListener;
      exports.DeleteToolMouseListener = DeleteToolMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteToolMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-tool-feedback.js
  var require_marquee_tool_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-tool-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.removeMarquee = exports.drawMarquee = exports.MARQUEE = exports.marqueeId = exports.MarqueeEndMovingMouseListener = exports.RemoveMarqueeCommand = exports.RemoveMarqueeAction = exports.DrawMarqueeCommand = exports.DrawMarqueeAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var feedback_command_1 = require_feedback_command();
      var DrawMarqueeAction;
      (function(DrawMarqueeAction2) {
        DrawMarqueeAction2.KIND = "drawMarquee";
        function is(object) {
          return sprotty_1.Action.hasKind(object, DrawMarqueeAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "startPoint") && (0, sprotty_1.hasObjectProp)(object, "endPoint");
        }
        DrawMarqueeAction2.is = is;
        function create(options) {
          return Object.assign({ kind: DrawMarqueeAction2.KIND }, options);
        }
        DrawMarqueeAction2.create = create;
      })(DrawMarqueeAction || (exports.DrawMarqueeAction = DrawMarqueeAction = {}));
      var DrawMarqueeCommand = class DrawMarqueeCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          drawMarquee(context, this.action.startPoint, this.action.endPoint);
          return context.root;
        }
      };
      exports.DrawMarqueeCommand = DrawMarqueeCommand;
      DrawMarqueeCommand.KIND = DrawMarqueeAction.KIND;
      exports.DrawMarqueeCommand = DrawMarqueeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DrawMarqueeCommand);
      var RemoveMarqueeAction;
      (function(RemoveMarqueeAction2) {
        RemoveMarqueeAction2.KIND = "removeMarquee";
        function is(object) {
          return sprotty_1.Action.hasKind(object, RemoveMarqueeAction2.KIND);
        }
        RemoveMarqueeAction2.is = is;
        function create() {
          return { kind: RemoveMarqueeAction2.KIND };
        }
        RemoveMarqueeAction2.create = create;
      })(RemoveMarqueeAction || (exports.RemoveMarqueeAction = RemoveMarqueeAction = {}));
      var RemoveMarqueeCommand = class RemoveMarqueeCommand extends feedback_command_1.FeedbackCommand {
        execute(context) {
          removeMarquee(context.root);
          return context.root;
        }
      };
      exports.RemoveMarqueeCommand = RemoveMarqueeCommand;
      RemoveMarqueeCommand.KIND = RemoveMarqueeAction.KIND;
      exports.RemoveMarqueeCommand = RemoveMarqueeCommand = __decorate([
        (0, inversify_1.injectable)()
      ], RemoveMarqueeCommand);
      var MarqueeEndMovingMouseListener = class extends sprotty_1.MouseListener {
        constructor(anchorRegistry) {
          super();
          this.anchorRegistry = anchorRegistry;
        }
        mouseMove(target, event) {
          return [];
        }
      };
      exports.MarqueeEndMovingMouseListener = MarqueeEndMovingMouseListener;
      function marqueeId(root) {
        return root.id + "_" + exports.MARQUEE;
      }
      exports.marqueeId = marqueeId;
      exports.MARQUEE = "marquee";
      function drawMarquee(context, startPoint, endPoint) {
        const root = context.root;
        removeMarquee(root);
        const marqueeSchema = {
          type: exports.MARQUEE,
          id: marqueeId(root),
          startPoint,
          endPoint
        };
        const marquee = context.modelFactory.createElement(marqueeSchema);
        root.add(marquee);
      }
      exports.drawMarquee = drawMarquee;
      function removeMarquee(root) {
        const marquee = root.index.getById(marqueeId(root));
        if (marquee instanceof sprotty_1.GChildElement) {
          root.remove(marquee);
        }
      }
      exports.removeMarquee = removeMarquee;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-behavior.js
  var require_marquee_behavior = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-behavior.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarqueeUtil = void 0;
      var sprotty_1 = require_lib5();
      var marquee_tool_feedback_1 = require_marquee_tool_feedback();
      var MarqueeUtil = class {
        constructor(marqueeBehavior) {
          if (marqueeBehavior) {
            this.marqueeBehavior = marqueeBehavior;
          } else {
            this.marqueeBehavior = { entireElement: false, entireEdge: false };
          }
        }
        updateStartPoint(position) {
          this.startPoint = position;
        }
        updateCurrentPoint(position) {
          this.currentPoint = position;
        }
        drawMarqueeAction() {
          return marquee_tool_feedback_1.DrawMarqueeAction.create({ startPoint: this.startPoint, endPoint: this.currentPoint });
        }
        isEdgePathMarked(path) {
          if (!path) {
            return false;
          }
          const points = path.split(/M|L/).filter((p) => p).map((p) => {
            const coord = p.split(",");
            return { x: parseInt(coord[0], 10), y: parseInt(coord[1], 10) };
          });
          return this.isEdgeMarked(points);
        }
        isEdgeMarked(points) {
          return this.marqueeBehavior.entireEdge ? this.isEntireEdgeMarked(points) : this.isPartOfEdgeMarked(points);
        }
        isNodeMarked(elementBounds) {
          const horizontallyIn = this.startPoint.x < this.currentPoint.x ? this.isElementBetweenXAxis(elementBounds, this.startPoint.x, this.currentPoint.x) : this.isElementBetweenXAxis(elementBounds, this.currentPoint.x, this.startPoint.x);
          const verticallyIn = this.startPoint.y < this.currentPoint.y ? this.isElementBetweenYAxis(elementBounds, this.startPoint.y, this.currentPoint.y) : this.isElementBetweenYAxis(elementBounds, this.currentPoint.y, this.startPoint.y);
          return horizontallyIn && verticallyIn;
        }
        isEntireEdgeMarked(points) {
          for (let i = 0; i < points.length; i++) {
            if (!this.pointInRect(points[i])) {
              return false;
            }
          }
          return true;
        }
        isPartOfEdgeMarked(points) {
          for (let i = 0; i < points.length - 1; i++) {
            if (this.isLineMarked(points[i], points[i + 1])) {
              return true;
            }
          }
          return false;
        }
        isLineMarked(point1, point2) {
          const line = new sprotty_1.PointToPointLine(point1, point2);
          return this.pointInRect(point1) || this.pointInRect(point2) || this.lineIntersect(line, this.startPoint, { x: this.startPoint.x, y: this.currentPoint.y }) || this.lineIntersect(line, this.startPoint, { x: this.currentPoint.x, y: this.startPoint.y }) || this.lineIntersect(line, { x: this.currentPoint.x, y: this.startPoint.y }, this.currentPoint) || this.lineIntersect(line, { x: this.startPoint.x, y: this.currentPoint.y }, this.currentPoint);
        }
        lineIntersect(line, p1, p2) {
          return line.intersection(new sprotty_1.PointToPointLine(p1, p2)) !== void 0;
        }
        pointInRect(point) {
          const boolX = this.startPoint.x <= this.currentPoint.x ? this.isBetween(point.x, this.startPoint.x, this.currentPoint.x) : this.isBetween(point.x, this.currentPoint.x, this.startPoint.x);
          const boolY = this.startPoint.y <= this.currentPoint.y ? this.isBetween(point.y, this.startPoint.y, this.currentPoint.y) : this.isBetween(point.y, this.currentPoint.y, this.startPoint.y);
          return boolX && boolY;
        }
        isElementBetweenXAxis(elementBounds, marqueeLeft, marqueeRight) {
          const leftEdge = this.isBetween(elementBounds.x, marqueeLeft, marqueeRight);
          const rightEdge = this.isBetween(elementBounds.x + elementBounds.width, marqueeLeft, marqueeRight);
          if (this.marqueeBehavior.entireElement) {
            return leftEdge && rightEdge;
          }
          return leftEdge || rightEdge || this.isBetween(marqueeLeft, elementBounds.x, elementBounds.x + elementBounds.width) || this.isBetween(marqueeRight, elementBounds.x, elementBounds.x + elementBounds.width);
        }
        isElementBetweenYAxis(elementBounds, marqueeTop, marqueeBottom) {
          const topEdge = this.isBetween(elementBounds.y, marqueeTop, marqueeBottom);
          const bottomEdge = this.isBetween(elementBounds.y + elementBounds.height, marqueeTop, marqueeBottom);
          if (this.marqueeBehavior.entireElement) {
            return topEdge && bottomEdge;
          }
          return topEdge || bottomEdge || this.isBetween(marqueeTop, elementBounds.y, elementBounds.y + elementBounds.height) || this.isBetween(marqueeBottom, elementBounds.y, elementBounds.y + elementBounds.height);
        }
        isBetween(x, lower, upper) {
          return lower <= x && x <= upper;
        }
      };
      exports.MarqueeUtil = MarqueeUtil;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-mouse-tool.js
  var require_marquee_mouse_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-mouse-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var MarqueeMouseTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShiftKeyListener = exports.MarqueeMouseListener = exports.MarqueeMouseTool = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var viewpoint_util_1 = require_viewpoint_util();
      var base_tools_1 = require_base_tools();
      var marquee_behavior_1 = require_marquee_behavior();
      var marquee_tool_feedback_1 = require_marquee_tool_feedback();
      var model_1 = require_model21();
      var MarqueeMouseTool = MarqueeMouseTool_1 = class MarqueeMouseTool extends base_tools_1.BaseEditTool {
        constructor() {
          super(...arguments);
          this.shiftKeyListener = new ShiftKeyListener();
        }
        get id() {
          return MarqueeMouseTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(new MarqueeMouseListener(this.domHelper, this.editorContext.modelRoot, this.marqueeBehavior)), this.keyTool.registerListener(this.shiftKeyListener), this.registerFeedback([(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.MARQUEE)], this, [(0, css_feedback_1.cursorFeedbackAction)()]));
        }
      };
      exports.MarqueeMouseTool = MarqueeMouseTool;
      MarqueeMouseTool.ID = "glsp.marquee-mouse-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.DOMHelper),
        __metadata("design:type", sprotty_1.DOMHelper)
      ], MarqueeMouseTool.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IMarqueeBehavior),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], MarqueeMouseTool.prototype, "marqueeBehavior", void 0);
      exports.MarqueeMouseTool = MarqueeMouseTool = MarqueeMouseTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MarqueeMouseTool);
      var MarqueeMouseListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(domHelper, root, marqueeBehavior) {
          super();
          this.isActive = false;
          this.domHelper = domHelper;
          this.marqueeUtil = new marquee_behavior_1.MarqueeUtil(marqueeBehavior);
          this.nodes = Array.from(root.index.all().map((e) => e).filter((e) => (0, sprotty_1.isSelectable)(e)).filter((e) => e instanceof sprotty_1.GNode));
          const sEdges = Array.from(root.index.all().filter((e) => e instanceof model_1.GEdge).filter((e) => (0, sprotty_1.isSelectable)(e)).map((e) => e.id));
          this.edges = Array.from(document.querySelectorAll("g")).filter((e) => sEdges.includes(this.domHelper.findSModelIdByDOMElement(e)));
        }
        mouseDown(target, event) {
          this.isActive = true;
          this.marqueeUtil.updateStartPoint((0, viewpoint_util_1.getAbsolutePosition)(target, event));
          if (event.ctrlKey) {
            this.previouslySelected = Array.from(target.root.index.all().map((e) => e).filter((e) => (0, sprotty_1.isSelected)(e)).map((e) => e.id));
          }
          return [];
        }
        mouseMove(target, event) {
          this.marqueeUtil.updateCurrentPoint((0, viewpoint_util_1.getAbsolutePosition)(target, event));
          if (this.isActive) {
            const nodeIdsSelected = this.nodes.filter((e) => this.marqueeUtil.isNodeMarked((0, viewpoint_util_1.toAbsoluteBounds)(e))).map((e) => e.id);
            const edgeIdsSelected = this.edges.filter((e) => this.isEdgeMarked(e)).map((e) => this.domHelper.findSModelIdByDOMElement(e));
            const selected = nodeIdsSelected.concat(edgeIdsSelected);
            return [sprotty_1.SelectAction.setSelection(selected.concat(this.previouslySelected)), this.marqueeUtil.drawMarqueeAction()];
          }
          return [];
        }
        mouseUp(_target, event) {
          this.isActive = false;
          if (event.shiftKey) {
            return [marquee_tool_feedback_1.RemoveMarqueeAction.create()];
          }
          return [marquee_tool_feedback_1.RemoveMarqueeAction.create(), tool_1.EnableDefaultToolsAction.create()];
        }
        isEdgeMarked(element) {
          if (!element.getAttribute("transform")) {
            if (element.children[0]) {
              const path = element.children[0].getAttribute("d");
              return this.marqueeUtil.isEdgePathMarked(path);
            }
          }
          return false;
        }
      };
      exports.MarqueeMouseListener = MarqueeMouseListener;
      var ShiftKeyListener = class ShiftKeyListener extends sprotty_1.KeyListener {
        keyUp(element, event) {
          if (event.shiftKey) {
            return [];
          }
          return [marquee_tool_feedback_1.RemoveMarqueeAction.create(), tool_1.EnableDefaultToolsAction.create()];
        }
      };
      exports.ShiftKeyListener = ShiftKeyListener;
      exports.ShiftKeyListener = ShiftKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], ShiftKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tool-palette/tool-palette.js
  var require_tool_palette2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tool-palette/tool-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var ToolPalette_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.changeCodiconClass = exports.changeCSSClass = exports.createToolGroup = exports.createIcon = exports.compare = exports.ToolPalette = exports.EnableToolPaletteAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var editor_context_service_1 = require_editor_context_service();
      var focus_tracker_1 = require_focus_tracker();
      var tool_1 = require_tool();
      var delete_tool_1 = require_delete_tool();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var CLICKED_CSS_CLASS = "clicked";
      var SEARCH_ICON_ID = "search";
      var PALETTE_ICON_ID = "symbol-color";
      var CHEVRON_DOWN_ICON_ID = "chevron-right";
      var PALETTE_HEIGHT = "500px";
      var EnableToolPaletteAction;
      (function(EnableToolPaletteAction2) {
        EnableToolPaletteAction2.KIND = "enableToolPalette";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableToolPaletteAction2.KIND);
        }
        EnableToolPaletteAction2.is = is;
        function create() {
          return { kind: EnableToolPaletteAction2.KIND };
        }
        EnableToolPaletteAction2.create = create;
      })(EnableToolPaletteAction || (exports.EnableToolPaletteAction = EnableToolPaletteAction = {}));
      var ToolPalette = ToolPalette_1 = class ToolPalette extends sprotty_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.paletteItemsCopy = [];
        }
        id() {
          return ToolPalette_1.ID;
        }
        containerClass() {
          return ToolPalette_1.ID;
        }
        postConstruct() {
          this.editorContext.onEditModeChanged((change) => this.editModeChanged(change.newValue, change.oldValue));
        }
        initialize() {
          if (!this.paletteItems) {
            return false;
          }
          return super.initialize();
        }
        initializeContents(containerElement) {
          this.createHeader();
          this.createBody();
          this.lastActiveButton = this.defaultToolsButton;
          containerElement.setAttribute("aria-label", "Tool-Palette");
        }
        onBeforeShow(_containerElement, root) {
          this.modelRootId = root.id;
          this.containerElement.style.maxHeight = PALETTE_HEIGHT;
        }
        addMinimizePaletteButton() {
          const baseDiv = document.getElementById(this.options.baseDiv);
          const minPaletteDiv = document.createElement("div");
          minPaletteDiv.classList.add("minimize-palette-button");
          this.containerElement.classList.add("collapsible-palette");
          if (baseDiv) {
            const insertedDiv = baseDiv.insertBefore(minPaletteDiv, baseDiv.firstChild);
            const minimizeIcon = createIcon(CHEVRON_DOWN_ICON_ID);
            this.updateMinimizePaletteButtonTooltip(minPaletteDiv);
            minimizeIcon.onclick = (_event) => {
              if (this.isPaletteMaximized()) {
                this.containerElement.style.maxHeight = "0px";
              } else {
                this.containerElement.style.maxHeight = PALETTE_HEIGHT;
              }
              this.updateMinimizePaletteButtonTooltip(minPaletteDiv);
              changeCodiconClass(minimizeIcon, PALETTE_ICON_ID);
              changeCodiconClass(minimizeIcon, CHEVRON_DOWN_ICON_ID);
            };
            insertedDiv.appendChild(minimizeIcon);
          }
        }
        updateMinimizePaletteButtonTooltip(button) {
          if (this.isPaletteMaximized()) {
            button.title = "Minimize palette";
          } else {
            button.title = "Maximize palette";
          }
        }
        isPaletteMaximized() {
          return this.containerElement && this.containerElement.style.maxHeight !== "0px";
        }
        createBody() {
          const bodyDiv = document.createElement("div");
          bodyDiv.classList.add("palette-body");
          let tabIndex = 0;
          this.paletteItems.sort(compare).forEach((item) => {
            if (item.children) {
              const group = createToolGroup(item);
              item.children.sort(compare).forEach((child) => group.appendChild(this.createToolButton(child, tabIndex++)));
              bodyDiv.appendChild(group);
            } else {
              bodyDiv.appendChild(this.createToolButton(item, tabIndex++));
            }
          });
          if (this.paletteItems.length === 0) {
            const noResultsDiv = document.createElement("div");
            noResultsDiv.innerText = "No results found.";
            noResultsDiv.classList.add("tool-button");
            bodyDiv.appendChild(noResultsDiv);
          }
          if (this.bodyDiv) {
            this.containerElement.removeChild(this.bodyDiv);
          }
          this.containerElement.appendChild(bodyDiv);
          this.bodyDiv = bodyDiv;
        }
        createHeader() {
          this.addMinimizePaletteButton();
          const headerCompartment = document.createElement("div");
          headerCompartment.classList.add("palette-header");
          headerCompartment.append(this.createHeaderTitle());
          headerCompartment.appendChild(this.createHeaderTools());
          headerCompartment.appendChild(this.searchField = this.createHeaderSearchField());
          this.containerElement.appendChild(headerCompartment);
        }
        createHeaderTools() {
          const headerTools = document.createElement("div");
          headerTools.classList.add("header-tools");
          this.defaultToolsButton = this.createDefaultToolButton();
          headerTools.appendChild(this.defaultToolsButton);
          const deleteToolButton = this.createMouseDeleteToolButton();
          headerTools.appendChild(deleteToolButton);
          const marqueeToolButton = this.createMarqueeToolButton();
          headerTools.appendChild(marqueeToolButton);
          const validateActionButton = this.createValidateButton();
          headerTools.appendChild(validateActionButton);
          const searchIcon = this.createSearchButton();
          headerTools.appendChild(searchIcon);
          return headerTools;
        }
        createDefaultToolButton() {
          const button = createIcon("inspect");
          button.id = "btn_default_tools";
          button.title = "Enable selection tool";
          button.onclick = this.onClickStaticToolButton(button);
          button.ariaLabel = button.title;
          button.tabIndex = 1;
          return button;
        }
        createMouseDeleteToolButton() {
          const deleteToolButton = createIcon("chrome-close");
          deleteToolButton.title = "Enable deletion tool";
          deleteToolButton.onclick = this.onClickStaticToolButton(deleteToolButton, delete_tool_1.MouseDeleteTool.ID);
          deleteToolButton.ariaLabel = deleteToolButton.title;
          deleteToolButton.tabIndex = 1;
          return deleteToolButton;
        }
        createMarqueeToolButton() {
          const marqueeToolButton = createIcon("screen-full");
          marqueeToolButton.title = "Enable marquee tool";
          marqueeToolButton.onclick = this.onClickStaticToolButton(marqueeToolButton, marquee_mouse_tool_1.MarqueeMouseTool.ID);
          marqueeToolButton.ariaLabel = marqueeToolButton.title;
          marqueeToolButton.tabIndex = 1;
          return marqueeToolButton;
        }
        createValidateButton() {
          const validateActionButton = createIcon("pass");
          validateActionButton.title = "Validate model";
          validateActionButton.onclick = (_event) => {
            const modelIds = [this.modelRootId];
            this.actionDispatcher.dispatch(sprotty_1.RequestMarkersAction.create(modelIds, { reason: sprotty_1.MarkersReason.BATCH }));
            validateActionButton.focus();
          };
          validateActionButton.ariaLabel = validateActionButton.title;
          validateActionButton.tabIndex = 1;
          return validateActionButton;
        }
        createSearchButton() {
          const searchIcon = createIcon(SEARCH_ICON_ID);
          searchIcon.onclick = (_ev) => {
            const searchField = document.getElementById(this.containerElement.id + "_search_field");
            if (searchField) {
              if (searchField.style.display === "none") {
                searchField.style.display = "";
                searchField.focus();
              } else {
                searchField.style.display = "none";
              }
            }
          };
          searchIcon.classList.add("search-icon");
          searchIcon.title = "Filter palette entries";
          searchIcon.ariaLabel = searchIcon.title;
          searchIcon.tabIndex = 1;
          return searchIcon;
        }
        createHeaderSearchField() {
          const searchField = document.createElement("input");
          searchField.classList.add("search-input");
          searchField.id = this.containerElement.id + "_search_field";
          searchField.type = "text";
          searchField.placeholder = " Search...";
          searchField.style.display = "none";
          searchField.onkeyup = () => this.requestFilterUpdate(this.searchField.value);
          searchField.onkeydown = (ev) => this.clearOnEscape(ev);
          return searchField;
        }
        createHeaderTitle() {
          const header = document.createElement("div");
          header.classList.add("header-icon");
          header.appendChild(createIcon(PALETTE_ICON_ID));
          header.insertAdjacentText("beforeend", "Palette");
          return header;
        }
        createToolButton(item, index) {
          const button = document.createElement("div");
          button.tabIndex = index;
          button.classList.add("tool-button");
          if (item.icon) {
            button.appendChild(createIcon(item.icon));
          }
          button.insertAdjacentText("beforeend", item.label);
          button.onclick = this.onClickCreateToolButton(button, item);
          button.onkeydown = (ev) => this.clearToolOnEscape(ev);
          return button;
        }
        onClickCreateToolButton(button, item) {
          return (_ev) => {
            if (!this.editorContext.isReadonly) {
              this.actionDispatcher.dispatchAll(item.actions);
              this.changeActiveButton(button);
              button.focus();
            }
          };
        }
        onClickStaticToolButton(button, toolId) {
          return (_ev) => {
            if (!this.editorContext.isReadonly) {
              const action = toolId ? tool_1.EnableToolsAction.create([toolId]) : tool_1.EnableDefaultToolsAction.create();
              this.actionDispatcher.dispatch(action);
              this.changeActiveButton(button);
              button.focus();
            }
          };
        }
        changeActiveButton(button) {
          if (this.lastActiveButton) {
            this.lastActiveButton.classList.remove(CLICKED_CSS_CLASS);
          }
          if (button) {
            button.classList.add(CLICKED_CSS_CLASS);
            this.lastActiveButton = button;
          } else if (this.defaultToolsButton) {
            this.defaultToolsButton.classList.add(CLICKED_CSS_CLASS);
            this.lastActiveButton = this.defaultToolsButton;
          }
        }
        handle(action) {
          var _a;
          this.changeActiveButton();
          if (this.focusTracker.hasFocus) {
            (_a = this.focusTracker.diagramElement) === null || _a === void 0 ? void 0 : _a.focus();
          }
        }
        editModeChanged(_newValue, _oldValue) {
          this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: ToolPalette_1.ID, visible: !this.editorContext.isReadonly }));
        }
        clearOnEscape(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            this.searchField.value = "";
            this.requestFilterUpdate("");
          }
        }
        clearToolOnEscape(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            this.actionDispatcher.dispatch(tool_1.EnableDefaultToolsAction.create());
          }
        }
        handleSetContextActions(action) {
          this.paletteItems = action.actions.map((e) => e);
          this.createBody();
        }
        requestFilterUpdate(filter) {
          if (this.paletteItemsCopy.length === 0) {
            this.paletteItemsCopy = JSON.parse(JSON.stringify(this.paletteItems));
          }
          this.paletteItems = JSON.parse(JSON.stringify(this.paletteItemsCopy));
          const filteredPaletteItems = [];
          for (const itemGroup of this.paletteItems) {
            if (itemGroup.children) {
              const matchingChildren = itemGroup.children.filter((child) => child.label.toLowerCase().includes(filter.toLowerCase()));
              if (matchingChildren.length > 0) {
                itemGroup.children.splice(0, itemGroup.children.length);
                matchingChildren.forEach((child) => itemGroup.children.push(child));
                filteredPaletteItems.push(itemGroup);
              }
            }
          }
          this.paletteItems = filteredPaletteItems;
          this.createBody();
        }
        async preRequestModel() {
          const requestAction = sprotty_1.RequestContextActions.create({
            contextId: ToolPalette_1.ID,
            editorContext: {
              selectedElementIds: []
            }
          });
          const response = await this.actionDispatcher.request(requestAction);
          this.paletteItems = response.actions.map((e) => e);
          if (!this.editorContext.isReadonly) {
            this.show(this.editorContext.modelRoot);
          }
        }
      };
      exports.ToolPalette = ToolPalette;
      ToolPalette.ID = "tool-palette";
      __decorate([
        (0, inversify_1.inject)(action_dispatcher_1.GLSPActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], ToolPalette.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ToolPalette.prototype, "editorContext", void 0);
      __decorate([
        (0, inversify_1.inject)(focus_tracker_1.FocusTracker),
        __metadata("design:type", focus_tracker_1.FocusTracker)
      ], ToolPalette.prototype, "focusTracker", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], ToolPalette.prototype, "postConstruct", null);
      exports.ToolPalette = ToolPalette = ToolPalette_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ToolPalette);
      function compare(a, b) {
        const sortStringBased = a.sortString.localeCompare(b.sortString);
        if (sortStringBased !== 0) {
          return sortStringBased;
        }
        return a.label.localeCompare(b.label);
      }
      exports.compare = compare;
      function createIcon(codiconId) {
        const icon = document.createElement("i");
        icon.classList.add(...(0, sprotty_1.codiconCSSClasses)(codiconId));
        return icon;
      }
      exports.createIcon = createIcon;
      function createToolGroup(item) {
        const group = document.createElement("div");
        group.classList.add("tool-group");
        group.id = item.id;
        const header = document.createElement("div");
        header.classList.add("group-header");
        if (item.icon) {
          header.appendChild(createIcon(item.icon));
        }
        header.insertAdjacentText("beforeend", item.label);
        header.ondblclick = (_ev) => {
          const css = "collapsed";
          changeCSSClass(group, css);
          Array.from(group.children).forEach((child) => changeCSSClass(child, css));
          window.getSelection().removeAllRanges();
        };
        group.appendChild(header);
        return group;
      }
      exports.createToolGroup = createToolGroup;
      function changeCSSClass(element, css) {
        element.classList.contains(css) ? element.classList.remove(css) : element.classList.add(css);
      }
      exports.changeCSSClass = changeCSSClass;
      function changeCodiconClass(element, codiconId) {
        element.classList.contains((0, sprotty_1.codiconCSSClasses)(codiconId)[1]) ? element.classList.remove((0, sprotty_1.codiconCSSClasses)(codiconId)[1]) : element.classList.add((0, sprotty_1.codiconCSSClasses)(codiconId)[1]);
      }
      exports.changeCodiconClass = changeCodiconClass;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool-feedback.js
  var require_change_bounds_tool_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackMoveMouseListener = exports.HideChangeBoundsToolResizeFeedbackCommand = exports.ShowChangeBoundsToolResizeFeedbackCommand = exports.HideChangeBoundsToolResizeFeedbackAction = exports.ShowChangeBoundsToolResizeFeedbackAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var css_feedback_1 = require_css_feedback();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model22();
      var movement_restrictor_1 = require_movement_restrictor();
      var ShowChangeBoundsToolResizeFeedbackAction;
      (function(ShowChangeBoundsToolResizeFeedbackAction2) {
        ShowChangeBoundsToolResizeFeedbackAction2.KIND = "showChangeBoundsToolResizeFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ShowChangeBoundsToolResizeFeedbackAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "elementId");
        }
        ShowChangeBoundsToolResizeFeedbackAction2.is = is;
        function create(elementId) {
          return {
            kind: ShowChangeBoundsToolResizeFeedbackAction2.KIND,
            elementId
          };
        }
        ShowChangeBoundsToolResizeFeedbackAction2.create = create;
      })(ShowChangeBoundsToolResizeFeedbackAction || (exports.ShowChangeBoundsToolResizeFeedbackAction = ShowChangeBoundsToolResizeFeedbackAction = {}));
      var HideChangeBoundsToolResizeFeedbackAction;
      (function(HideChangeBoundsToolResizeFeedbackAction2) {
        HideChangeBoundsToolResizeFeedbackAction2.KIND = "hideChangeBoundsToolResizeFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, HideChangeBoundsToolResizeFeedbackAction2.KIND);
        }
        HideChangeBoundsToolResizeFeedbackAction2.is = is;
        function create() {
          return { kind: HideChangeBoundsToolResizeFeedbackAction2.KIND };
        }
        HideChangeBoundsToolResizeFeedbackAction2.create = create;
      })(HideChangeBoundsToolResizeFeedbackAction || (exports.HideChangeBoundsToolResizeFeedbackAction = HideChangeBoundsToolResizeFeedbackAction = {}));
      var ShowChangeBoundsToolResizeFeedbackCommand = class ShowChangeBoundsToolResizeFeedbackCommand extends feedback_command_1.FeedbackCommand {
        execute(context) {
          const index = context.root.index;
          (0, gmodel_util_1.forEachElement)(index, model_1.isResizable, model_1.removeResizeHandles);
          if (this.action.elementId) {
            const resizeElement = index.getById(this.action.elementId);
            if (resizeElement && (0, model_1.isResizable)(resizeElement)) {
              (0, model_1.addResizeHandles)(resizeElement);
            }
          }
          return context.root;
        }
      };
      exports.ShowChangeBoundsToolResizeFeedbackCommand = ShowChangeBoundsToolResizeFeedbackCommand;
      ShowChangeBoundsToolResizeFeedbackCommand.KIND = ShowChangeBoundsToolResizeFeedbackAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.Action),
        __metadata("design:type", Object)
      ], ShowChangeBoundsToolResizeFeedbackCommand.prototype, "action", void 0);
      exports.ShowChangeBoundsToolResizeFeedbackCommand = ShowChangeBoundsToolResizeFeedbackCommand = __decorate([
        (0, inversify_1.injectable)()
      ], ShowChangeBoundsToolResizeFeedbackCommand);
      var HideChangeBoundsToolResizeFeedbackCommand = class HideChangeBoundsToolResizeFeedbackCommand extends feedback_command_1.FeedbackCommand {
        execute(context) {
          const index = context.root.index;
          (0, gmodel_util_1.forEachElement)(index, model_1.isResizable, model_1.removeResizeHandles);
          return context.root;
        }
      };
      exports.HideChangeBoundsToolResizeFeedbackCommand = HideChangeBoundsToolResizeFeedbackCommand;
      HideChangeBoundsToolResizeFeedbackCommand.KIND = HideChangeBoundsToolResizeFeedbackAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.Action),
        __metadata("design:type", Object)
      ], HideChangeBoundsToolResizeFeedbackCommand.prototype, "action", void 0);
      exports.HideChangeBoundsToolResizeFeedbackCommand = HideChangeBoundsToolResizeFeedbackCommand = __decorate([
        (0, inversify_1.injectable)()
      ], HideChangeBoundsToolResizeFeedbackCommand);
      var FeedbackMoveMouseListener = class extends sprotty_1.MouseListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.hasDragged = false;
          this.elementId2startPos = /* @__PURE__ */ new Map();
        }
        mouseDown(target, event) {
          if (event.button === 0 && !(target instanceof model_1.SResizeHandle)) {
            const moveable = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isMoveable);
            if (moveable !== void 0) {
              this.startDragPosition = { x: event.pageX, y: event.pageY };
            } else {
              this.startDragPosition = void 0;
            }
            this.hasDragged = false;
          }
          return [];
        }
        mouseMove(target, event) {
          const result = [];
          if (event.buttons === 0) {
            this.mouseUp(target, event);
          } else if (this.startDragPosition) {
            if (this.elementId2startPos.size === 0) {
              this.collectStartPositions(target.root);
            }
            this.hasDragged = true;
            const moveAction = this.getElementMoves(target, event, false);
            if (moveAction) {
              result.push(moveAction);
              result.push((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.MOVE));
            }
          }
          this.tool.registerFeedback(result, this);
          return [];
        }
        collectStartPositions(root) {
          this.rootElement = root;
          const selectedElements = root.index.all().filter((element) => (0, sprotty_1.isSelectable)(element) && element.selected);
          const elementsSet = new Set(selectedElements);
          selectedElements.filter((element) => !this.isChildOfSelected(elementsSet, element)).forEach((element) => {
            if ((0, sprotty_1.isMoveable)(element)) {
              this.elementId2startPos.set(element.id, element.position);
            }
          });
        }
        isChildOfSelected(selectedElements, element) {
          while (element instanceof sprotty_1.GChildElement) {
            element = element.parent;
            if (selectedElements.has(element)) {
              return true;
            }
          }
          return false;
        }
        getElementMoves(target, event, finished) {
          if (!this.startDragPosition) {
            return void 0;
          }
          const viewport = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isViewport);
          const zoom = viewport ? viewport.zoom : 1;
          const delta = {
            x: (event.pageX - this.startDragPosition.x) / zoom,
            y: (event.pageY - this.startDragPosition.y) / zoom
          };
          const elementMoves = this.getElementMovesForDelta(target, delta, !event.shiftKey, finished);
          if (elementMoves.length > 0) {
            return sprotty_1.MoveAction.create(elementMoves, { animate: false, finished });
          } else {
            return void 0;
          }
        }
        getElementMovesForDelta(target, delta, isSnap, finished) {
          const elementMoves = [];
          this.elementId2startPos.forEach((startPosition, elementId) => {
            const element = target.root.index.getById(elementId);
            if (element) {
              let toPosition = this.snap({
                x: startPosition.x + delta.x,
                y: startPosition.y + delta.y
              }, element, isSnap);
              if ((0, sprotty_1.isMoveable)(element)) {
                toPosition = this.validateMove(startPosition, toPosition, element, finished);
                elementMoves.push({
                  elementId: element.id,
                  fromPosition: {
                    x: element.position.x,
                    y: element.position.y
                  },
                  toPosition
                });
              }
            }
          });
          return elementMoves;
        }
        validateMove(startPosition, toPosition, element, isFinished) {
          let newPosition = toPosition;
          if (this.tool.movementRestrictor) {
            const valid = this.tool.movementRestrictor.validate(element, toPosition);
            let action;
            if (!valid) {
              action = (0, movement_restrictor_1.createMovementRestrictionFeedback)(element, this.tool.movementRestrictor);
              if (isFinished) {
                newPosition = startPosition;
              }
            } else {
              action = (0, movement_restrictor_1.removeMovementRestrictionFeedback)(element, this.tool.movementRestrictor);
            }
            this.tool.registerFeedback([action], this);
          }
          return newPosition;
        }
        snap(position, element, isSnap) {
          if (isSnap && this.tool.snapper) {
            return this.tool.snapper.snap(position, element);
          } else {
            return position;
          }
        }
        mouseEnter(target, event) {
          if (target instanceof sprotty_1.GModelRoot && event.buttons === 0 && !this.startDragPosition) {
            this.mouseUp(target, event);
          }
          return [];
        }
        mouseUp(target, event) {
          const result = [];
          if (this.startDragPosition) {
            const moveAction = this.getElementMoves(target, event, true);
            if (moveAction) {
              result.push(moveAction);
            }
            const resetFeedback = [];
            if (this.tool.movementRestrictor) {
              resetFeedback.push((0, movement_restrictor_1.removeMovementRestrictionFeedback)(target, this.tool.movementRestrictor));
            }
            resetFeedback.push((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
            this.tool.deregisterFeedback(this, resetFeedback);
          }
          this.reset();
          return result;
        }
        reset(resetFeedback = false) {
          if (this.rootElement && resetFeedback) {
            const elementMoves = this.getElementMovesForDelta(this.rootElement, { x: 0, y: 0 }, true, true);
            const moveAction = sprotty_1.MoveAction.create(elementMoves, { animate: false, finished: true });
            this.tool.deregisterFeedback(this, [moveAction]);
          }
          this.hasDragged = false;
          this.startDragPosition = void 0;
          this.rootElement = void 0;
          this.elementId2startPos.clear();
        }
        decorate(vnode, _element) {
          return vnode;
        }
        dispose() {
          this.reset(true);
        }
      };
      exports.FeedbackMoveMouseListener = FeedbackMoveMouseListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool.js
  var require_change_bounds_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var ChangeBoundsTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChangeBoundsListener = exports.ChangeBoundsTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var selection_service_1 = require_selection_service();
      var snap_1 = require_snap2();
      var layout_utils_1 = require_layout_utils();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model22();
      var movement_restrictor_1 = require_movement_restrictor();
      var base_tools_1 = require_base_tools();
      var change_bounds_tool_feedback_1 = require_change_bounds_tool_feedback();
      var ChangeBoundsTool = ChangeBoundsTool_1 = class ChangeBoundsTool extends base_tools_1.BaseEditTool {
        get id() {
          return ChangeBoundsTool_1.ID;
        }
        enable() {
          const feedbackMoveMouseListener = this.createMoveMouseListener();
          if (sprotty_1.Disposable.is(feedbackMoveMouseListener)) {
            this.toDisposeOnDisable.push(feedbackMoveMouseListener);
          }
          const changeBoundsListener = this.createChangeBoundsListener();
          if (sprotty_1.Disposable.is(changeBoundsListener)) {
            this.toDisposeOnDisable.push(changeBoundsListener);
          }
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(feedbackMoveMouseListener), this.mouseTool.registerListener(changeBoundsListener), sprotty_1.Disposable.create(() => this.deregisterFeedback(feedbackMoveMouseListener)), sprotty_1.Disposable.create(() => this.deregisterFeedback(changeBoundsListener, [change_bounds_tool_feedback_1.HideChangeBoundsToolResizeFeedbackAction.create()])), this.selectionService.onSelectionChanged((change) => changeBoundsListener.selectionChanged(change.root, change.selectedElements)));
        }
        createMoveMouseListener() {
          return new change_bounds_tool_feedback_1.FeedbackMoveMouseListener(this);
        }
        createChangeBoundsListener() {
          return new ChangeBoundsListener(this);
        }
      };
      exports.ChangeBoundsTool = ChangeBoundsTool;
      ChangeBoundsTool.ID = "glsp.change-bounds-tool";
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], ChangeBoundsTool.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], ChangeBoundsTool.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ChangeBoundsTool.prototype, "snapper", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ChangeBoundsTool.prototype, "movementRestrictor", void 0);
      exports.ChangeBoundsTool = ChangeBoundsTool = ChangeBoundsTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ChangeBoundsTool);
      var ChangeBoundsListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.pointPositionUpdater = new snap_1.PointPositionUpdater(tool.snapper);
        }
        mouseDown(target, event) {
          super.mouseDown(target, event);
          if (event.button !== 0 || target instanceof sprotty_1.GModelRoot) {
            return [];
          }
          if (this.activeResizeElement && target instanceof model_1.SResizeHandle) {
            this.activeResizeHandle = target;
          } else {
            this.setActiveResizeElement(target);
          }
          if (this.activeResizeElement) {
            this.initPosition(event);
          } else {
            this.reset();
          }
          return [];
        }
        mouseMove(target, event) {
          super.mouseMove(target, event);
          if (this.isMouseDrag && this.activeResizeHandle) {
            const actions = [
              (0, css_feedback_1.cursorFeedbackAction)(this.activeResizeHandle.isNwSeResize() ? css_feedback_1.CursorCSS.RESIZE_NWSE : css_feedback_1.CursorCSS.RESIZE_NESW),
              (0, css_feedback_1.applyCssClasses)(this.activeResizeHandle, ChangeBoundsListener.CSS_CLASS_ACTIVE)
            ];
            const positionUpdate = this.pointPositionUpdater.updatePosition(target, { x: event.pageX, y: event.pageY }, !event.altKey);
            if (positionUpdate) {
              const resizeActions = this.handleResizeOnClient(positionUpdate);
              actions.push(...resizeActions);
            }
            this.tool.registerFeedback(actions, this);
          }
          return [];
        }
        draggingMouseUp(target, _event) {
          if (this.pointPositionUpdater.isLastDragPositionUndefined()) {
            this.resetPosition();
            return [];
          }
          const actions = [];
          if (this.activeResizeHandle) {
            actions.push(...this.handleResize(this.activeResizeHandle));
          } else {
            actions.push(...this.handleMoveOnServer(target));
          }
          this.resetPosition();
          this.tool.deregisterFeedback(this, [(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT)]);
          return actions;
        }
        handleMoveOnServer(target) {
          const operations = [];
          operations.push(...this.handleMoveElementsOnServer(target));
          operations.push(...this.handleMoveRoutingPointsOnServer(target));
          if (operations.length > 0) {
            return [sprotty_1.CompoundOperation.create(operations)];
          }
          return operations;
        }
        handleMoveElementsOnServer(target) {
          const result = [];
          const newBounds = [];
          const selectedElements = [];
          (0, gmodel_util_1.forEachElement)(target.index, gmodel_util_1.isNonRoutableSelectedMovableBoundsAware, (element) => {
            selectedElements.push(element);
          });
          const selectionSet = new Set(selectedElements);
          selectedElements.filter((element) => !this.isChildOfSelected(selectionSet, element)).map((element) => this.createElementAndBounds(element)).forEach((bounds) => newBounds.push(...bounds));
          if (newBounds.length > 0) {
            result.push(sprotty_1.ChangeBoundsOperation.create(newBounds));
          }
          return result;
        }
        isChildOfSelected(selectedElements, element) {
          while (element instanceof sprotty_1.GChildElement) {
            element = element.parent;
            if (selectedElements.has(element)) {
              return true;
            }
          }
          return false;
        }
        handleMoveRoutingPointsOnServer(target) {
          const newRoutingPoints = [];
          const routerRegistry = this.tool.edgeRouterRegistry;
          if (routerRegistry) {
            (0, gmodel_util_1.forEachElement)(target.index, gmodel_util_1.isNonRoutableSelectedMovableBoundsAware, (element) => {
              if (element instanceof sprotty_1.GConnectableElement) {
                element.incomingEdges.map((connectable) => (0, gmodel_util_1.calcElementAndRoutingPoints)(connectable, routerRegistry)).forEach((ear) => newRoutingPoints.push(ear));
                element.outgoingEdges.map((connectable) => (0, gmodel_util_1.calcElementAndRoutingPoints)(connectable, routerRegistry)).forEach((ear) => newRoutingPoints.push(ear));
              }
            });
          }
          return newRoutingPoints.length > 0 ? [sprotty_1.ChangeRoutingPointsOperation.create(newRoutingPoints)] : [];
        }
        handleResize(activeResizeHandle) {
          const actions = [];
          actions.push((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
          actions.push((0, css_feedback_1.deleteCssClasses)(activeResizeHandle, ChangeBoundsListener.CSS_CLASS_ACTIVE));
          const resizeElement = (0, sprotty_1.findParentByFeature)(activeResizeHandle, model_1.isResizable);
          if (this.isActiveResizeElement(resizeElement)) {
            this.createChangeBoundsAction(resizeElement).forEach((action) => actions.push(action));
          }
          return actions;
        }
        selectionChanged(root, selectedElements) {
          if (this.activeResizeElement) {
            if (selectedElements.includes(this.activeResizeElement.id)) {
              return;
            }
            for (const elementId of selectedElements.reverse()) {
              const element = root.index.getById(elementId);
              if (element && this.setActiveResizeElement(element)) {
                return;
              }
            }
            this.reset();
          }
        }
        setActiveResizeElement(target) {
          const moveableElement = (0, sprotty_1.findParentByFeature)(target, model_1.isBoundsAwareMoveable);
          if ((0, sprotty_1.isSelected)(moveableElement)) {
            this.activeResizeElement = moveableElement;
            if ((0, model_1.isResizable)(this.activeResizeElement)) {
              this.tool.registerFeedback([change_bounds_tool_feedback_1.ShowChangeBoundsToolResizeFeedbackAction.create(this.activeResizeElement.id)], this.activeResizeElement);
            }
            return true;
          }
          return false;
        }
        isActiveResizeElement(element) {
          return element !== void 0 && this.activeResizeElement !== void 0 && element.id === this.activeResizeElement.id;
        }
        initPosition(event) {
          this.pointPositionUpdater.updateLastDragPosition({ x: event.pageX, y: event.pageY });
          if (this.activeResizeHandle) {
            const resizeElement = (0, sprotty_1.findParentByFeature)(this.activeResizeHandle, model_1.isResizable);
            this.initialBounds = {
              x: resizeElement.bounds.x,
              y: resizeElement.bounds.y,
              width: resizeElement.bounds.width,
              height: resizeElement.bounds.height
            };
          }
        }
        dispose() {
          this.reset(true);
        }
        reset(resetBounds = false) {
          this.resetFeedback(resetBounds);
          this.resetPosition();
        }
        resetFeedback(resetBounds = false) {
          const resetFeedback = [];
          if (this.activeResizeElement && (0, model_1.isResizable)(this.activeResizeElement)) {
            if (this.initialBounds && this.activeResizeHandle && resetBounds) {
              resetFeedback.push(sprotty_1.SetBoundsAction.create([
                {
                  elementId: this.activeResizeElement.id,
                  newPosition: this.initialBounds,
                  newSize: this.initialBounds
                }
              ]));
            }
            this.tool.deregisterFeedback(this.activeResizeElement, [change_bounds_tool_feedback_1.HideChangeBoundsToolResizeFeedbackAction.create()]);
          }
          resetFeedback.push((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
          this.tool.deregisterFeedback(this, resetFeedback);
        }
        resetPosition() {
          this.activeResizeHandle = void 0;
          this.pointPositionUpdater.resetPosition();
        }
        handleResizeOnClient(positionUpdate) {
          if (!this.activeResizeHandle) {
            return [];
          }
          const resizeElement = (0, sprotty_1.findParentByFeature)(this.activeResizeHandle, model_1.isResizable);
          if (this.isActiveResizeElement(resizeElement)) {
            switch (this.activeResizeHandle.location) {
              case model_1.ResizeHandleLocation.TopLeft:
                return this.handleTopLeftResize(resizeElement, positionUpdate);
              case model_1.ResizeHandleLocation.TopRight:
                return this.handleTopRightResize(resizeElement, positionUpdate);
              case model_1.ResizeHandleLocation.BottomLeft:
                return this.handleBottomLeftResize(resizeElement, positionUpdate);
              case model_1.ResizeHandleLocation.BottomRight:
                return this.handleBottomRightResize(resizeElement, positionUpdate);
            }
          }
          return [];
        }
        handleTopLeftResize(resizeElement, positionUpdate) {
          return this.createSetBoundsAction(resizeElement, resizeElement.bounds.x + positionUpdate.x, resizeElement.bounds.y + positionUpdate.y, resizeElement.bounds.width - positionUpdate.x, resizeElement.bounds.height - positionUpdate.y);
        }
        handleTopRightResize(resizeElement, positionUpdate) {
          return this.createSetBoundsAction(resizeElement, resizeElement.bounds.x, resizeElement.bounds.y + positionUpdate.y, resizeElement.bounds.width + positionUpdate.x, resizeElement.bounds.height - positionUpdate.y);
        }
        handleBottomLeftResize(resizeElement, positionUpdate) {
          return this.createSetBoundsAction(resizeElement, resizeElement.bounds.x + positionUpdate.x, resizeElement.bounds.y, resizeElement.bounds.width - positionUpdate.x, resizeElement.bounds.height + positionUpdate.y);
        }
        handleBottomRightResize(resizeElement, positionUpdate) {
          return this.createSetBoundsAction(resizeElement, resizeElement.bounds.x, resizeElement.bounds.y, resizeElement.bounds.width + positionUpdate.x, resizeElement.bounds.height + positionUpdate.y);
        }
        createChangeBoundsAction(element) {
          if (this.isValidBoundChange(element, element.bounds, element.bounds)) {
            return [sprotty_1.ChangeBoundsOperation.create([(0, gmodel_util_1.toElementAndBounds)(element)])];
          } else if (this.initialBounds) {
            const actions = [];
            if (this.tool.movementRestrictor) {
              actions.push((0, movement_restrictor_1.removeMovementRestrictionFeedback)(element, this.tool.movementRestrictor));
            }
            actions.push(sprotty_1.SetBoundsAction.create([{ elementId: element.id, newPosition: this.initialBounds, newSize: this.initialBounds }]));
            return actions;
          }
          return [];
        }
        createElementAndBounds(element) {
          if (this.isValidBoundChange(element, element.bounds, element.bounds)) {
            return [(0, gmodel_util_1.toElementAndBounds)(element)];
          }
          return [];
        }
        createSetBoundsAction(element, x, y, width, height) {
          const newPosition = { x, y };
          const newSize = { width, height };
          const result = [];
          if (this.isValidBoundChange(element, newPosition, newSize)) {
            if (this.tool.movementRestrictor) {
              result.push((0, movement_restrictor_1.removeMovementRestrictionFeedback)(element, this.tool.movementRestrictor));
            }
            result.push(sprotty_1.SetBoundsAction.create([{ elementId: element.id, newPosition, newSize }]));
          } else if (this.isValidSize(element, newSize)) {
            if (this.tool.movementRestrictor) {
              result.push((0, movement_restrictor_1.createMovementRestrictionFeedback)(element, this.tool.movementRestrictor));
            }
            result.push(sprotty_1.SetBoundsAction.create([{ elementId: element.id, newPosition, newSize }]));
          }
          return result;
        }
        snap(position, element, isSnap) {
          return isSnap && this.tool.snapper ? this.tool.snapper.snap(position, element) : { x: position.x, y: position.y };
        }
        isValidBoundChange(element, newPosition, newSize) {
          return this.isValidSize(element, newSize) && this.isValidMove(element, newPosition);
        }
        isValidSize(element, size) {
          return (0, layout_utils_1.isValidSize)(element, size);
        }
        isValidMove(element, newPosition) {
          return (0, layout_utils_1.isValidMove)(element, newPosition, this.tool.movementRestrictor);
        }
      };
      exports.ChangeBoundsListener = ChangeBoundsListener;
      ChangeBoundsListener.CSS_CLASS_ACTIVE = "active";
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/view.js
  var require_view3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SResizeHandleView = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var model_1 = require_model22();
      var JSX = { createElement: sprotty_1.svg };
      var SResizeHandleView = class SResizeHandleView {
        render(handle, context) {
          const position = this.getPosition(handle);
          if (position !== void 0) {
            const node = JSX.createElement("circle", { "class-sprotty-resize-handle": true, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
            (0, sprotty_1.setAttr)(node, "data-kind", handle.location);
            return node;
          }
          return JSX.createElement("g", null);
        }
        getPosition(handle) {
          const parent = handle.parent;
          if ((0, model_1.isResizable)(parent)) {
            if (handle.location === model_1.ResizeHandleLocation.TopLeft) {
              return { x: 0, y: 0 };
            } else if (handle.location === model_1.ResizeHandleLocation.TopRight) {
              return { x: parent.bounds.width, y: 0 };
            } else if (handle.location === model_1.ResizeHandleLocation.BottomLeft) {
              return { x: 0, y: parent.bounds.height };
            } else if (handle.location === model_1.ResizeHandleLocation.BottomRight) {
              return { x: parent.bounds.width, y: parent.bounds.height };
            }
          }
          return void 0;
        }
        getRadius() {
          return 7;
        }
      };
      exports.SResizeHandleView = SResizeHandleView;
      exports.SResizeHandleView = SResizeHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], SResizeHandleView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-tool-feedback.js
  var require_edge_edit_tool_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-tool-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.drawFeedbackEdgeSource = exports.FeedbackEdgeRouteMovingMouseListener = exports.FeedbackEdgeSourceMovingMouseListener = exports.FeedbackEdgeTargetMovingMouseListener = exports.DrawFeedbackEdgeSourceCommand = exports.DrawFeedbackEdgeSourceAction = exports.SwitchRoutingModeCommand = exports.SwitchRoutingModeAction = exports.HideEdgeReconnectHandlesFeedbackCommand = exports.ShowEdgeReconnectHandlesFeedbackCommand = exports.HideEdgeReconnectHandlesFeedbackAction = exports.ShowEdgeReconnectHandlesFeedbackAction = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var viewpoint_util_1 = require_viewpoint_util();
      var snap_1 = require_snap2();
      var model_1 = require_model23();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_creation_tool_feedback_1 = require_edge_creation_tool_feedback();
      var ShowEdgeReconnectHandlesFeedbackAction;
      (function(ShowEdgeReconnectHandlesFeedbackAction2) {
        ShowEdgeReconnectHandlesFeedbackAction2.KIND = "showReconnectHandlesFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ShowEdgeReconnectHandlesFeedbackAction2.KIND);
        }
        ShowEdgeReconnectHandlesFeedbackAction2.is = is;
        function create(elementId) {
          return { kind: ShowEdgeReconnectHandlesFeedbackAction2.KIND, elementId };
        }
        ShowEdgeReconnectHandlesFeedbackAction2.create = create;
      })(ShowEdgeReconnectHandlesFeedbackAction || (exports.ShowEdgeReconnectHandlesFeedbackAction = ShowEdgeReconnectHandlesFeedbackAction = {}));
      var HideEdgeReconnectHandlesFeedbackAction;
      (function(HideEdgeReconnectHandlesFeedbackAction2) {
        HideEdgeReconnectHandlesFeedbackAction2.KIND = "hideReconnectHandlesFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, HideEdgeReconnectHandlesFeedbackAction2.KIND);
        }
        HideEdgeReconnectHandlesFeedbackAction2.is = is;
        function create() {
          return { kind: HideEdgeReconnectHandlesFeedbackAction2.KIND };
        }
        HideEdgeReconnectHandlesFeedbackAction2.create = create;
      })(HideEdgeReconnectHandlesFeedbackAction || (exports.HideEdgeReconnectHandlesFeedbackAction = HideEdgeReconnectHandlesFeedbackAction = {}));
      var ShowEdgeReconnectHandlesFeedbackCommand = class ShowEdgeReconnectHandlesFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const index = context.root.index;
          (0, gmodel_util_1.forEachElement)(index, gmodel_util_1.isRoutable, model_1.removeReconnectHandles);
          const routableElement = index.getById(this.action.elementId);
          if (routableElement && (0, gmodel_util_1.isRoutable)(routableElement)) {
            (0, model_1.addReconnectHandles)(routableElement);
          }
          return context.root;
        }
      };
      exports.ShowEdgeReconnectHandlesFeedbackCommand = ShowEdgeReconnectHandlesFeedbackCommand;
      ShowEdgeReconnectHandlesFeedbackCommand.KIND = ShowEdgeReconnectHandlesFeedbackAction.KIND;
      exports.ShowEdgeReconnectHandlesFeedbackCommand = ShowEdgeReconnectHandlesFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ShowEdgeReconnectHandlesFeedbackCommand);
      var HideEdgeReconnectHandlesFeedbackCommand = class HideEdgeReconnectHandlesFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const index = context.root.index;
          (0, gmodel_util_1.forEachElement)(index, gmodel_util_1.isRoutable, model_1.removeReconnectHandles);
          return context.root;
        }
      };
      exports.HideEdgeReconnectHandlesFeedbackCommand = HideEdgeReconnectHandlesFeedbackCommand;
      HideEdgeReconnectHandlesFeedbackCommand.KIND = HideEdgeReconnectHandlesFeedbackAction.KIND;
      exports.HideEdgeReconnectHandlesFeedbackCommand = HideEdgeReconnectHandlesFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], HideEdgeReconnectHandlesFeedbackCommand);
      var SwitchRoutingModeAction;
      (function(SwitchRoutingModeAction2) {
        SwitchRoutingModeAction2.KIND = "switchRoutingMode";
        function create(options) {
          return Object.assign(Object.assign({}, sprotty_1.SwitchEditModeAction.create(options)), { kind: SwitchRoutingModeAction2.KIND });
        }
        SwitchRoutingModeAction2.create = create;
      })(SwitchRoutingModeAction || (exports.SwitchRoutingModeAction = SwitchRoutingModeAction = {}));
      var SwitchRoutingModeCommand = class SwitchRoutingModeCommand extends sprotty_1.SwitchEditModeCommand {
        constructor(action) {
          super(Object.assign(Object.assign({}, action), { kind: sprotty_1.SwitchEditModeAction.KIND }));
        }
      };
      exports.SwitchRoutingModeCommand = SwitchRoutingModeCommand;
      SwitchRoutingModeCommand.KIND = SwitchRoutingModeAction.KIND;
      exports.SwitchRoutingModeCommand = SwitchRoutingModeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SwitchRoutingModeCommand);
      var DrawFeedbackEdgeSourceAction;
      (function(DrawFeedbackEdgeSourceAction2) {
        DrawFeedbackEdgeSourceAction2.KIND = "drawFeedbackEdgeSource";
        function is(object) {
          return sprotty_1.Action.hasKind(object, DrawFeedbackEdgeSourceAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "elementTypeId") && (0, sprotty_1.hasStringProp)(object, "targetId");
        }
        DrawFeedbackEdgeSourceAction2.is = is;
        function create(options) {
          return Object.assign({ kind: DrawFeedbackEdgeSourceAction2.KIND }, options);
        }
        DrawFeedbackEdgeSourceAction2.create = create;
      })(DrawFeedbackEdgeSourceAction || (exports.DrawFeedbackEdgeSourceAction = DrawFeedbackEdgeSourceAction = {}));
      var DrawFeedbackEdgeSourceCommand = class DrawFeedbackEdgeSourceCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          drawFeedbackEdgeSource(context, this.action.targetId, this.action.elementTypeId);
          return context.root;
        }
      };
      exports.DrawFeedbackEdgeSourceCommand = DrawFeedbackEdgeSourceCommand;
      DrawFeedbackEdgeSourceCommand.KIND = DrawFeedbackEdgeSourceAction.KIND;
      exports.DrawFeedbackEdgeSourceCommand = DrawFeedbackEdgeSourceCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DrawFeedbackEdgeSourceCommand);
      var FeedbackEdgeTargetMovingMouseListener = class extends edge_creation_tool_feedback_1.FeedbackEdgeEndMovingMouseListener {
        constructor(anchorRegistry, feedbackDispatcher) {
          super(anchorRegistry, feedbackDispatcher);
        }
      };
      exports.FeedbackEdgeTargetMovingMouseListener = FeedbackEdgeTargetMovingMouseListener;
      var FeedbackEdgeSourceMovingMouseListener = class extends sprotty_1.MouseListener {
        constructor(anchorRegistry, feedbackDispatcher) {
          super();
          this.anchorRegistry = anchorRegistry;
          this.feedbackDispatcher = feedbackDispatcher;
        }
        mouseMove(target, event) {
          const root = target.root;
          const edgeEnd = root.index.getById((0, dangling_edge_feedback_1.feedbackEdgeEndId)(root));
          if (!(edgeEnd instanceof dangling_edge_feedback_1.FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
            return [];
          }
          const edge = edgeEnd.feedbackEdge;
          const position = (0, viewpoint_util_1.getAbsolutePosition)(edgeEnd, event);
          const endAtMousePosition = (0, sprotty_1.findChildrenAtPosition)(target.root, position).find((element) => (0, sprotty_1.isConnectable)(element) && element.canConnect(edge, "source"));
          if (endAtMousePosition instanceof sprotty_1.GConnectableElement && edge.target && (0, sprotty_1.isBoundsAware)(edge.target)) {
            const anchor = this.computeAbsoluteAnchor(endAtMousePosition, sprotty_1.Bounds.center(edge.target.bounds));
            if (sprotty_1.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
              this.feedbackDispatcher.registerFeedback(this, [
                sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], { animate: false })
              ]);
            }
          } else {
            this.feedbackDispatcher.registerFeedback(this, [
              sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], { animate: false })
            ]);
          }
          return [];
        }
        computeAbsoluteAnchor(element, referencePoint, offset) {
          const anchorComputer = this.anchorRegistry.get(sprotty_1.PolylineEdgeRouter.KIND, element.anchorKind);
          let anchor = anchorComputer.getAnchor(element, referencePoint, offset);
          if (element.parent !== element.root) {
            const parent = (0, sprotty_1.findParentByFeature)(element.parent, sprotty_1.isBoundsAware);
            if (parent) {
              const absoluteParentPosition = (0, viewpoint_util_1.toAbsoluteBounds)(parent);
              anchor = sprotty_1.Point.add(absoluteParentPosition, anchor);
            }
          }
          return anchor;
        }
        dispose() {
          this.feedbackDispatcher.deregisterFeedback(this);
        }
      };
      exports.FeedbackEdgeSourceMovingMouseListener = FeedbackEdgeSourceMovingMouseListener;
      var FeedbackEdgeRouteMovingMouseListener = class extends sprotty_1.MouseListener {
        constructor(edgeRouterRegistry, snapper) {
          super();
          this.edgeRouterRegistry = edgeRouterRegistry;
          this.snapper = snapper;
          this.pointPositionUpdater = new snap_1.PointPositionUpdater(snapper);
        }
        mouseDown(target, event) {
          const result = [];
          if (event.button === 0) {
            const routingHandle = (0, sprotty_1.findParentByFeature)(target, gmodel_util_1.isRoutingHandle);
            if (routingHandle !== void 0) {
              result.push(SwitchRoutingModeAction.create({ elementsToActivate: [target.id] }));
              this.pointPositionUpdater.updateLastDragPosition({ x: event.pageX, y: event.pageY });
            } else {
              this.pointPositionUpdater.resetPosition();
            }
          }
          return result;
        }
        mouseMove(target, event) {
          const result = [];
          if (event.buttons === 0) {
            return this.mouseUp(target, event);
          }
          const positionUpdate = this.pointPositionUpdater.updatePosition(target, { x: event.pageX, y: event.pageY }, !event.altKey);
          if (positionUpdate) {
            const moveActions = this.handleMoveOnClient(target, positionUpdate, !event.altKey);
            result.push(...moveActions);
          }
          return result;
        }
        handleMoveOnClient(target, positionUpdate, isSnap) {
          const handleMoves = [];
          target.root.index.all().filter((element) => (0, sprotty_1.isSelected)(element)).forEach((element) => {
            if ((0, gmodel_util_1.isRoutingHandle)(element)) {
              const elementMove = this.toElementMove(element, positionUpdate, isSnap);
              if (elementMove) {
                handleMoves.push(elementMove);
              }
            }
          });
          if (handleMoves.length > 0) {
            return [sprotty_1.MoveAction.create(handleMoves, { animate: false })];
          }
          return [];
        }
        toElementMove(element, positionDelta, isSnap) {
          const point = this.getHandlePosition(element);
          if (point !== void 0) {
            const snappedPoint = this.getSnappedHandlePosition(element, point, isSnap);
            return {
              elementId: element.id,
              fromPosition: point,
              toPosition: {
                x: snappedPoint.x + positionDelta.x,
                y: snappedPoint.y + positionDelta.y
              }
            };
          }
          return void 0;
        }
        getSnappedHandlePosition(element, point, isSnap) {
          if (this.snapper && isSnap) {
            return this.snapper.snap(point, element);
          }
          return point;
        }
        getHandlePosition(handle) {
          if (this.edgeRouterRegistry) {
            const parent = handle.parent;
            if (!(0, gmodel_util_1.isRoutable)(parent)) {
              return void 0;
            }
            const router = this.edgeRouterRegistry.get(parent.routerKind);
            const route = router.route(parent);
            return router.getHandlePosition(parent, route, handle);
          }
          return void 0;
        }
        mouseUp(_target, _event) {
          this.pointPositionUpdater.resetPosition();
          return [];
        }
        decorate(vnode, _element) {
          return vnode;
        }
      };
      exports.FeedbackEdgeRouteMovingMouseListener = FeedbackEdgeRouteMovingMouseListener;
      function drawFeedbackEdgeSource(context, targetId, elementTypeId) {
        const root = context.root;
        const targetChild = root.index.getById(targetId);
        if (!targetChild) {
          return;
        }
        const target = (0, sprotty_1.findParentByFeature)(targetChild, sprotty_1.isConnectable);
        if (!target || !(0, sprotty_1.isBoundsAware)(target)) {
          return;
        }
        const edgeEnd = new dangling_edge_feedback_1.FeedbackEdgeEnd(target.id, elementTypeId);
        edgeEnd.id = (0, dangling_edge_feedback_1.feedbackEdgeEndId)(root);
        edgeEnd.position = { x: target.bounds.x, y: target.bounds.y };
        const feedbackEdgeSchema = {
          type: "edge",
          id: (0, dangling_edge_feedback_1.feedbackEdgeId)(root),
          sourceId: edgeEnd.id,
          targetId: target.id,
          opacity: 0.3
        };
        const feedbackEdge = context.modelFactory.createElement(feedbackEdgeSchema);
        if ((0, gmodel_util_1.isRoutable)(feedbackEdge)) {
          edgeEnd.feedbackEdge = feedbackEdge;
          root.add(edgeEnd);
          root.add(feedbackEdge);
        }
      }
      exports.drawFeedbackEdgeSource = drawFeedbackEdgeSource;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-tool.js
  var require_edge_edit_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var EdgeEditTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeEditListener = exports.EdgeEditTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var selection_service_1 = require_selection_service();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model23();
      var base_tools_1 = require_base_tools();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_edit_tool_feedback_1 = require_edge_edit_tool_feedback();
      var EdgeEditTool = EdgeEditTool_1 = class EdgeEditTool extends base_tools_1.BaseEditTool {
        get id() {
          return EdgeEditTool_1.ID;
        }
        enable() {
          this.edgeEditListener = new EdgeEditListener(this);
          this.feedbackEdgeSourceMovingListener = new edge_edit_tool_feedback_1.FeedbackEdgeSourceMovingMouseListener(this.anchorRegistry, this.feedbackDispatcher);
          this.feedbackEdgeTargetMovingListener = new edge_edit_tool_feedback_1.FeedbackEdgeTargetMovingMouseListener(this.anchorRegistry, this.feedbackDispatcher);
          this.feedbackMovingListener = new edge_edit_tool_feedback_1.FeedbackEdgeRouteMovingMouseListener(this.edgeRouterRegistry, this.snapper);
          this.toDisposeOnDisable.push(sprotty_1.Disposable.create(() => this.edgeEditListener.reset()), this.mouseTool.registerListener(this.edgeEditListener), this.feedbackEdgeSourceMovingListener, this.feedbackEdgeTargetMovingListener, this.selectionService.onSelectionChanged((change) => this.edgeEditListener.selectionChanged(change.root, change.selectedElements)));
        }
        registerFeedbackListeners() {
          this.mouseTool.register(this.feedbackMovingListener);
          this.mouseTool.register(this.feedbackEdgeSourceMovingListener);
          this.mouseTool.register(this.feedbackEdgeTargetMovingListener);
        }
        deregisterFeedbackListeners() {
          this.feedbackEdgeSourceMovingListener.dispose();
          this.feedbackEdgeTargetMovingListener.dispose();
          this.mouseTool.deregister(this.feedbackEdgeSourceMovingListener);
          this.mouseTool.deregister(this.feedbackEdgeTargetMovingListener);
          this.mouseTool.deregister(this.feedbackMovingListener);
        }
      };
      exports.EdgeEditTool = EdgeEditTool;
      EdgeEditTool.ID = "glsp.edge-edit-tool";
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], EdgeEditTool.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.AnchorComputerRegistry),
        __metadata("design:type", sprotty_1.AnchorComputerRegistry)
      ], EdgeEditTool.prototype, "anchorRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], EdgeEditTool.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], EdgeEditTool.prototype, "snapper", void 0);
      exports.EdgeEditTool = EdgeEditTool = EdgeEditTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeEditTool);
      var EdgeEditListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(tool) {
          super();
          this.tool = tool;
        }
        isValidEdge(edge) {
          return edge !== void 0 && edge.id !== (0, dangling_edge_feedback_1.feedbackEdgeId)(edge.root) && (0, sprotty_1.isSelected)(edge);
        }
        setEdgeSelected(edge) {
          if (this.edge && this.edge.id !== edge.id) {
            this.reset();
          }
          this.edge = edge;
          const feedbackActions = [];
          if ((0, sprotty_1.canEditRouting)(edge)) {
            feedbackActions.push(edge_edit_tool_feedback_1.SwitchRoutingModeAction.create({ elementsToActivate: [this.edge.id] }));
          }
          if ((0, model_1.isReconnectable)(edge)) {
            feedbackActions.push(edge_edit_tool_feedback_1.ShowEdgeReconnectHandlesFeedbackAction.create(this.edge.id));
          }
          this.tool.registerFeedback(feedbackActions);
        }
        isEdgeSelected() {
          return this.edge !== void 0 && (0, sprotty_1.isSelected)(this.edge);
        }
        setReconnectHandleSelected(edge, reconnectHandle) {
          if (this.edge && this.edge.target && this.edge.source) {
            if ((0, model_1.isSourceRoutingHandle)(edge, reconnectHandle)) {
              this.tool.registerFeedback([
                edge_edit_tool_feedback_1.HideEdgeReconnectHandlesFeedbackAction.create(),
                (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_RECONNECT),
                edge_edit_tool_feedback_1.DrawFeedbackEdgeSourceAction.create({ elementTypeId: this.edge.type, targetId: this.edge.targetId })
              ]);
              this.reconnectMode = "NEW_SOURCE";
            } else if ((0, model_1.isTargetRoutingHandle)(edge, reconnectHandle)) {
              this.tool.registerFeedback([
                edge_edit_tool_feedback_1.HideEdgeReconnectHandlesFeedbackAction.create(),
                (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_CREATION_TARGET),
                dangling_edge_feedback_1.DrawFeedbackEdgeAction.create({ elementTypeId: this.edge.type, sourceId: this.edge.sourceId })
              ]);
              this.reconnectMode = "NEW_TARGET";
            }
          }
        }
        isReconnecting() {
          return this.reconnectMode !== void 0;
        }
        isReconnectingNewSource() {
          return this.reconnectMode === "NEW_SOURCE";
        }
        setRoutingHandleSelected(edge, routingHandle) {
          if (this.edge && this.edge.target && this.edge.source) {
            this.routingHandle = routingHandle;
          }
        }
        requiresReconnect(sourceId, targetId) {
          return this.edge !== void 0 && (this.edge.sourceId !== sourceId || this.edge.targetId !== targetId);
        }
        setNewConnectable(connectable) {
          this.newConnectable = connectable;
        }
        isReadyToReconnect() {
          return this.edge && this.isReconnecting() && this.newConnectable !== void 0;
        }
        isReadyToReroute() {
          return this.routingHandle !== void 0;
        }
        mouseDown(target, event) {
          const result = super.mouseDown(target, event);
          if (event.button === 0) {
            const reconnectHandle = (0, sprotty_1.findParentByFeature)(target, model_1.isReconnectHandle);
            const routingHandle = !reconnectHandle ? (0, sprotty_1.findParentByFeature)(target, gmodel_util_1.isRoutingHandle) : void 0;
            const edge = (0, sprotty_1.findParentByFeature)(target, gmodel_util_1.isRoutable);
            if (this.isEdgeSelected() && edge && reconnectHandle) {
              this.setReconnectHandleSelected(edge, reconnectHandle);
            } else if (this.isEdgeSelected() && edge && routingHandle) {
              this.setRoutingHandleSelected(edge, routingHandle);
            } else if (this.isValidEdge(edge)) {
              this.tool.registerFeedbackListeners();
              this.setEdgeSelected(edge);
            }
          } else if (event.button === 2) {
            this.reset();
          }
          return result;
        }
        mouseMove(target, event) {
          const result = super.mouseMove(target, event);
          if (this.isMouseDrag) {
            this.setNewConnectable(void 0);
          }
          return result;
        }
        mouseUp(target, event) {
          const result = super.mouseUp(target, event);
          if (!this.isReadyToReconnect() && !this.isReadyToReroute()) {
            return result;
          }
          if (this.edge && this.newConnectable) {
            const sourceElementId = this.isReconnectingNewSource() ? this.newConnectable.id : this.edge.sourceId;
            const targetElementId = this.isReconnectingNewSource() ? this.edge.targetId : this.newConnectable.id;
            if (this.requiresReconnect(sourceElementId, targetElementId)) {
              result.push(sprotty_1.ReconnectEdgeOperation.create({ edgeElementId: this.edge.id, sourceElementId, targetElementId }));
            }
            this.reset();
          } else if (this.edge && this.routingHandle) {
            const latestEdge = target.index.getById(this.edge.id);
            if (latestEdge && (0, gmodel_util_1.isRoutable)(latestEdge)) {
              const newRoutingPoints = (0, gmodel_util_1.calcElementAndRoutingPoints)(latestEdge, this.tool.edgeRouterRegistry);
              result.push(sprotty_1.ChangeRoutingPointsOperation.create([newRoutingPoints]));
              this.routingHandle = void 0;
            }
          }
          return result;
        }
        mouseOver(target, _event) {
          if (this.edge && this.isReconnecting()) {
            const currentTarget = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isConnectable);
            if (!this.newConnectable || currentTarget !== this.newConnectable) {
              this.setNewConnectable(currentTarget);
              if (currentTarget) {
                if (this.reconnectMode === "NEW_SOURCE" && currentTarget.canConnect(this.edge, "source") || this.reconnectMode === "NEW_TARGET" && currentTarget.canConnect(this.edge, "target")) {
                  this.tool.registerFeedback([(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_RECONNECT)]);
                  return [];
                }
              }
              this.tool.registerFeedback([(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED)]);
            }
          }
          return [];
        }
        selectionChanged(root, selectedElements) {
          if (this.edge) {
            if (selectedElements.indexOf(this.edge.id) > -1) {
              return;
            }
            if (this.isReconnecting()) {
              return;
            }
            for (const elementId of selectedElements.reverse()) {
              const element = root.index.getById(elementId);
              if (element) {
                const edge = (0, sprotty_1.findParentByFeature)(element, gmodel_util_1.isRoutable);
                if (this.isValidEdge(edge)) {
                  this.setEdgeSelected(edge);
                  return;
                }
              }
            }
            this.reset();
          }
        }
        reset() {
          this.resetFeedback();
          this.resetData();
        }
        resetData() {
          this.edge = void 0;
          this.reconnectMode = void 0;
          this.newConnectable = void 0;
          this.routingHandle = void 0;
        }
        resetFeedback() {
          const result = [];
          if (this.edge) {
            result.push(edge_edit_tool_feedback_1.SwitchRoutingModeAction.create({ elementsToDeactivate: [this.edge.id] }));
          }
          result.push(...[edge_edit_tool_feedback_1.HideEdgeReconnectHandlesFeedbackAction.create(), (0, css_feedback_1.cursorFeedbackAction)(), dangling_edge_feedback_1.RemoveFeedbackEdgeAction.create()]);
          this.tool.deregisterFeedback(void 0, result);
          this.tool.deregisterFeedbackListeners();
        }
      };
      exports.EdgeEditListener = EdgeEditListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-tool.js
  var require_marquee_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var MarqueeTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarqueeKeyListener = exports.MarqueeTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var tool_1 = require_tool();
      var base_tools_1 = require_base_tools();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var MarqueeTool = MarqueeTool_1 = class MarqueeTool extends base_tools_1.BaseEditTool {
        constructor() {
          super(...arguments);
          this.marqueeKeyListener = new MarqueeKeyListener();
        }
        get id() {
          return MarqueeTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.marqueeKeyListener));
        }
      };
      exports.MarqueeTool = MarqueeTool;
      MarqueeTool.ID = "glsp.marquee-tool";
      exports.MarqueeTool = MarqueeTool = MarqueeTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MarqueeTool);
      var MarqueeKeyListener = class MarqueeKeyListener extends sprotty_1.KeyListener {
        keyDown(_element, event) {
          if (event.shiftKey) {
            return [tool_1.EnableToolsAction.create([marquee_mouse_tool_1.MarqueeMouseTool.ID])];
          }
          return [];
        }
      };
      exports.MarqueeKeyListener = MarqueeKeyListener;
      exports.MarqueeKeyListener = MarqueeKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], MarqueeKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/model.js
  var require_model24 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarqueeNode = void 0;
      var sprotty_1 = require_lib5();
      var MarqueeNode = class extends sprotty_1.RectangularNode {
      };
      exports.MarqueeNode = MarqueeNode;
      MarqueeNode.DEFAULT_FEATURES = [sprotty_1.boundsFeature];
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/view.js
  var require_view4 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarqueeView = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var JSX = { createElement: sprotty_1.svg };
      var MarqueeView = class MarqueeView extends sprotty_1.RectangularNodeView {
        render(node, context) {
          const graph = JSX.createElement(
            "g",
            null,
            JSX.createElement("rect", { "class-sprotty-node": true, "class-marquee": true, x: node.startPoint.x - node.endPoint.x <= 0 ? node.startPoint.x : node.endPoint.x, y: node.startPoint.y - node.endPoint.y <= 0 ? node.startPoint.y : node.endPoint.y, rx: 0, ry: 0, width: Math.abs(node.startPoint.x - node.endPoint.x), height: Math.abs(node.startPoint.y - node.endPoint.y) })
          );
          return graph;
        }
      };
      exports.MarqueeView = MarqueeView;
      exports.MarqueeView = MarqueeView = __decorate([
        (0, inversify_1.injectable)()
      ], MarqueeView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-tool.js
  var require_node_creation_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var NodeCreationTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NodeCreationToolMouseListener = exports.NodeCreationTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var viewpoint_util_1 = require_viewpoint_util();
      var model_1 = require_model20();
      var base_tools_1 = require_base_tools();
      var NodeCreationTool = NodeCreationTool_1 = class NodeCreationTool extends base_tools_1.BaseCreationTool {
        constructor() {
          super(...arguments);
          this.isTriggerAction = sprotty_1.TriggerNodeCreationAction.is;
        }
        get id() {
          return NodeCreationTool_1.ID;
        }
        doEnable() {
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(new NodeCreationToolMouseListener(this.triggerAction, this)), this.registerFeedback([(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.NODE_CREATION)], this, [(0, css_feedback_1.cursorFeedbackAction)()]));
        }
      };
      exports.NodeCreationTool = NodeCreationTool;
      NodeCreationTool.ID = "tool_create_node";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], NodeCreationTool.prototype, "snapper", void 0);
      exports.NodeCreationTool = NodeCreationTool = NodeCreationTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], NodeCreationTool);
      var NodeCreationToolMouseListener = class NodeCreationToolMouseListener extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(triggerAction, tool) {
          super();
          this.triggerAction = triggerAction;
          this.tool = tool;
        }
        creationAllowed(elementTypeId) {
          return this.container && this.container.isContainableElement(elementTypeId);
        }
        get elementTypeId() {
          return this.triggerAction.elementTypeId;
        }
        nonDraggingMouseUp(target, event) {
          const result = [];
          if (this.container === void 0) {
            this.mouseOver(target, event);
          }
          if (this.creationAllowed(this.elementTypeId)) {
            const containerId = this.container ? this.container.id : void 0;
            let location2 = (0, viewpoint_util_1.getAbsolutePosition)(target, event);
            if (this.tool.snapper) {
              const elementProxy = new sprotty_1.GNode();
              elementProxy.size = { width: 0, height: 0 };
              location2 = this.tool.snapper.snap(location2, elementProxy);
            }
            result.push(sprotty_1.CreateNodeOperation.create(this.elementTypeId, { location: location2, containerId, args: this.triggerAction.args }));
            if (!(0, sprotty_1.isCtrlOrCmd)(event)) {
              result.push(tool_1.EnableDefaultToolsAction.create());
            }
          }
          return result;
        }
        mouseOver(target, event) {
          const currentContainer = (0, sprotty_1.findParentByFeature)(target, model_1.isContainable);
          if (!this.container || currentContainer !== this.container) {
            this.container = currentContainer;
            const feedback = this.creationAllowed(this.elementTypeId) ? (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.NODE_CREATION) : (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED);
            this.tool.registerFeedback([feedback]);
          }
          return [];
        }
      };
      exports.NodeCreationToolMouseListener = NodeCreationToolMouseListener;
      exports.NodeCreationToolMouseListener = NodeCreationToolMouseListener = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [Object, NodeCreationTool])
      ], NodeCreationToolMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/undo-redo/undo-redo-key-listener.js
  var require_undo_redo_key_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/undo-redo/undo-redo-key-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPUndoRedoKeyListener = void 0;
      var sprotty_1 = require_lib5();
      var GLSPUndoRedoKeyListener = class extends sprotty_1.KeyListener {
        keyDown(element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd")) {
            return [sprotty_1.UndoAction.create()];
          }
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd", "shift") || !(0, sprotty_1.isMac)() && (0, sprotty_1.matchesKeystroke)(event, "KeyY", "ctrlCmd")) {
            return [sprotty_1.RedoAction.create()];
          }
          return [];
        }
      };
      exports.GLSPUndoRedoKeyListener = GLSPUndoRedoKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/marker.js
  var require_marker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/marker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.collectIssueMarkers = exports.MarkerPredicates = void 0;
      var sprotty_1 = require_lib5();
      var issue_marker_1 = require_issue_marker();
      var MarkerPredicates;
      (function(MarkerPredicates2) {
        MarkerPredicates2.ALL = () => true;
        MarkerPredicates2.ERRORS = (marker) => hasIssueWithSeverity(marker, sprotty_1.MarkerKind.ERROR);
        MarkerPredicates2.WARNINGS = (marker) => hasIssueWithSeverity(marker, sprotty_1.MarkerKind.WARNING);
        MarkerPredicates2.INFOS = (marker) => hasIssueWithSeverity(marker, sprotty_1.MarkerKind.INFO);
        function hasIssueWithSeverity(marker, severity) {
          return marker.issues.find((issue) => issue.severity === severity) !== void 0;
        }
        MarkerPredicates2.hasIssueWithSeverity = hasIssueWithSeverity;
      })(MarkerPredicates || (exports.MarkerPredicates = MarkerPredicates = {}));
      function collectIssueMarkers(root) {
        const markers = [];
        for (const child of root.children) {
          if (child instanceof issue_marker_1.GIssueMarker) {
            markers.push(child);
          }
          markers.push(...collectIssueMarkers(child));
        }
        return markers;
      }
      exports.collectIssueMarkers = collectIssueMarkers;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/validation/marker-navigator.js
  var require_marker_navigator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/validation/marker-navigator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarkerNavigatorKeyListener = exports.MarkerNavigatorContextMenuItemProvider = exports.NavigateToMarkerActionHandler = exports.MarkerNavigator = exports.LeftToRightTopToBottomComparator = exports.GModelElementComparator = exports.NavigateToMarkerAction = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var action_dispatcher_1 = require_action_dispatcher2();
      var selection_service_1 = require_selection_service();
      var gmodel_util_1 = require_gmodel_util();
      var marker_1 = require_marker();
      var NavigateToMarkerAction;
      (function(NavigateToMarkerAction2) {
        NavigateToMarkerAction2.KIND = "navigateToMarker";
        function is(object) {
          return sprotty_1.Action.hasKind(object, NavigateToMarkerAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "direction") && (0, sprotty_1.hasArrayProp)(object, "severities");
        }
        NavigateToMarkerAction2.is = is;
        function create(options) {
          return Object.assign({ kind: NavigateToMarkerAction2.KIND, direction: "next", severities: MarkerNavigator.ALL_SEVERITIES }, options);
        }
        NavigateToMarkerAction2.create = create;
      })(NavigateToMarkerAction || (exports.NavigateToMarkerAction = NavigateToMarkerAction = {}));
      var GModelElementComparator = class {
        compare(_one, _other) {
          return 0;
        }
      };
      exports.GModelElementComparator = GModelElementComparator;
      var LeftToRightTopToBottomComparator = class LeftToRightTopToBottomComparator {
        compare(one, other) {
          const boundsOne = (0, sprotty_1.findParentByFeature)(one, gmodel_util_1.isSelectableAndBoundsAware);
          const boundsOther = (0, sprotty_1.findParentByFeature)(other, gmodel_util_1.isSelectableAndBoundsAware);
          if (boundsOne && boundsOther) {
            if (boundsOne.bounds.y !== boundsOther.bounds.y) {
              return boundsOne.bounds.y - boundsOther.bounds.y;
            }
            if (boundsOne.bounds.x !== boundsOther.bounds.x) {
              return boundsOne.bounds.x - boundsOther.bounds.x;
            }
          }
          return 0;
        }
      };
      exports.LeftToRightTopToBottomComparator = LeftToRightTopToBottomComparator;
      exports.LeftToRightTopToBottomComparator = LeftToRightTopToBottomComparator = __decorate([
        (0, inversify_1.injectable)()
      ], LeftToRightTopToBottomComparator);
      var MarkerNavigator = class MarkerNavigator {
        next(root, current, predicate = marker_1.MarkerPredicates.ALL) {
          const markers = this.getMarkers(root, predicate);
          if (current === void 0) {
            return markers.length > 0 ? markers[0] : void 0;
          }
          return markers[this.getNextIndex(current, markers) % markers.length];
        }
        previous(root, current, predicate = marker_1.MarkerPredicates.ALL) {
          const markers = this.getMarkers(root, predicate);
          if (current === void 0) {
            return markers.length > 0 ? markers[0] : void 0;
          }
          return markers[this.getPreviousIndex(current, markers) % markers.length];
        }
        getMarkers(root, predicate) {
          const markers = (0, marker_1.collectIssueMarkers)(root);
          return markers.filter(predicate).sort(this.markerComparator.compare);
        }
        getNextIndex(current, markers) {
          for (let index = 0; index < markers.length; index++) {
            if (this.markerComparator.compare(markers[index], current) > 0) {
              return index;
            }
          }
          return 0;
        }
        getPreviousIndex(current, markers) {
          for (let index = markers.length - 1; index >= 0; index--) {
            if (this.markerComparator.compare(markers[index], current) < 0) {
              return index;
            }
          }
          return markers.length - 1;
        }
      };
      exports.MarkerNavigator = MarkerNavigator;
      MarkerNavigator.ALL_SEVERITIES = ["error", "warning", "info"];
      __decorate([
        (0, inversify_1.inject)(GModelElementComparator),
        __metadata("design:type", GModelElementComparator)
      ], MarkerNavigator.prototype, "markerComparator", void 0);
      exports.MarkerNavigator = MarkerNavigator = __decorate([
        (0, inversify_1.injectable)()
      ], MarkerNavigator);
      var NavigateToMarkerActionHandler = class NavigateToMarkerActionHandler {
        handle(action) {
          const selected = this.getSelectedElements(action);
          const target = this.getTarget(action, selected);
          const selectableTarget = target ? (0, sprotty_1.findParentByFeature)(target, sprotty_1.isSelectable) : void 0;
          if (selectableTarget) {
            const deselectedElementsIDs = selected.map((e) => e.id).filter((id) => id !== selectableTarget.id);
            this.actionDispatcher.dispatch(sprotty_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs }));
            this.actionDispatcher.dispatch(sprotty_1.CenterAction.create([selectableTarget.id]));
          }
        }
        getSelectedElements(action) {
          if (action.selectedElementIds && action.selectedElementIds.length > 0) {
            return (0, gmodel_util_1.getElements)(this.selectionService.getModelRoot().index, action.selectedElementIds, sprotty_1.isSelectable);
          }
          return this.selectionService.getSelectedElements();
        }
        getTarget(action, selected) {
          const root = this.selectionService.getModelRoot();
          const target = selected.sort(this.markerComparator.compare).find(sprotty_1.isBoundsAware);
          if (action.direction === "previous") {
            return this.markerNavigator.previous(root, target, (marker) => this.matchesSeverities(action, marker));
          } else {
            return this.markerNavigator.next(root, target, (marker) => this.matchesSeverities(action, marker));
          }
        }
        matchesSeverities(action, marker) {
          return marker.issues.find((issue) => action.severities.includes(issue.severity)) !== void 0;
        }
      };
      exports.NavigateToMarkerActionHandler = NavigateToMarkerActionHandler;
      __decorate([
        (0, inversify_1.inject)(GModelElementComparator),
        __metadata("design:type", GModelElementComparator)
      ], NavigateToMarkerActionHandler.prototype, "markerComparator", void 0);
      __decorate([
        (0, inversify_1.inject)(MarkerNavigator),
        __metadata("design:type", MarkerNavigator)
      ], NavigateToMarkerActionHandler.prototype, "markerNavigator", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], NavigateToMarkerActionHandler.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], NavigateToMarkerActionHandler.prototype, "actionDispatcher", void 0);
      exports.NavigateToMarkerActionHandler = NavigateToMarkerActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], NavigateToMarkerActionHandler);
      var MarkerNavigatorContextMenuItemProvider = class MarkerNavigatorContextMenuItemProvider {
        getItems(root, lastMousePosition) {
          const selectedElementIds = Array.from(this.selectionService.getSelectedElementIDs());
          const hasMarkers = (0, marker_1.collectIssueMarkers)(root).length > 0;
          return Promise.resolve([
            {
              id: "navigate",
              label: "Go to",
              group: "navigate",
              actions: [],
              children: [
                {
                  id: "next-marker",
                  label: "Next marker",
                  group: "marker",
                  actions: [NavigateToMarkerAction.create({ direction: "next", selectedElementIds })],
                  isEnabled: () => hasMarkers
                },
                {
                  id: "previous-marker",
                  label: "Previous marker",
                  group: "marker",
                  actions: [NavigateToMarkerAction.create({ direction: "previous", selectedElementIds })],
                  isEnabled: () => hasMarkers
                }
              ]
            }
          ]);
        }
      };
      exports.MarkerNavigatorContextMenuItemProvider = MarkerNavigatorContextMenuItemProvider;
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], MarkerNavigatorContextMenuItemProvider.prototype, "selectionService", void 0);
      exports.MarkerNavigatorContextMenuItemProvider = MarkerNavigatorContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], MarkerNavigatorContextMenuItemProvider);
      var MarkerNavigatorKeyListener = class MarkerNavigatorKeyListener extends sprotty_1.KeyListener {
        keyDown(_element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Period", "ctrl")) {
            return [NavigateToMarkerAction.create({ direction: "next" })];
          } else if ((0, sprotty_1.matchesKeystroke)(event, "Comma", "ctrl")) {
            return [NavigateToMarkerAction.create({ direction: "previous" })];
          }
          return [];
        }
      };
      exports.MarkerNavigatorKeyListener = MarkerNavigatorKeyListener;
      exports.MarkerNavigatorKeyListener = MarkerNavigatorKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], MarkerNavigatorKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/validation/validate.js
  var require_validate = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/validation/validate.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteMarkersCommand = exports.ApplyMarkersCommand = exports.ApplyMarkersAction = exports.SetMarkersActionHandler = exports.ExternalMarkerManager = exports.ValidationFeedbackEmitter = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var editor_context_service_1 = require_editor_context_service();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var issue_marker_1 = require_issue_marker();
      var ValidationFeedbackEmitter = class ValidationFeedbackEmitter {
        constructor() {
          this.registeredFeedbackByReason = /* @__PURE__ */ new Map();
        }
        /**
         * Register the action that should be emitted for visualizing validation feedback.
         * @param action the action that should be emitted when the model is updated and that will visualize the model validation feedback.
         * @param reason the reason for this validation feedback.
         */
        registerValidationFeedbackAction(action, reason = "") {
          const previousFeedbackWithSameReason = this.registeredFeedbackByReason.get(reason);
          if (previousFeedbackWithSameReason) {
            this.feedbackActionDispatcher.deregisterFeedback(this, [previousFeedbackWithSameReason]);
            const deleteMarkersAction = sprotty_1.DeleteMarkersAction.create(previousFeedbackWithSameReason.markers);
            this.actionDispatcher().then((dispatcher) => dispatcher.dispatch(deleteMarkersAction));
          }
          this.registeredFeedbackByReason.set(reason, action);
          this.feedbackActionDispatcher.registerFeedback(this, [...this.registeredFeedbackByReason.values()]);
        }
      };
      exports.ValidationFeedbackEmitter = ValidationFeedbackEmitter;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], ValidationFeedbackEmitter.prototype, "feedbackActionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcherProvider),
        __metadata("design:type", Function)
      ], ValidationFeedbackEmitter.prototype, "actionDispatcher", void 0);
      exports.ValidationFeedbackEmitter = ValidationFeedbackEmitter = __decorate([
        (0, inversify_1.injectable)()
      ], ValidationFeedbackEmitter);
      var ExternalMarkerManager = class ExternalMarkerManager {
        connect(actionDispatcher) {
          this.actionDispatcher = actionDispatcher;
        }
        removeMarkers(markers) {
          if (this.actionDispatcher) {
            this.actionDispatcher.dispatch(sprotty_1.DeleteMarkersAction.create(markers));
          }
        }
      };
      exports.ExternalMarkerManager = ExternalMarkerManager;
      exports.ExternalMarkerManager = ExternalMarkerManager = __decorate([
        (0, inversify_1.injectable)()
      ], ExternalMarkerManager);
      var SetMarkersActionHandler = class SetMarkersActionHandler {
        handle(action) {
          const markers = action.markers;
          this.setMarkers(markers, action.reason);
        }
        async setMarkers(markers, reason) {
          var _a;
          const uri = this.editorContextService.sourceUri;
          (_a = this.externalMarkerManager) === null || _a === void 0 ? void 0 : _a.setMarkers(markers, reason, uri);
          const applyMarkersAction = ApplyMarkersAction.create(markers);
          this.validationFeedbackEmitter.registerValidationFeedbackAction(applyMarkersAction, reason);
        }
      };
      exports.SetMarkersActionHandler = SetMarkersActionHandler;
      __decorate([
        (0, inversify_1.inject)(ValidationFeedbackEmitter),
        __metadata("design:type", ValidationFeedbackEmitter)
      ], SetMarkersActionHandler.prototype, "validationFeedbackEmitter", void 0);
      __decorate([
        (0, inversify_1.inject)(ExternalMarkerManager),
        (0, inversify_1.optional)(),
        __metadata("design:type", ExternalMarkerManager)
      ], SetMarkersActionHandler.prototype, "externalMarkerManager", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], SetMarkersActionHandler.prototype, "editorContextService", void 0);
      exports.SetMarkersActionHandler = SetMarkersActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], SetMarkersActionHandler);
      var ApplyMarkersAction;
      (function(ApplyMarkersAction2) {
        ApplyMarkersAction2.KIND = "applyMarkers";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ApplyMarkersAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "markers");
        }
        ApplyMarkersAction2.is = is;
        function create(markers) {
          return {
            kind: ApplyMarkersAction2.KIND,
            markers
          };
        }
        ApplyMarkersAction2.create = create;
      })(ApplyMarkersAction || (exports.ApplyMarkersAction = ApplyMarkersAction = {}));
      var ApplyMarkersCommand = class ApplyMarkersCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.action.markers.forEach((marker) => {
            const modelElement = context.root.index.getById(marker.elementId);
            if (modelElement instanceof sprotty_1.GParentElement) {
              const issueMarker = (0, issue_marker_1.getOrCreateGIssueMarker)(modelElement);
              const issue = (0, issue_marker_1.createGIssue)(marker);
              issueMarker.issues.push(issue);
              if (issueMarker instanceof issue_marker_1.GIssueMarker) {
                issueMarker.computeProjectionCssClasses();
              }
              addMaxSeverityCSSClassToIssueParent(modelElement, issueMarker);
            }
          });
          return context.root;
        }
      };
      exports.ApplyMarkersCommand = ApplyMarkersCommand;
      ApplyMarkersCommand.KIND = ApplyMarkersAction.KIND;
      exports.ApplyMarkersCommand = ApplyMarkersCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ApplyMarkersCommand);
      function addMaxSeverityCSSClassToIssueParent(modelElement, issueMarker) {
        const maxSeverityCSSClass = (0, issue_marker_1.getSeverity)(issueMarker);
        if (!modelElement.cssClasses) {
          modelElement.cssClasses = [maxSeverityCSSClass];
        } else {
          modelElement.cssClasses = modelElement.cssClasses.filter((value) => !value.match("info|warning|error"));
          modelElement.cssClasses.push(maxSeverityCSSClass);
        }
      }
      function removeCSSClassFromIssueParent(modelElement, issueMarker) {
        const severity = (0, issue_marker_1.getSeverity)(issueMarker);
        (0, gmodel_util_1.removeCssClasses)(modelElement, [severity]);
      }
      var DeleteMarkersCommand = class DeleteMarkersCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.action.markers.forEach((marker) => {
            const modelElement = context.root.index.getById(marker.elementId);
            if (modelElement instanceof sprotty_1.GParentElement) {
              const issueMarker = (0, issue_marker_1.getGIssueMarker)(modelElement);
              if (issueMarker) {
                removeCSSClassFromIssueParent(modelElement, issueMarker);
                for (let index = 0; index < issueMarker.issues.length; ++index) {
                  const issue = issueMarker.issues[index];
                  if (issue.message === marker.description) {
                    issueMarker.issues.splice(index--, 1);
                  }
                }
                if (issueMarker.issues.length === 0) {
                  modelElement.remove(issueMarker);
                } else {
                  addMaxSeverityCSSClassToIssueParent(modelElement, issueMarker);
                }
              }
            }
          });
          return context.root;
        }
      };
      exports.DeleteMarkersCommand = DeleteMarkersCommand;
      DeleteMarkersCommand.KIND = sprotty_1.DeleteMarkersAction.KIND;
      exports.DeleteMarkersCommand = DeleteMarkersCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DeleteMarkersCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/glsp-scroll-mouse-listener.js
  var require_glsp_scroll_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/glsp-scroll-mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPScrollMouseListener = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var tool_1 = require_tool();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var GLSPScrollMouseListener = class GLSPScrollMouseListener extends sprotty_1.ScrollMouseListener {
        constructor() {
          super(...arguments);
          this.preventScrolling = false;
        }
        handle(action) {
          if (action.kind === tool_1.EnableToolsAction.KIND) {
            if (action.toolIds.includes(marquee_mouse_tool_1.MarqueeMouseTool.ID)) {
              this.preventScrolling = true;
            }
          } else if (action.kind === tool_1.EnableDefaultToolsAction.KIND) {
            this.preventScrolling = false;
          }
        }
        mouseDown(target, event) {
          if (this.preventScrolling) {
            return [];
          }
          return super.mouseDown(target, event);
        }
      };
      exports.GLSPScrollMouseListener = GLSPScrollMouseListener;
      exports.GLSPScrollMouseListener = GLSPScrollMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPScrollMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/css/glsp-sprotty.css
  var require_2 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/glsp-sprotty.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/default.module.js
  var require_default_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/default.module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultModule = void 0;
      var sprotty_1 = require_lib5();
      require_2();
      var action_dispatcher_1 = require_action_dispatcher2();
      var action_handler_registry_1 = require_action_handler_registry();
      var command_stack_1 = require_command_stack2();
      var editor_context_service_1 = require_editor_context_service();
      var css_feedback_1 = require_css_feedback();
      var feedback_action_dispatcher_1 = require_feedback_action_dispatcher();
      var update_model_command_1 = require_update_model_command();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var focus_tracker_1 = require_focus_tracker();
      var diagram_loader_1 = require_diagram_loader();
      var glsp_model_source_1 = require_glsp_model_source();
      var model_initialization_constraint_1 = require_model_initialization_constraint();
      var model_registry_1 = require_model_registry();
      var selection_clearing_mouse_listener_1 = require_selection_clearing_mouse_listener();
      var selection_service_1 = require_selection_service();
      var tool_1 = require_tool();
      var tool_manager_1 = require_tool_manager();
      var key_tool_1 = require_key_tool2();
      var mouse_tool_1 = require_mouse_tool2();
      var view_registry_1 = require_view_registry();
      exports.defaultModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind, ...rest) => {
        sprotty_1.sprottyDefaultModule.registry(bind, unbind, isBound, rebind, ...rest);
        const context = { bind, unbind, isBound, rebind };
        bind(editor_context_service_1.EditorContextService).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.IEditorContextServiceProvider).toProvider((ctx) => async () => ctx.container.get(editor_context_service_1.EditorContextService));
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetEditModeAction.KIND, editor_context_service_1.EditorContextService);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetDirtyStateAction.KIND, editor_context_service_1.EditorContextService);
        bind(focus_tracker_1.FocusTracker).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, focus_state_change_action_1.FocusStateChangedAction.KIND, focus_tracker_1.FocusTracker);
        bind(sprotty_1.TYPES.IFeedbackActionDispatcher).to(feedback_action_dispatcher_1.FeedbackActionDispatcher).inSingletonScope();
        (0, sprotty_1.configureCommand)(context, update_model_command_1.FeedbackAwareUpdateModelCommand);
        bind(mouse_tool_1.GLSPMouseTool).toSelf().inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.MouseTool).toService(mouse_tool_1.GLSPMouseTool);
        bind(key_tool_1.GLSPKeyTool).toSelf().inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.KeyTool).toService(key_tool_1.GLSPKeyTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, selection_clearing_mouse_listener_1.SelectionClearingMouseListener);
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.ICommandStack).to(command_stack_1.GLSPCommandStack).inSingletonScope();
        bind(action_dispatcher_1.GLSPActionDispatcher).toSelf().inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.IActionDispatcher).toService(action_dispatcher_1.GLSPActionDispatcher);
        bind(action_handler_registry_1.GLSPActionHandlerRegistry).toSelf().inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.ActionHandlerRegistry).toService(action_handler_registry_1.GLSPActionHandlerRegistry);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ModelSource, glsp_model_source_1.GLSPModelSource);
        bind(diagram_loader_1.DiagramLoader).toSelf().inSingletonScope();
        bind(model_initialization_constraint_1.ModelInitializationConstraint).to(model_initialization_constraint_1.DefaultModelInitializationConstraint).inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.SModelRegistry).to(model_registry_1.GModelRegistry).inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.ViewRegistry).to(view_registry_1.GViewRegistry).inSingletonScope();
        bind(selection_service_1.SelectionService).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.ISModelRootListener).toService(selection_service_1.SelectionService);
        (0, sprotty_1.configureCommand)(context, css_feedback_1.ModifyCssFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.MoveCommand);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IVNodePostprocessor, sprotty_1.LocationPostprocessor);
        bind(sprotty_1.TYPES.HiddenVNodePostprocessor).toService(sprotty_1.LocationPostprocessor);
        bind(sprotty_1.TYPES.IToolManager).to(tool_manager_1.ToolManager).inSingletonScope();
        bind(tool_manager_1.DefaultToolsEnablingKeyListener).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.KeyListener).toService(tool_manager_1.DefaultToolsEnablingKeyListener);
        bind(tool_manager_1.ToolManagerActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, tool_manager_1.ToolManagerActionHandler);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableToolsAction.KIND, tool_manager_1.ToolManagerActionHandler);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/bounds-module.js
  var require_bounds_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/bounds-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.boundsModule = void 0;
      var sprotty_1 = require_lib5();
      var freeform_layout_1 = require_freeform_layout();
      var glsp_hidden_bounds_updater_1 = require_glsp_hidden_bounds_updater();
      var hbox_layout_1 = require_hbox_layout2();
      var layouter_1 = require_layouter();
      var vbox_layout_1 = require_vbox_layout2();
      exports.boundsModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, _rebind) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureCommand)(context, sprotty_1.SetBoundsCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.RequestBoundsCommand);
        bind(sprotty_1.HiddenBoundsUpdater).toSelf().inSingletonScope();
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.HiddenVNodePostprocessor, glsp_hidden_bounds_updater_1.GLSPHiddenBoundsUpdater);
        bind(sprotty_1.TYPES.Layouter).to(layouter_1.LayouterExt).inSingletonScope();
        bind(sprotty_1.TYPES.LayoutRegistry).to(sprotty_1.LayoutRegistry).inSingletonScope();
        (0, sprotty_1.configureLayout)(context, sprotty_1.VBoxLayouter.KIND, vbox_layout_1.VBoxLayouterExt);
        (0, sprotty_1.configureLayout)(context, sprotty_1.HBoxLayouter.KIND, hbox_layout_1.HBoxLayouterExt);
        (0, sprotty_1.configureLayout)(context, freeform_layout_1.FreeFormLayouter.KIND, freeform_layout_1.FreeFormLayouter);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/css/command-palette.css
  var require_3 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/command-palette.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette-module.js
  var require_command_palette_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.commandPaletteModule = void 0;
      var sprotty_1 = require_lib5();
      require_3();
      var command_palette_tool_1 = require_command_palette_tool();
      var server_command_palette_provider_1 = require_server_command_palette_provider();
      exports.commandPaletteModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IUIExtension, sprotty_1.CommandPalette);
        bind(sprotty_1.TYPES.ICommandPaletteActionProviderRegistry).to(sprotty_1.CommandPaletteActionProviderRegistry).inSingletonScope();
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.ICommandPaletteActionProvider, server_command_palette_provider_1.ServerCommandPaletteActionProvider);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IDefaultTool, command_palette_tool_1.CommandPaletteTool);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/context-menu/context-menu-module.js
  var require_context_menu_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/context-menu/context-menu-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.contextMenuModule = void 0;
      var sprotty_1 = require_lib5();
      var glsp_context_menu_mouse_listener_1 = require_glsp_context_menu_mouse_listener();
      var server_context_menu_provider_1 = require_server_context_menu_provider();
      exports.contextMenuModule = new sprotty_1.FeatureModule((bind) => {
        bind(sprotty_1.TYPES.IContextMenuServiceProvider).toProvider((ctx) => async () => {
          if (ctx.container.isBound(sprotty_1.TYPES.IContextMenuService)) {
            return ctx.container.get(sprotty_1.TYPES.IContextMenuService);
          }
          console.warn("'TYPES.IContextMenuService' is not bound. Use no-op implementation instead");
          return { show: () => {
          } };
        });
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.MouseListener, glsp_context_menu_mouse_listener_1.GLSPContextMenuMouseListener);
        bind(sprotty_1.TYPES.IContextMenuProviderRegistry).to(sprotty_1.ContextMenuProviderRegistry);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IContextMenuItemProvider, server_context_menu_provider_1.ServerContextMenuItemProvider);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-standalone.js
  var require_copy_paste_standalone = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-standalone.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CopyPasteStartup = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var CopyPasteStartup = class CopyPasteStartup {
        constructor() {
          this.toDispose = new sprotty_1.DisposableCollection();
        }
        postModelInitialization() {
          if (!this.copyPasteHandler) {
            return;
          }
          const copyListener = (e) => {
            var _a;
            (_a = this.copyPasteHandler) === null || _a === void 0 ? void 0 : _a.handleCopy(e);
            e.preventDefault();
          };
          const cutListener = (e) => {
            var _a;
            (_a = this.copyPasteHandler) === null || _a === void 0 ? void 0 : _a.handleCut(e);
            e.preventDefault();
          };
          const pasteListener = (e) => {
            var _a;
            (_a = this.copyPasteHandler) === null || _a === void 0 ? void 0 : _a.handlePaste(e);
            e.preventDefault();
          };
          window.addEventListener("copy", copyListener);
          window.addEventListener("cut", cutListener);
          window.addEventListener("paste", pasteListener);
          this.toDispose.push(sprotty_1.Disposable.create(() => {
            window.removeEventListener("copy", copyListener);
            window.removeEventListener("cut", cutListener);
            window.removeEventListener("paste", pasteListener);
          }));
        }
        dispose() {
          this.toDispose.dispose();
        }
      };
      exports.CopyPasteStartup = CopyPasteStartup;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ICopyPasteHandler),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], CopyPasteStartup.prototype, "copyPasteHandler", void 0);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], CopyPasteStartup.prototype, "dispose", null);
      exports.CopyPasteStartup = CopyPasteStartup = __decorate([
        (0, inversify_1.injectable)()
      ], CopyPasteStartup);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-modules.js
  var require_copy_paste_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneCopyPasteModule = exports.copyPasteModule = void 0;
      var sprotty_1 = require_lib5();
      var copy_paste_handler_1 = require_copy_paste_handler();
      var copy_paste_standalone_1 = require_copy_paste_standalone();
      exports.copyPasteModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        bind(sprotty_1.TYPES.ICopyPasteHandler).to(copy_paste_handler_1.ServerCopyPasteHandler);
        bind(sprotty_1.TYPES.IAsyncClipboardService).to(copy_paste_handler_1.LocalClipboardService).inSingletonScope();
      });
      exports.standaloneCopyPasteModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IDiagramStartup, copy_paste_standalone_1.CopyPasteStartup);
      }, { requires: exports.copyPasteModule });
    }
  });

  // node_modules/@eclipse-glsp/client/css/decoration.css
  var require_4 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/decoration.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/decoration/decoration-module.js
  var require_decoration_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/decoration/decoration-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decorationModule = void 0;
      var sprotty_1 = require_lib5();
      require_4();
      var decoration_placer_1 = require_decoration_placer2();
      exports.decorationModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IVNodePostprocessor, decoration_placer_1.GlspDecorationPlacer);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/export/export-svg-action-handler.js
  var require_export_svg_action_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/export/export-svg-action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExportSvgActionHandler = void 0;
      var file_saver_1 = require_FileSaver_min();
      var inversify_1 = require_inversify();
      var ExportSvgActionHandler = class ExportSvgActionHandler {
        handle(action) {
          const blob = new Blob([action.svg], { type: "text/plain;charset=utf-8" });
          (0, file_saver_1.saveAs)(blob, "diagram.svg");
        }
      };
      exports.ExportSvgActionHandler = ExportSvgActionHandler;
      exports.ExportSvgActionHandler = ExportSvgActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ExportSvgActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/export/export-modules.js
  var require_export_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/export/export-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneExportModule = exports.exportModule = void 0;
      var sprotty_1 = require_lib5();
      var export_svg_action_handler_1 = require_export_svg_action_handler();
      var glsp_svg_exporter_1 = require_glsp_svg_exporter();
      exports.exportModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.HiddenVNodePostprocessor, sprotty_1.ExportSvgPostprocessor);
        (0, sprotty_1.configureCommand)(context, sprotty_1.ExportSvgCommand);
        bind(sprotty_1.TYPES.SvgExporter).to(glsp_svg_exporter_1.GLSPSvgExporter).inSingletonScope();
      });
      exports.standaloneExportModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.KeyListener, sprotty_1.ExportSvgKeyListener);
        bind(export_svg_action_handler_1.ExportSvgActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.ExportSvgAction.KIND, export_svg_action_handler_1.ExportSvgActionHandler);
      }, { requires: exports.exportModule });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hints/type-hints-module.js
  var require_type_hints_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hints/type-hints-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.typeHintsModule = void 0;
      var sprotty_1 = require_lib5();
      var type_hint_provider_1 = require_type_hint_provider();
      exports.typeHintsModule = new sprotty_1.FeatureModule((bind, unbind, isBound) => {
        const context = { bind, unbind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITypeHintProvider, type_hint_provider_1.TypeHintProvider);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(type_hint_provider_1.TypeHintProvider);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetTypeHintsAction.KIND, type_hint_provider_1.TypeHintProvider);
        (0, sprotty_1.configureCommand)(context, type_hint_provider_1.ApplyTypeHintsCommand);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hover/hover-module.js
  var require_hover_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hover/hover-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hoverModule = void 0;
      var sprotty_1 = require_lib5();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var tool_1 = require_tool();
      var hover_1 = require_hover2();
      exports.hoverModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.PopupVNodePostprocessor, sprotty_1.PopupPositionUpdater);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, hover_1.GlspHoverMouseListener);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.PopupMouseListener, sprotty_1.PopupHoverMouseListener);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.KeyListener, sprotty_1.HoverKeyListener);
        bind(sprotty_1.TYPES.HoverState).toConstantValue({
          mouseOverTimer: void 0,
          mouseOutTimer: void 0,
          popupOpen: false,
          previousPopupElement: void 0
        });
        bind(sprotty_1.ClosePopupActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureCommand)(context, sprotty_1.HoverFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.SetPopupModelCommand);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetPopupModelCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.FitToScreenCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.CenterCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetViewportCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.MoveCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, focus_state_change_action_1.FocusStateChangedAction.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableToolsAction.KIND, hover_1.GlspHoverMouseListener);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, hover_1.GlspHoverMouseListener);
        (0, sprotty_1.configureActionHandler)(context, focus_state_change_action_1.FocusStateChangedAction.KIND, hover_1.GlspHoverMouseListener);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/label-edit/label-edit-module.js
  var require_label_edit_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/label-edit/label-edit-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.labelEditModule = void 0;
      var sprotty_1 = require_lib5();
      var edit_label_tool_1 = require_edit_label_tool();
      var edit_label_validator_1 = require_edit_label_validator();
      exports.labelEditModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, _rebind) => {
        bind(sprotty_1.TYPES.IEditLabelValidator).to(edit_label_validator_1.ServerEditLabelValidator);
        bind(sprotty_1.TYPES.IEditLabelValidationDecorator).to(edit_label_validator_1.BalloonLabelValidationDecorator);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IDefaultTool, edit_label_tool_1.DirectLabelEditTool);
        (0, sprotty_1.configureCommand)({ bind, isBound }, sprotty_1.ApplyLabelEditCommand);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/layout/layout-module.js
  var require_layout_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/layout/layout-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.layoutModule = void 0;
      var sprotty_1 = require_lib5();
      var layout_elements_action_1 = require_layout_elements_action();
      exports.layoutModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureActionHandler)(context, layout_elements_action_1.ResizeElementsAction.KIND, layout_elements_action_1.ResizeElementsActionHandler);
        (0, sprotty_1.configureActionHandler)(context, layout_elements_action_1.AlignElementsAction.KIND, layout_elements_action_1.AlignElementsActionHandler);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-module.js
  var require_navigation_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.navigationModule = void 0;
      var sprotty_1 = require_lib5();
      var navigation_action_handler_1 = require_navigation_action_handler();
      var navigation_target_resolver_1 = require_navigation_target_resolver();
      exports.navigationModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        bind(navigation_target_resolver_1.NavigationTargetResolver).toSelf().inSingletonScope();
        bind(navigation_action_handler_1.NavigationActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, navigation_action_handler_1.NavigateAction.KIND, navigation_action_handler_1.NavigationActionHandler);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, sprotty_1.NavigateToTargetAction.KIND, navigation_action_handler_1.NavigationActionHandler);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, navigation_action_handler_1.ProcessNavigationArgumentsAction.KIND, navigation_action_handler_1.NavigationActionHandler);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, sprotty_1.NavigateToExternalTargetAction.KIND, navigation_action_handler_1.NavigationActionHandler);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/routing/routing-module.js
  var require_routing_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/routing/routing-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.routingModule = void 0;
      var sprotty_1 = require_lib5();
      var glsp_manhattan_edge_router_1 = require_glsp_manhattan_edge_router();
      exports.routingModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        bind(sprotty_1.EdgeRouterRegistry).toSelf().inSingletonScope();
        bind(sprotty_1.AnchorComputerRegistry).toSelf().inSingletonScope();
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IEdgeRouter, glsp_manhattan_edge_router_1.GLSPManhattanEdgeRouter);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.ManhattanEllipticAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.ManhattanRectangularAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.ManhattanDiamondAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IEdgeRouter, sprotty_1.PolylineEdgeRouter);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.EllipseAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.RectangleAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.DiamondAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IEdgeRouter, sprotty_1.BezierEdgeRouter);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.BezierEllipseAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.BezierRectangleAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.BezierDiamondAnchor);
        (0, sprotty_1.configureCommand)({ bind, isBound }, sprotty_1.AddRemoveBezierSegmentCommand);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/select/select-module.js
  var require_select_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/select/select-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneSelectModule = exports.selectModule = void 0;
      var sprotty_1 = require_lib5();
      var selection_service_1 = require_selection_service();
      var select_feedback_command_1 = require_select_feedback_command();
      var select_mouse_listener_1 = require_select_mouse_listener();
      exports.selectModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureCommand)(context, selection_service_1.SelectCommand);
        (0, sprotty_1.configureCommand)(context, selection_service_1.SelectAllCommand);
        (0, sprotty_1.configureCommand)(context, select_feedback_command_1.SelectFeedbackCommand);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, select_mouse_listener_1.RankedSelectMouseListener);
      });
      exports.standaloneSelectModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.KeyListener, sprotty_1.SelectKeyboardListener);
      }, { requires: exports.selectModule });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/source-model-watcher/source-model-wacher-module.js
  var require_source_model_wacher_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/source-model-watcher/source-model-wacher-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sourceModelWatcherModule = void 0;
      var sprotty_1 = require_lib5();
      var source_model_changed_action_handler_1 = require_source_model_changed_action_handler();
      exports.sourceModelWatcherModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, sprotty_1.SourceModelChangedAction.KIND, source_model_changed_action_handler_1.SourceModelChangedActionHandler);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/css/status-overlay.css
  var require_5 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/status-overlay.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/status/status-module.js
  var require_status_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/status/status-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.statusModule = void 0;
      var sprotty_1 = require_lib5();
      require_5();
      var status_overlay_1 = require_status_overlay();
      exports.statusModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, status_overlay_1.StatusOverlay);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(status_overlay_1.StatusOverlay);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.StatusAction.KIND, status_overlay_1.StatusOverlay);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/svg-metadata/svg-metadata-module.js
  var require_svg_metadata_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/svg-metadata/svg-metadata-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.svgMetadataModule = void 0;
      var sprotty_1 = require_lib5();
      var metadata_placer_1 = require_metadata_placer();
      exports.svgMetadataModule = new sprotty_1.FeatureModule((bind) => {
        bind(metadata_placer_1.MetadataPlacer).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.IVNodePostprocessor).toService(metadata_placer_1.MetadataPlacer);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/css/tool-palette.css
  var require_6 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/tool-palette.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tool-palette/tool-palette-module.js
  var require_tool_palette_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tool-palette/tool-palette-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toolPaletteModule = void 0;
      var sprotty_1 = require_lib5();
      require_6();
      var tool_1 = require_tool();
      var tool_palette_1 = require_tool_palette2();
      exports.toolPaletteModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, _rebind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IUIExtension, tool_palette_1.ToolPalette);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(tool_palette_1.ToolPalette);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, tool_1.EnableDefaultToolsAction.KIND, tool_palette_1.ToolPalette);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-boounds-tool-module.js
  var require_change_boounds_tool_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-boounds-tool-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.changeBoundsToolModule = void 0;
      var sprotty_1 = require_lib5();
      var model_1 = require_model22();
      var change_bounds_tool_1 = require_change_bounds_tool();
      var change_bounds_tool_feedback_1 = require_change_bounds_tool_feedback();
      var view_1 = require_view3();
      exports.changeBoundsToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, change_bounds_tool_1.ChangeBoundsTool);
        (0, sprotty_1.configureCommand)(context, change_bounds_tool_feedback_1.ShowChangeBoundsToolResizeFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, change_bounds_tool_feedback_1.HideChangeBoundsToolResizeFeedbackCommand);
        (0, sprotty_1.configureView)(context, model_1.SResizeHandle.TYPE, view_1.SResizeHandleView);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/deletion/deletion-tool-module.js
  var require_deletion_tool_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/deletion/deletion-tool-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deletionToolModule = void 0;
      var sprotty_1 = require_lib5();
      var delete_tool_1 = require_delete_tool();
      exports.deletionToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, delete_tool_1.DelKeyDeleteTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, delete_tool_1.MouseDeleteTool);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edege-creation-module.js
  var require_edege_creation_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edege-creation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.edgeCreationToolModule = void 0;
      var sprotty_1 = require_lib5();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_creation_tool_1 = require_edge_creation_tool();
      exports.edgeCreationToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, edge_creation_tool_1.EdgeCreationTool);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.TriggerEdgeCreationAction.KIND, edge_creation_tool_1.EdgeCreationTool);
        (0, dangling_edge_feedback_1.configureDanglingFeedbackEdge)(context);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-module.js
  var require_edge_edit_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.edgeEditToolModule = void 0;
      var sprotty_1 = require_lib5();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_edit_tool_1 = require_edge_edit_tool();
      var edge_edit_tool_feedback_1 = require_edge_edit_tool_feedback();
      exports.edgeEditToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, edge_edit_tool_1.EdgeEditTool);
        (0, sprotty_1.configureCommand)(context, edge_edit_tool_feedback_1.ShowEdgeReconnectHandlesFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, edge_edit_tool_feedback_1.HideEdgeReconnectHandlesFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, edge_edit_tool_feedback_1.DrawFeedbackEdgeSourceCommand);
        (0, sprotty_1.configureCommand)(context, edge_edit_tool_feedback_1.SwitchRoutingModeCommand);
        (0, dangling_edge_feedback_1.configureDanglingFeedbackEdge)(context);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-selection-module.js
  var require_marquee_selection_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-selection-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.marqueeSelectionToolModule = void 0;
      var sprotty_1 = require_lib5();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var marquee_tool_1 = require_marquee_tool();
      var marquee_tool_feedback_1 = require_marquee_tool_feedback();
      var model_1 = require_model24();
      var view_1 = require_view4();
      exports.marqueeSelectionToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, marquee_tool_1.MarqueeTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, marquee_mouse_tool_1.MarqueeMouseTool);
        (0, sprotty_1.configureCommand)(context, marquee_tool_feedback_1.DrawMarqueeCommand);
        (0, sprotty_1.configureCommand)(context, marquee_tool_feedback_1.RemoveMarqueeCommand);
        (0, sprotty_1.configureModelElement)(context, marquee_tool_feedback_1.MARQUEE, model_1.MarqueeNode, view_1.MarqueeView);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-module.js
  var require_node_creation_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.nodeCreationToolModule = void 0;
      var sprotty_1 = require_lib5();
      var node_creation_tool_1 = require_node_creation_tool();
      exports.nodeCreationToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, node_creation_tool_1.NodeCreationTool);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.TriggerNodeCreationAction.KIND, node_creation_tool_1.NodeCreationTool);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/tool-focus-loss-module.js
  var require_tool_focus_loss_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/tool-focus-loss-module.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toolFocusLossModule = exports.EnableDefaultToolsOnFocusLossHandler = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var tool_1 = require_tool();
      var EnableDefaultToolsOnFocusLossHandler = class EnableDefaultToolsOnFocusLossHandler {
        handle(action) {
          if (focus_state_change_action_1.FocusStateChangedAction.is(action) && !action.hasFocus) {
            return tool_1.EnableDefaultToolsAction.create();
          }
        }
      };
      exports.EnableDefaultToolsOnFocusLossHandler = EnableDefaultToolsOnFocusLossHandler;
      exports.EnableDefaultToolsOnFocusLossHandler = EnableDefaultToolsOnFocusLossHandler = __decorate([
        (0, inversify_1.injectable)()
      ], EnableDefaultToolsOnFocusLossHandler);
      exports.toolFocusLossModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, focus_state_change_action_1.FocusStateChangedAction.KIND, EnableDefaultToolsOnFocusLossHandler);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/validation/validation-modules.js
  var require_validation_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/validation/validation-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneMarkerNavigatorModule = exports.markerNavigatorModule = exports.validationModule = void 0;
      var sprotty_1 = require_lib5();
      var marker_navigator_1 = require_marker_navigator();
      var validate_1 = require_validate();
      exports.validationModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetMarkersAction.KIND, validate_1.SetMarkersActionHandler);
        (0, sprotty_1.configureCommand)(context, validate_1.ApplyMarkersCommand);
        (0, sprotty_1.configureCommand)(context, validate_1.DeleteMarkersCommand);
        bind(validate_1.ValidationFeedbackEmitter).toSelf().inSingletonScope();
      });
      exports.markerNavigatorModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        bind(marker_navigator_1.GModelElementComparator).to(marker_navigator_1.LeftToRightTopToBottomComparator).inSingletonScope();
        bind(marker_navigator_1.MarkerNavigator).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, marker_navigator_1.NavigateToMarkerAction.KIND, marker_navigator_1.NavigateToMarkerActionHandler);
      });
      exports.standaloneMarkerNavigatorModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IContextMenuProvider, marker_navigator_1.MarkerNavigatorContextMenuItemProvider);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.KeyListener, marker_navigator_1.MarkerNavigatorKeyListener);
      }, { requires: exports.markerNavigatorModule });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/actions.js
  var require_actions3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusDomAction = void 0;
      var sprotty_1 = require_lib5();
      var FocusDomAction;
      (function(FocusDomAction2) {
        FocusDomAction2.KIND = "focusDomAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, FocusDomAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "id");
        }
        FocusDomAction2.is = is;
        function create(id) {
          return { kind: FocusDomAction2.KIND, id };
        }
        FocusDomAction2.create = create;
      })(FocusDomAction || (exports.FocusDomAction = FocusDomAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-handler.js
  var require_viewport_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RestoreViewportHandler = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var focus_tracker_1 = require_focus_tracker();
      var tool_1 = require_tool();
      var actions_1 = require_actions3();
      var RestoreViewportHandler = class RestoreViewportHandler {
        constructor() {
          this.graphSelector = '[data-svg-metadata-type="graph"]';
        }
        handle(action) {
          if (tool_1.EnableDefaultToolsAction.is(action) || actions_1.FocusDomAction.is(action) && action.id === "graph") {
            this.focusGraph();
          }
        }
        async postRequestModel() {
          await this.waitForElement(this.graphSelector);
          this.focusGraph();
        }
        focusGraph() {
          var _a;
          if (this.focusTracker.hasFocus) {
            const container = (_a = this.focusTracker.diagramElement) === null || _a === void 0 ? void 0 : _a.querySelector(this.graphSelector);
            container === null || container === void 0 ? void 0 : container.focus();
          }
        }
        // https://stackoverflow.com/questions/5525071/how-to-wait-until-an-element-exists
        waitForElement(selector) {
          return new Promise((resolve) => {
            if (document.querySelector(selector)) {
              return resolve(document.querySelector(selector));
            }
            const observer = new MutationObserver((mutations) => {
              if (document.querySelector(selector)) {
                observer.disconnect();
                resolve(document.querySelector(selector));
              }
            });
            observer.observe(document.body, {
              childList: true,
              subtree: true
            });
          });
        }
      };
      exports.RestoreViewportHandler = RestoreViewportHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], RestoreViewportHandler.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(focus_tracker_1.FocusTracker),
        __metadata("design:type", focus_tracker_1.FocusTracker)
      ], RestoreViewportHandler.prototype, "focusTracker", void 0);
      exports.RestoreViewportHandler = RestoreViewportHandler = __decorate([
        (0, inversify_1.injectable)()
      ], RestoreViewportHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-modules.js
  var require_viewport_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneViewportModule = exports.viewportModule = void 0;
      var sprotty_1 = require_lib5();
      var tool_1 = require_tool();
      var glsp_scroll_mouse_listener_1 = require_glsp_scroll_mouse_listener();
      var viewport_handler_1 = require_viewport_handler();
      var reposition_1 = require_reposition();
      var actions_1 = require_actions3();
      exports.viewportModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureCommand)(context, sprotty_1.CenterCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.FitToScreenCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.GetViewportCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.SetViewportCommand);
        (0, sprotty_1.configureCommand)(context, reposition_1.RepositionCommand);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, sprotty_1.ZoomMouseListener);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, glsp_scroll_mouse_listener_1.GLSPScrollMouseListener);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableToolsAction.KIND, glsp_scroll_mouse_listener_1.GLSPScrollMouseListener);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, glsp_scroll_mouse_listener_1.GLSPScrollMouseListener);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDiagramStartup, viewport_handler_1.RestoreViewportHandler);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, viewport_handler_1.RestoreViewportHandler);
        (0, sprotty_1.configureActionHandler)(context, actions_1.FocusDomAction.KIND, viewport_handler_1.RestoreViewportHandler);
      });
      exports.standaloneViewportModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.KeyListener, sprotty_1.CenterKeyboardListener);
      }, { requires: exports.viewportModule });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/default-modules.js
  var require_default_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/default-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.initializeDiagramContainer = exports.configureDiagramOptions = exports.createDiagramOptionsModule = exports.DEFAULT_MODULES = void 0;
      var sprotty_1 = require_lib5();
      var default_module_1 = require_default_module();
      var bounds_module_1 = require_bounds_module();
      var command_palette_module_1 = require_command_palette_module();
      var context_menu_module_1 = require_context_menu_module();
      var copy_paste_modules_1 = require_copy_paste_modules();
      var decoration_module_1 = require_decoration_module();
      var export_modules_1 = require_export_modules();
      var type_hints_module_1 = require_type_hints_module();
      var hover_module_1 = require_hover_module();
      var label_edit_module_1 = require_label_edit_module();
      var layout_module_1 = require_layout_module();
      var navigation_module_1 = require_navigation_module();
      var routing_module_1 = require_routing_module();
      var select_module_1 = require_select_module();
      var source_model_wacher_module_1 = require_source_model_wacher_module();
      var status_module_1 = require_status_module();
      var svg_metadata_module_1 = require_svg_metadata_module();
      var tool_palette_module_1 = require_tool_palette_module();
      var change_boounds_tool_module_1 = require_change_boounds_tool_module();
      var deletion_tool_module_1 = require_deletion_tool_module();
      var edege_creation_module_1 = require_edege_creation_module();
      var edge_edit_module_1 = require_edge_edit_module();
      var marquee_selection_module_1 = require_marquee_selection_module();
      var node_creation_module_1 = require_node_creation_module();
      var tool_focus_loss_module_1 = require_tool_focus_loss_module();
      var validation_modules_1 = require_validation_modules();
      var viewport_modules_1 = require_viewport_modules();
      exports.DEFAULT_MODULES = [
        default_module_1.defaultModule,
        sprotty_1.buttonModule,
        sprotty_1.edgeIntersectionModule,
        sprotty_1.edgeLayoutModule,
        sprotty_1.expandModule,
        export_modules_1.exportModule,
        sprotty_1.fadeModule,
        bounds_module_1.boundsModule,
        command_palette_module_1.commandPaletteModule,
        context_menu_module_1.contextMenuModule,
        decoration_module_1.decorationModule,
        label_edit_module_1.labelEditModule,
        hover_module_1.hoverModule,
        select_module_1.selectModule,
        copy_paste_modules_1.copyPasteModule,
        viewport_modules_1.viewportModule,
        sprotty_1.labelEditUiModule,
        layout_module_1.layoutModule,
        validation_modules_1.markerNavigatorModule,
        type_hints_module_1.typeHintsModule,
        sprotty_1.modelSourceModule,
        source_model_wacher_module_1.sourceModelWatcherModule,
        navigation_module_1.navigationModule,
        routing_module_1.routingModule,
        tool_palette_module_1.toolPaletteModule,
        edege_creation_module_1.edgeCreationToolModule,
        edge_edit_module_1.edgeEditToolModule,
        deletion_tool_module_1.deletionToolModule,
        node_creation_module_1.nodeCreationToolModule,
        change_boounds_tool_module_1.changeBoundsToolModule,
        marquee_selection_module_1.marqueeSelectionToolModule,
        tool_focus_loss_module_1.toolFocusLossModule,
        validation_modules_1.validationModule,
        sprotty_1.zorderModule,
        svg_metadata_module_1.svgMetadataModule,
        status_module_1.statusModule
      ];
      function createDiagramOptionsModule(options) {
        return new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => configureDiagramOptions({ bind, unbind, isBound, rebind }, options));
      }
      exports.createDiagramOptionsModule = createDiagramOptionsModule;
      function configureDiagramOptions(context, options) {
        const viewerOptions = {
          baseDiv: options.clientId,
          hiddenDiv: options.clientId + "_hidden"
        };
        (0, sprotty_1.configureViewerOptions)(context, viewerOptions);
        context.bind(sprotty_1.TYPES.IDiagramOptions).toConstantValue(options);
      }
      exports.configureDiagramOptions = configureDiagramOptions;
      function initializeDiagramContainer(container, ...containerConfigurations) {
        const modules = (0, sprotty_1.resolveContainerConfiguration)(...exports.DEFAULT_MODULES, ...containerConfigurations);
        const firstModule = modules[0];
        if (!firstModule || !(firstModule instanceof sprotty_1.FeatureModule && firstModule.featureId === default_module_1.defaultModule.featureId)) {
          throw new Error("Invalid module configuration. The first module to load should be the `defaultModule` (or an equivalent replacement module)");
        }
        container.load(...modules);
        return container;
      }
      exports.initializeDiagramContainer = initializeDiagramContainer;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/save/save-module.js
  var require_save_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/save/save-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.saveModule = void 0;
      var sprotty_1 = require_lib5();
      var save_keylistener_1 = require_save_keylistener();
      exports.saveModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.KeyListener, save_keylistener_1.SaveModelKeyboardListener);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/undo-redo/undo-redo-module.js
  var require_undo_redo_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/undo-redo/undo-redo-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.undoRedoModule = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var undo_redo_key_listener_1 = require_undo_redo_key_listener();
      exports.undoRedoModule = new inversify_1.ContainerModule((bind, unbind, isBound, rebind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.KeyListener, undo_redo_key_listener_1.GLSPUndoRedoKeyListener);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/standalone-modules.js
  var require_standalone_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/standalone-modules.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.STANDALONE_MODULE_CONFIG = exports.STANDALONE_MODULES = exports.LayoutKeyListener = exports.FallbackActionHandler = exports.standaloneDefaultModule = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var copy_paste_modules_1 = require_copy_paste_modules();
      var export_modules_1 = require_export_modules();
      var save_module_1 = require_save_module();
      var select_module_1 = require_select_module();
      var undo_redo_module_1 = require_undo_redo_module();
      var validation_modules_1 = require_validation_modules();
      var viewport_modules_1 = require_viewport_modules();
      exports.standaloneDefaultModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        bind(FallbackActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.MessageAction.KIND, FallbackActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.StartProgressAction.KIND, FallbackActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.UpdateProgressAction.KIND, FallbackActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.EndProgressAction.KIND, FallbackActionHandler);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.KeyListener, LayoutKeyListener);
      });
      var FallbackActionHandler = class FallbackActionHandler {
        handle(action) {
          this.logger.log(this, "Unhandled action received:", action);
        }
      };
      exports.FallbackActionHandler = FallbackActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], FallbackActionHandler.prototype, "logger", void 0);
      exports.FallbackActionHandler = FallbackActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], FallbackActionHandler);
      var LayoutKeyListener = class LayoutKeyListener extends sprotty_1.KeyListener {
        keyDown(_element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyL", "ctrlCmd", "shift")) {
            return [sprotty_1.LayoutOperation.create()];
          }
          return [];
        }
      };
      exports.LayoutKeyListener = LayoutKeyListener;
      exports.LayoutKeyListener = LayoutKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], LayoutKeyListener);
      exports.STANDALONE_MODULES = [
        viewport_modules_1.standaloneViewportModule,
        copy_paste_modules_1.standaloneCopyPasteModule,
        validation_modules_1.standaloneMarkerNavigatorModule,
        select_module_1.standaloneSelectModule,
        export_modules_1.standaloneExportModule,
        exports.standaloneDefaultModule,
        save_module_1.saveModule,
        undo_redo_module_1.undoRedoModule
      ];
      exports.STANDALONE_MODULE_CONFIG = {
        add: [...exports.STANDALONE_MODULES]
      };
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/argument-utils.js
  var require_argument_utils = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/argument-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CornerRadius = exports.EdgePadding = exports.GArgument = void 0;
      var args_feature_1 = require_args_feature();
      var GArgument;
      (function(GArgument2) {
        function asNumber(argValue) {
          return typeof argValue === "number" ? argValue : void 0;
        }
        GArgument2.asNumber = asNumber;
        function asNumbers(argValues) {
          return argValues.map(asNumber);
        }
        GArgument2.asNumbers = asNumbers;
        function asString(argValue) {
          return typeof argValue === "string" ? argValue : void 0;
        }
        GArgument2.asString = asString;
        function asStrings(argValues) {
          return argValues.map(asString);
        }
        GArgument2.asStrings = asStrings;
        function asBoolean(argValue) {
          return typeof argValue === "boolean" ? argValue : void 0;
        }
        GArgument2.asBoolean = asBoolean;
        function asBooleans(argValues) {
          return argValues.map(asBoolean);
        }
        GArgument2.asBooleans = asBooleans;
        function getArgument(element, key) {
          return (0, args_feature_1.hasArgs)(element) ? element.args[key] : void 0;
        }
        GArgument2.getArgument = getArgument;
        function getNumber(element, key) {
          return (0, args_feature_1.hasArgs)(element) ? asNumber(element.args[key]) : void 0;
        }
        GArgument2.getNumber = getNumber;
        function getString(element, key) {
          return (0, args_feature_1.hasArgs)(element) ? asString(element.args[key]) : void 0;
        }
        GArgument2.getString = getString;
        function getBoolean(element, key) {
          return (0, args_feature_1.hasArgs)(element) ? asBoolean(element.args[key]) : void 0;
        }
        GArgument2.getBoolean = getBoolean;
        function getArguments(element, ...keys) {
          if (!(0, args_feature_1.hasArgs)(element)) {
            return void 0;
          }
          const values = [];
          for (const key of keys) {
            const value = element.args[key];
            if (value) {
              values.push(value);
            }
          }
          return values;
        }
        GArgument2.getArguments = getArguments;
        function getNumbers(element, ...keys) {
          const values = getArguments(element, ...keys);
          return values ? asNumbers(values) : void 0;
        }
        GArgument2.getNumbers = getNumbers;
        function getStrings(element, ...keys) {
          const values = getArguments(element, ...keys);
          return values ? asStrings(values) : void 0;
        }
        GArgument2.getStrings = getStrings;
        function getBooleans(element, ...keys) {
          const values = getArguments(element, ...keys);
          return values ? asBooleans(values) : void 0;
        }
        GArgument2.getBooleans = getBooleans;
        function hasNValues(values, length) {
          return values.length === length && values.filter((e) => e === void 0).length === 0;
        }
        GArgument2.hasNValues = hasNValues;
      })(GArgument || (exports.GArgument = GArgument = {}));
      var EdgePadding;
      (function(EdgePadding2) {
        const KEY = "edgePadding";
        function from(element) {
          return GArgument.getNumber(element, KEY);
        }
        EdgePadding2.from = from;
      })(EdgePadding || (exports.EdgePadding = EdgePadding = {}));
      var CornerRadius = class {
        constructor(topLeft = 0, topRight = topLeft, bottomRight = topLeft, bottomLeft = topRight) {
          this.topLeft = topLeft;
          this.topRight = topRight;
          this.bottomRight = bottomRight;
          this.bottomLeft = bottomLeft;
        }
        static from(element) {
          const radius = GArgument.getNumbers(element, this.KEY_RADIUS_TOP_LEFT, this.KEY_RADIUS_TOP_RIGHT, this.KEY_RADIUS_BOTTOM_RIGHT, this.KEY_RADIUS_BOTTOM_LEFT);
          if (radius === void 0 || radius[0] === void 0) {
            return void 0;
          }
          return GArgument.hasNValues(radius, 4) ? new CornerRadius(radius[0], radius[1], radius[2], radius[3]) : new CornerRadius(radius[0]);
        }
      };
      exports.CornerRadius = CornerRadius;
      CornerRadius.NO_RADIUS = new CornerRadius(0);
      CornerRadius.KEY_RADIUS_TOP_LEFT = "radiusTopLeft";
      CornerRadius.KEY_RADIUS_TOP_RIGHT = "radiusTopRight";
      CornerRadius.KEY_RADIUS_BOTTOM_RIGHT = "radiusBottomRight";
      CornerRadius.KEY_RADIUS_BOTTOM_LEFT = "radiusBottomLeft";
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/html-utils.js
  var require_html_utils = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/html-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createElementFromHTML = void 0;
      function createElementFromHTML(html) {
        const template = document.createElement("template");
        html = html.trim();
        template.innerHTML = html;
        const node = template.content.firstChild;
        if (node && node instanceof HTMLElement) {
          return node;
        }
        return void 0;
      }
      exports.createElementFromHTML = createElementFromHTML;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/gedge-view.js
  var require_gedge_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/gedge-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GEdgeView = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var argument_utils_1 = require_argument_utils();
      var JSX = { createElement: sprotty_1.svg };
      var GEdgeView = class GEdgeView extends sprotty_1.PolylineEdgeView {
        render(edge, context) {
          const router = this.edgeRouterRegistry.get(edge.routerKind);
          const route = router.route(edge);
          if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
          }
          return JSX.createElement(
            "g",
            Object.assign({ "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback }, this.additionalClasses(edge, context)),
            this.renderLine(edge, route, context),
            this.renderAdditionals(edge, route, context),
            context.renderChildren(edge, { route })
          );
        }
        additionalClasses(_edge, _context) {
          return {};
        }
        renderLine(_edge, segments, _context) {
          return JSX.createElement("path", { d: this.createPathForSegments(segments) });
        }
        renderAdditionals(edge, segments, _context) {
          const edgePadding = argument_utils_1.EdgePadding.from(edge);
          return edgePadding ? [this.renderMouseHandle(segments, edgePadding)] : [];
        }
        renderMouseHandle(segments, padding) {
          return JSX.createElement("path", { "class-mouse-handle": true, d: this.createPathForSegments(segments), "style-stroke-width": padding * 2, "style-stroke": "transparent", "style-stroke-dasharray": "none", "style-stroke-dashoffset": "0" });
        }
        createPathForSegments(segments) {
          const firstPoint = segments[0];
          let path = `M ${firstPoint.x},${firstPoint.y}`;
          for (let i = 1; i < segments.length; i++) {
            const p = segments[i];
            path += ` L ${p.x},${p.y}`;
          }
          return path;
        }
      };
      exports.GEdgeView = GEdgeView;
      exports.GEdgeView = GEdgeView = __decorate([
        (0, inversify_1.injectable)()
      ], GEdgeView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/issue-marker-view.js
  var require_issue_marker_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/issue-marker-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GIssueMarkerView = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var JSX = { createElement: sprotty_1.svg };
      var GIssueMarkerView = class GIssueMarkerView extends sprotty_1.IssueMarkerView {
        render(marker, _context) {
          const maxSeverity = super.getMaxSeverity(marker);
          const group = JSX.createElement(
            "g",
            { "class-sprotty-issue": true },
            JSX.createElement(
              "g",
              null,
              this.getGlspIssueMarkerBackground(maxSeverity),
              JSX.createElement("path", { d: this.getGlspIssueMarkerPath(maxSeverity) })
            )
          );
          (0, sprotty_1.setClass)(group, "sprotty-" + maxSeverity, true);
          return group;
        }
        getGlspIssueMarkerBackground(severity) {
          switch (severity) {
            case "warning":
              return JSX.createElement("polygon", { "class-sprotty-issue-background": true, points: "8 2, 15.9 14.9, 0.2 14.9" });
            case "error":
            case "info":
              return JSX.createElement("circle", { "class-sprotty-issue-background": true, r: this.radius, cx: this.radius, cy: this.radius });
          }
        }
        get radius() {
          return 8;
        }
        getGlspIssueMarkerPath(severity) {
          switch (severity) {
            case "error":
              return "m 8.8527788,0.00699568 c 1.8523692,0.115773 3.5889642,1.04195762 4.8624692,2.31546152 1.505048,1.620823 2.31546,3.5889653 2.31546,5.9044268 0,1.852369 -0.694637,3.588965 -1.852367,5.094015 -1.157733,1.389277 -2.778554,2.431235 -4.6309235,2.778554 C 7.6950478,16.446772 5.8426784,16.215226 4.2218552,15.289042 2.6010319,14.362857 1.3275281,12.97358 0.63288942,11.236984 -0.06174907,9.5003878 -0.17752216,7.5322456 0.4013433,5.7956494 0.98020876,3.9432802 2.0221665,2.4382302 3.6429898,1.3962725 5.14804,0.35431486 7.0004094,-0.10877742 8.8527788,0.00699568 Z M 9.4316445,14.941722 c 1.5050505,-0.347319 2.8943275,-1.15773 3.9362845,-2.431234 0.926185,-1.273504 1.50505,-2.778554 1.389277,-4.3993771 0,-1.8523692 -0.69464,-3.7047384 -1.968142,-4.9782422 C 11.631331,1.9751379 10.242054,1.2804995 8.6212324,1.1647264 7.1161824,1.0489533 5.4953592,1.3962725 4.2218552,2.3224572 2.9483511,3.2486418 2.0221665,4.5221456 1.5590742,6.1429686 c -0.4630923,1.50505 -0.4630923,3.1258731 0.2315462,4.6309234 0.6946384,1.50505 1.7365963,2.66278 3.1258734,3.473192 1.3892769,0.810411 3.0101002,1.041958 4.5151507,0.694638 z M 8.042367,7.5322456 10.82092,4.6379187 11.631331,5.4483302 8.8527788,8.3426571 11.631331,11.236984 10.82092,12.047395 8.042367,9.1530686 5.2638128,12.047395 4.4534013,11.236984 7.2319555,8.3426571 4.4534013,5.4483302 5.2638128,4.6379187 Z";
            case "warning":
              return "M 7.5587159,0.61312771 H 8.565869 L 16.050847,14.644601 15.54727,15.491525 H 0.55442396 L 0.05084746,14.644601 Z M 8.0622924,2.0780776 1.5157974,14.347033 H 14.585897 Z M 8.7776,13.202541 V 12.058049 H 7.3469848 v 1.144492 z M 7.3469848,10.913557 V 6.3355883 H 8.7776 v 4.5779687 z";
            case "info":
              return "M 8.7624795,0.01729008 A 7.8878137,7.8878137 0 0 1 13.625085,2.3592747 8.1894066,8.1894066 0 0 1 14.158672,13.251418 7.9458123,7.9458123 0 0 1 4.2061071,15.26977 8.1198082,8.1198082 0 0 1 0.58699265,11.209866 8.259005,8.259005 0 0 1 0.32019895,5.7463948 8.1198082,8.1198082 0 0 1 3.533323,1.3500986 7.8878137,7.8878137 0 0 1 8.7624795,0.01729008 Z M 9.3099868,14.921778 A 6.8322386,6.8322386 0 0 0 13.265493,12.520635 7.0410337,7.0410337 0 0 0 12.801504,3.1712556 6.7510406,6.7510406 0 0 0 4.1829077,2.3128758 7.029434,7.029434 0 0 0 4.762894,14.248994 6.7394408,6.7394408 0 0 0 9.3099868,14.921778 Z M 7.3786322,5.7811939 H 8.8285979 V 4.6212213 H 7.3786322 Z M 8.8285979,6.9411665 V 11.581057 H 7.3786322 V 6.9411665 Z";
          }
        }
      };
      exports.GIssueMarkerView = GIssueMarkerView;
      exports.GIssueMarkerView = GIssueMarkerView = __decorate([
        (0, inversify_1.injectable)()
      ], GIssueMarkerView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/rounded-corner.js
  var require_rounded_corner = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/rounded-corner.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scaledRadius = exports.RoundedCornerWrapper = void 0;
      var RoundedCornerWrapper = class {
        constructor(element, cornerRadius) {
          this.element = element;
          this.cornerRadius = cornerRadius;
        }
        get size() {
          return this.element.size;
        }
        get topLeftCorner() {
          if (!this._topLeftCorner) {
            this._topLeftCorner = {
              radiusX: scaledRadius(this.cornerRadius.topLeft, this.element.size.width / 2),
              radiusY: scaledRadius(this.cornerRadius.topLeft, this.element.size.height / 2)
            };
          }
          return this._topLeftCorner;
        }
        get topRightCorner() {
          if (!this._topRightCorner) {
            this._topRightCorner = {
              radiusX: scaledRadius(this.cornerRadius.topRight, this.element.size.width / 2),
              radiusY: scaledRadius(this.cornerRadius.topRight, this.element.size.height / 2)
            };
          }
          return this._topRightCorner;
        }
        get bottomRightCorner() {
          if (!this._bottomRightCorner) {
            this._bottomRightCorner = {
              radiusX: scaledRadius(this.cornerRadius.bottomRight, this.element.size.width / 2),
              radiusY: scaledRadius(this.cornerRadius.bottomRight, this.element.size.height / 2)
            };
          }
          return this._bottomRightCorner;
        }
        get bottomLeftCorner() {
          if (!this._bottomLeftCorner) {
            this._bottomLeftCorner = {
              radiusX: scaledRadius(this.cornerRadius.bottomLeft, this.element.size.width / 2),
              radiusY: scaledRadius(this.cornerRadius.bottomLeft, this.element.size.height / 2)
            };
          }
          return this._bottomLeftCorner;
        }
      };
      exports.RoundedCornerWrapper = RoundedCornerWrapper;
      function scaledRadius(radius, maximalLength) {
        if (radius <= maximalLength) {
          return radius;
        } else {
          return radius * (maximalLength / radius);
        }
      }
      exports.scaledRadius = scaledRadius;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/rounded-corner-view.js
  var require_rounded_corner_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/rounded-corner-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toClipPathId = exports.RoundedCornerNodeView = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var argument_utils_1 = require_argument_utils();
      var rounded_corner_1 = require_rounded_corner();
      var JSX = { createElement: sprotty_1.svg };
      var RoundedCornerNodeView = class RoundedCornerNodeView extends sprotty_1.RectangularNodeView {
        render(node, context) {
          const cornerRadius = argument_utils_1.CornerRadius.from(node);
          if (!cornerRadius) {
            return this.renderWithoutRadius(node, context);
          }
          const wrapper = new rounded_corner_1.RoundedCornerWrapper(node, cornerRadius);
          return JSX.createElement(
            "g",
            { "class-node": true },
            JSX.createElement(
              "defs",
              null,
              JSX.createElement(
                "clipPath",
                { id: toClipPathId(node) },
                JSX.createElement("path", { d: this.renderPath(wrapper, context, this.getClipPathInsets() || 0) })
              )
            ),
            this.renderPathNode(wrapper, context),
            context.renderChildren(node)
          );
        }
        renderWithoutRadius(node, context) {
          return super.render(node, context);
        }
        getClipPathInsets() {
          return 2;
        }
        renderPathNode(wrapper, context) {
          return JSX.createElement("path", Object.assign({ d: this.renderPath(wrapper, context, 0), "class-sprotty-node": wrapper.element instanceof sprotty_1.GNode, "class-sprotty-port": wrapper.element instanceof sprotty_1.GPort, "class-mouseover": wrapper.element.hoverFeedback, "class-selected": wrapper.element.selected }, this.additionalClasses(wrapper.element, context)));
        }
        additionalClasses(_node, _context) {
          return {};
        }
        renderPath(wrapper, _context, inset) {
          const topLineLength = Math.max(0, wrapper.size.width - wrapper.cornerRadius.topLeft - wrapper.cornerRadius.topRight);
          const rightLineLength = Math.max(0, wrapper.size.height - wrapper.cornerRadius.topRight - wrapper.cornerRadius.bottomRight);
          const bottomLineLength = Math.max(0, wrapper.size.width - wrapper.cornerRadius.bottomLeft - wrapper.cornerRadius.bottomRight);
          const path = `M${0 + inset},${0 + wrapper.topLeftCorner.radiusY}q${0},${-(wrapper.topLeftCorner.radiusY - inset)} ${wrapper.topLeftCorner.radiusX - inset},${-(wrapper.topLeftCorner.radiusY - inset)}h${topLineLength}q${wrapper.topRightCorner.radiusX - inset},0 ${wrapper.topRightCorner.radiusX - inset},${wrapper.topRightCorner.radiusY - inset}v${rightLineLength}q0,${wrapper.bottomRightCorner.radiusY - inset} ${-(wrapper.bottomRightCorner.radiusX - inset)},${wrapper.bottomRightCorner.radiusY - inset}h${-bottomLineLength}q${-(wrapper.bottomLeftCorner.radiusX - inset)},0 ${-(wrapper.bottomLeftCorner.radiusX - inset)},${-(wrapper.bottomLeftCorner.radiusY - inset)}z `;
          return path;
        }
      };
      exports.RoundedCornerNodeView = RoundedCornerNodeView;
      exports.RoundedCornerNodeView = RoundedCornerNodeView = __decorate([
        (0, inversify_1.injectable)()
      ], RoundedCornerNodeView);
      function toClipPathId(node) {
        return `${node.id}_clip_path`;
      }
      exports.toClipPathId = toClipPathId;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/base-view-module.js
  var require_base_view_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/base-view-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureDefaultModelElements = exports.baseViewModule = void 0;
      var sprotty_1 = require_lib5();
      var issue_marker_1 = require_issue_marker();
      var gedge_view_1 = require_gedge_view();
      var issue_marker_view_1 = require_issue_marker_view();
      var rounded_corner_view_1 = require_rounded_corner_view();
      var model_1 = require_model21();
      exports.baseViewModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureDefaultModelElements(context);
      });
      function configureDefaultModelElements(context) {
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.HTML, sprotty_1.GHtmlRoot, sprotty_1.HtmlRootView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.FOREIGN_OBJECT, sprotty_1.GForeignObjectElement, sprotty_1.ForeignObjectView, {
          disable: [sprotty_1.selectFeature, sprotty_1.moveFeature]
        });
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.PRE_RENDERED, sprotty_1.GPreRenderedElement, sprotty_1.PreRenderedView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.SHAPE_PRE_RENDERED, sprotty_1.GShapedPreRenderedElement, sprotty_1.PreRenderedView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.SVG, sprotty_1.GViewportRootElement, sprotty_1.SvgViewportView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.GRAPH, model_1.GGraph, sprotty_1.GGraphView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.NODE, sprotty_1.GNode, rounded_corner_view_1.RoundedCornerNodeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.COMPARTMENT, sprotty_1.GCompartment, sprotty_1.GCompartmentView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.COMPARTMENT_HEADER, sprotty_1.GCompartment, sprotty_1.GCompartmentView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.EDGE, model_1.GEdge, gedge_view_1.GEdgeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.PORT, sprotty_1.GPort, sprotty_1.RectangularNodeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.ROUTING_POINT, sprotty_1.GRoutingHandle, sprotty_1.GRoutingHandleView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.VOLATILE_ROUTING_POINT, sprotty_1.GRoutingHandle, sprotty_1.GRoutingHandleView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.LABEL, sprotty_1.GLabel, sprotty_1.GLabelView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.BUTTON_EXPAND, sprotty_1.GButton, sprotty_1.ExpandButtonView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.ISSUE_MARKER, issue_marker_1.GIssueMarker, issue_marker_view_1.GIssueMarkerView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.NODE_CIRCLE, sprotty_1.CircularNode, sprotty_1.CircularNodeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.NODE_DIAMOND, sprotty_1.DiamondNode, sprotty_1.DiamondNodeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.NODE_RECTANGLE, sprotty_1.RectangularNode, sprotty_1.RectangularNodeView);
      }
      exports.configureDefaultModelElements = configureDefaultModelElements;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/compartments.js
  var require_compartments = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/compartments.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StructureCompartmentView = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var JSX = { createElement: sprotty_1.svg };
      var StructureCompartmentView = class StructureCompartmentView extends sprotty_1.ShapeView {
        render(model, context) {
          if (!this.isVisible(model, context)) {
            return void 0;
          }
          return JSX.createElement(
            "g",
            null,
            JSX.createElement("rect", { "class-sprotty-comp": true, x: "0", y: "0", width: model.size.width, height: model.size.height }),
            context.renderChildren(model)
          );
        }
      };
      exports.StructureCompartmentView = StructureCompartmentView;
      exports.StructureCompartmentView = StructureCompartmentView = __decorate([
        (0, inversify_1.injectable)()
      ], StructureCompartmentView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/glsp-projection-view.js
  var require_glsp_projection_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/glsp-projection-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPProjectionView = void 0;
      var inversify_1 = require_inversify();
      var snabbdom_1 = require_snabbdom_cjs();
      var sprotty_1 = require_lib5();
      var JSX = { createElement: sprotty_1.html };
      var GLSPProjectionView = class GLSPProjectionView extends sprotty_1.ProjectedViewportView {
        render(model, context, args) {
          const svgElem = this.renderSvg(model, context, args);
          if (svgElem.data) {
            svgElem.data.class = { "sprotty-graph": true };
          }
          const rootNode = JSX.createElement(
            "div",
            { "class-sprotty-graph": false, style: { width: "100%", height: "100%" } },
            svgElem,
            this.renderProjections(model, context, args)
          );
          (0, sprotty_1.setAttr)(rootNode, "tabindex", 1);
          (0, sprotty_1.setAttr)(rootNode, "aria-label", "Diagram");
          return rootNode;
        }
        renderSvg(model, context, args) {
          const edgeRouting = this.edgeRouterRegistry.routeAllChildren(model);
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          const ns = "http://www.w3.org/2000/svg";
          const svg3 = (0, snabbdom_1.h)("svg", { ns, style: { height: "100%" } }, (0, snabbdom_1.h)("g", { ns, attrs: { transform } }, context.renderChildren(model, { edgeRouting })));
          return svg3;
        }
        renderProjectionBar(projections, model, modelBounds, orientation) {
          const params = { modelBounds, orientation };
          params.factor = orientation === "horizontal" ? model.canvasBounds.width / modelBounds.width : model.canvasBounds.height / modelBounds.height;
          params.zoomedFactor = params.factor / model.zoom;
          return JSX.createElement(
            "div",
            { "class-sprotty-projection-bar": true, "class-horizontal": orientation === "horizontal", "class-vertical": orientation === "vertical", "class-bordered-projection-bar": true },
            this.renderViewport(model, params),
            projections.map((p) => this.renderProjection(p, model, params))
          );
        }
        renderViewport(model, params) {
          let canvasSize;
          let viewportPos;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            viewportPos = (model.scroll.x - params.modelBounds.x) * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            viewportPos = (model.scroll.y - params.modelBounds.y) * params.factor;
          }
          let viewportSize = canvasSize * params.zoomedFactor;
          if (viewportPos < 0) {
            viewportSize += viewportPos;
            viewportPos = 0;
          } else if (viewportPos > canvasSize) {
            viewportPos = canvasSize;
          }
          if (viewportSize < 0) {
            viewportSize = 0;
          } else if (viewportPos + viewportSize > canvasSize) {
            viewportSize = canvasSize - viewportPos;
          }
          if (Math.abs(viewportSize - canvasSize) < 1) {
            viewportSize = 0;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${viewportPos}px`,
            width: `${viewportSize}px`,
            border: "none"
          } : {
            top: `${viewportPos}px`,
            height: `${viewportSize}px`,
            border: "none"
          };
          return JSX.createElement("div", { "class-sprotty-viewport": viewportSize !== 0, "class-projection-scroll-bar": true, style });
        }
        renderProjection(projection, model, params) {
          let canvasSize;
          let projPos;
          let projSize;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            projPos = (projection.projectedBounds.x - params.modelBounds.x) * params.factor;
            projSize = projection.projectedBounds.width * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            projPos = (projection.projectedBounds.y - params.modelBounds.y) * params.factor;
            projSize = projection.projectedBounds.height * params.factor;
          }
          if (projPos < 0) {
            projSize += projPos;
            projPos = 0;
          } else if (projPos > canvasSize) {
            projPos = canvasSize;
          }
          if (projSize < 0) {
            projSize = 0;
          } else if (projPos + projSize > canvasSize) {
            projSize = canvasSize - projPos;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${projPos}px`,
            width: `${projSize}px`,
            height: "60%"
          } : {
            top: `${projPos}px`,
            height: `${projSize}px`,
            width: "60%"
          };
          const result = JSX.createElement("div", { id: `${params.orientation}-projection:${projection.elementId}`, "class-sprotty-projection": true, "class-glsp-projection": true, style });
          projection.cssClasses.forEach((cl) => (0, sprotty_1.setClass)(result, cl, true));
          return result;
        }
      };
      exports.GLSPProjectionView = GLSPProjectionView;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], GLSPProjectionView.prototype, "edgeRouterRegistry", void 0);
      exports.GLSPProjectionView = GLSPProjectionView = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPProjectionView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/index.js
  var require_views7 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_base_view_module(), exports);
      __exportStar(require_compartments(), exports);
      __exportStar(require_gedge_view(), exports);
      __exportStar(require_glsp_projection_view(), exports);
      __exportStar(require_issue_marker_view(), exports);
      __exportStar(require_rounded_corner(), exports);
      __exportStar(require_rounded_corner_view(), exports);
    }
  });

  // node_modules/@eclipse-glsp/client/css/key-shortcut.css
  var require_7 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/key-shortcut.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/key-shortcut/di.config.js
  var require_di_config23 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/key-shortcut/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureShortcutHelpTool = exports.glspShortcutHelpModule = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      require_7();
      var accessible_key_shortcut_1 = require_accessible_key_shortcut();
      var accessible_key_shortcut_tool_1 = require_accessible_key_shortcut_tool();
      exports.glspShortcutHelpModule = new inversify_1.ContainerModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureShortcutHelpTool(context);
      });
      function configureShortcutHelpTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, accessible_key_shortcut_tool_1.AccessibleKeyShortcutTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, accessible_key_shortcut_1.KeyShortcutUIExtension);
        (0, sprotty_1.configureActionHandler)(context, accessible_key_shortcut_1.SetAccessibleKeyShortcutAction.KIND, accessible_key_shortcut_1.KeyShortcutUIExtension);
      }
      exports.configureShortcutHelpTool = configureShortcutHelpTool;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/move-zoom/move-zoom-module.js
  var require_move_zoom_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/move-zoom/move-zoom-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureMoveZoom = exports.moveZoomModule = void 0;
      var sprotty_1 = require_lib5();
      var move_handler_1 = require_move_handler();
      var zoom_handler_1 = require_zoom_handler();
      exports.moveZoomModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureMoveZoom(context);
      });
      function configureMoveZoom(context) {
        context.bind(move_handler_1.MoveViewportHandler).toSelf().inSingletonScope();
        context.bind(move_handler_1.MoveElementHandler).toSelf().inSingletonScope();
        context.bind(zoom_handler_1.ZoomViewportHandler).toSelf().inSingletonScope();
        context.bind(zoom_handler_1.ZoomElementHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, move_handler_1.MoveViewportAction.KIND, move_handler_1.MoveViewportHandler);
        (0, sprotty_1.configureActionHandler)(context, move_handler_1.MoveElementAction.KIND, move_handler_1.MoveElementHandler);
        (0, sprotty_1.configureActionHandler)(context, zoom_handler_1.ZoomViewportAction.KIND, zoom_handler_1.ZoomViewportHandler);
        (0, sprotty_1.configureActionHandler)(context, zoom_handler_1.ZoomElementAction.KIND, zoom_handler_1.ZoomElementHandler);
      }
      exports.configureMoveZoom = configureMoveZoom;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/resize-key-tool/resize-key-module.js
  var require_resize_key_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/resize-key-tool/resize-key-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureResizeTools = exports.resizeKeyModule = void 0;
      var sprotty_1 = require_lib5();
      var resize_key_handler_1 = require_resize_key_handler();
      var resize_key_tool_1 = require_resize_key_tool();
      exports.resizeKeyModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureResizeTools(context);
      });
      function configureResizeTools(context) {
        context.bind(resize_key_handler_1.ResizeElementHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, resize_key_handler_1.ResizeElementAction.KIND, resize_key_handler_1.ResizeElementHandler);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, resize_key_tool_1.ResizeKeyTool);
      }
      exports.configureResizeTools = configureResizeTools;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-palette-module.js
  var require_search_palette_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-palette-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureSearchPaletteModule = exports.searchPaletteModule = void 0;
      var sprotty_1 = require_lib5();
      var search_palette_1 = require_search_palette();
      var search_tool_1 = require_search_tool();
      exports.searchPaletteModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, rebind) => {
        const context = { bind, isBound, rebind };
        configureSearchPaletteModule(context);
      });
      function configureSearchPaletteModule(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, search_palette_1.SearchAutocompletePalette);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, search_tool_1.SearchAutocompletePaletteTool);
      }
      exports.configureSearchPaletteModule = configureSearchPaletteModule;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/view-key-tools-module.js
  var require_view_key_tools_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/view-key-tools-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureViewKeyTools = exports.viewKeyToolsModule = void 0;
      var sprotty_1 = require_lib5();
      var deselect_key_tool_1 = require_deselect_key_tool();
      var movement_key_tool_1 = require_movement_key_tool();
      var zoom_key_tool_1 = require_zoom_key_tool();
      var action_1 = require_action2();
      exports.viewKeyToolsModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, rebind) => {
        const context = { bind, isBound, rebind };
        configureViewKeyTools(context);
      });
      function configureViewKeyTools(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, movement_key_tool_1.MovementKeyTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, zoom_key_tool_1.ZoomKeyTool);
        (0, sprotty_1.configureActionHandler)(context, action_1.KeyboardGridCellSelectedAction.KIND, zoom_key_tool_1.ZoomKeyTool);
        (0, sprotty_1.configureActionHandler)(context, action_1.KeyboardGridKeyboardEventAction.KIND, zoom_key_tool_1.ZoomKeyTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, deselect_key_tool_1.DeselectKeyTool);
      }
      exports.configureViewKeyTools = configureViewKeyTools;
    }
  });

  // node_modules/@eclipse-glsp/client/css/keyboard-tool-palette.css
  var require_8 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/keyboard-tool-palette.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/constants.js
  var require_constants = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardNodeGridMetadata = exports.KeyboardGridMetadata = void 0;
      var KeyboardGridMetadata;
      (function(KeyboardGridMetadata2) {
        KeyboardGridMetadata2.ID = "keyboard-grid";
        KeyboardGridMetadata2.TAB_INDEX = 15;
      })(KeyboardGridMetadata || (exports.KeyboardGridMetadata = KeyboardGridMetadata = {}));
      var KeyboardNodeGridMetadata;
      (function(KeyboardNodeGridMetadata2) {
        KeyboardNodeGridMetadata2.ID = "keyboard-node-grid";
      })(KeyboardNodeGridMetadata || (exports.KeyboardNodeGridMetadata = KeyboardNodeGridMetadata = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/action.js
  var require_action3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetEdgeTargetSelectionAction = void 0;
      var sprotty_1 = require_lib5();
      var SetEdgeTargetSelectionAction;
      (function(SetEdgeTargetSelectionAction2) {
        SetEdgeTargetSelectionAction2.KIND = "setEdgeTargetSelectionAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, SetEdgeTargetSelectionAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "elementId") && (0, sprotty_1.hasObjectProp)(object, "context");
        }
        SetEdgeTargetSelectionAction2.is = is;
        function create(elementId, context) {
          return { kind: SetEdgeTargetSelectionAction2.KIND, elementId, context };
        }
        SetEdgeTargetSelectionAction2.create = create;
      })(SetEdgeTargetSelectionAction || (exports.SetEdgeTargetSelectionAction = SetEdgeTargetSelectionAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-palette.js
  var require_edge_autocomplete_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PossibleEdgeTargetAutocompleteSuggestionProvider = exports.EdgeAutocompletePalette = exports.EdgeAutocompletePaletteMetadata = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var tool_1 = require_tool();
      var iterable_1 = require_iterable();
      var search_palette_1 = require_search_palette();
      var action_1 = require_action3();
      var auto_complete_widget_1 = require_auto_complete_widget();
      var model_1 = require_model21();
      var EdgeAutocompletePaletteMetadata;
      (function(EdgeAutocompletePaletteMetadata2) {
        EdgeAutocompletePaletteMetadata2.ID = "edge-autocomplete-palette";
      })(EdgeAutocompletePaletteMetadata || (exports.EdgeAutocompletePaletteMetadata = EdgeAutocompletePaletteMetadata = {}));
      var EdgeAutocompletePalette = class EdgeAutocompletePalette extends search_palette_1.SearchAutocompletePalette {
        constructor() {
          super(...arguments);
          this.targetSuggestionProvider = new PossibleEdgeTargetAutocompleteSuggestionProvider();
        }
        id() {
          return EdgeAutocompletePaletteMetadata.ID;
        }
        handle(action) {
          if (sprotty_1.TriggerEdgeCreationAction.is(action)) {
            this.context = {
              trigger: action,
              role: "source"
            };
            this.targetSuggestionProvider.setContext(action, this.context);
          }
        }
        onBeforeShow(containerElement, root, ...contextElementIds) {
          var _a;
          super.onBeforeShow(containerElement, root, ...contextElementIds);
          this.autocompleteWidget.inputField.placeholder = `Search for ${(_a = this.context) === null || _a === void 0 ? void 0 : _a.role} elements`;
        }
        getSuggestionProviders(root, input) {
          return [this.targetSuggestionProvider];
        }
        reload() {
          const context = this.context;
          this.hide();
          this.context = context;
          this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({
            extensionId: EdgeAutocompletePaletteMetadata.ID,
            visible: true
          }));
        }
        executeSuggestion(input) {
          var _a, _b, _c, _d;
          const action = (0, auto_complete_widget_1.toActionArray)(input)[0];
          if (((_a = this.context) === null || _a === void 0 ? void 0 : _a.role) === "source") {
            this.context.sourceId = action.elementId;
            this.context.role = "target";
            this.reload();
          } else if (((_b = this.context) === null || _b === void 0 ? void 0 : _b.role) === "target") {
            this.context.targetId = action.elementId;
          }
          if (((_c = this.context) === null || _c === void 0 ? void 0 : _c.sourceId) !== void 0 && ((_d = this.context) === null || _d === void 0 ? void 0 : _d.targetId) !== void 0) {
            this.actionDispatcher.dispatchAll([
              sprotty_1.CreateEdgeOperation.create({
                elementTypeId: this.context.trigger.elementTypeId,
                sourceElementId: this.context.sourceId,
                targetElementId: this.context.targetId,
                args: this.context.trigger.args
              }),
              tool_1.EnableDefaultToolsAction.create()
            ]);
            this.hide();
          }
        }
        autocompleteHide(reason) {
          if (reason !== "submission") {
            this.hide();
          }
        }
      };
      exports.EdgeAutocompletePalette = EdgeAutocompletePalette;
      exports.EdgeAutocompletePalette = EdgeAutocompletePalette = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeAutocompletePalette);
      var PossibleEdgeTargetAutocompleteSuggestionProvider = class PossibleEdgeTargetAutocompleteSuggestionProvider {
        setContext(triggerAction, edgeAutocompleteContext) {
          this.proxyEdge = new model_1.GEdge();
          this.proxyEdge.type = triggerAction.elementTypeId;
          this.context = edgeAutocompleteContext;
        }
        isAllowedSource(element, role) {
          return element !== void 0 && this.proxyEdge !== void 0 && (0, sprotty_1.isConnectable)(element) && element.canConnect(this.proxyEdge, role);
        }
        async retrieveSuggestions(root, text) {
          const context = this.context;
          if (this.context === void 0) {
            return [];
          }
          const nodes = (0, iterable_1.toArray)(root.index.all().filter((element) => this.isAllowedSource(element, context.role)));
          return nodes.map((node) => {
            var _a;
            return {
              element: node,
              action: {
                label: `[${node.type}] ${(_a = (0, sprotty_1.name)(node)) !== null && _a !== void 0 ? _a : "<no-name>"}`,
                actions: [action_1.SetEdgeTargetSelectionAction.create(node.id, context.role)],
                icon: (0, sprotty_1.codiconCSSString)("arrow-both")
              }
            };
          });
        }
      };
      exports.PossibleEdgeTargetAutocompleteSuggestionProvider = PossibleEdgeTargetAutocompleteSuggestionProvider;
      exports.PossibleEdgeTargetAutocompleteSuggestionProvider = PossibleEdgeTargetAutocompleteSuggestionProvider = __decorate([
        (0, inversify_1.injectable)()
      ], PossibleEdgeTargetAutocompleteSuggestionProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-tool-palette/keyboard-tool-palette.js
  var require_keyboard_tool_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-tool-palette/keyboard-tool-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardToolPalette = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var keyboard_1 = require_keyboard();
      var delete_tool_1 = require_delete_tool();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var tool_palette_1 = require_tool_palette2();
      var constants_1 = require_constants();
      var actions_1 = require_actions3();
      var edge_autocomplete_palette_1 = require_edge_autocomplete_palette();
      var tool_1 = require_tool();
      var toast_handler_1 = require_toast_handler();
      var diagram_navigation_tool_1 = require_diagram_navigation_tool();
      var messages = require_messages2();
      var SEARCH_ICON_ID = "search";
      var PALETTE_ICON_ID = "symbol-color";
      var CHEVRON_DOWN_ICON_ID = "chevron-right";
      var PALETTE_HEIGHT = "500px";
      var SELECTION_TOOL_KEY = ["Digit1", "Numpad1"];
      var DELETION_TOOL_KEY = ["Digit2", "Numpad2"];
      var MARQUEE_TOOL_KEY = ["Digit3", "Numpad3"];
      var VALIDATION_TOOL_KEY = ["Digit4", "Numpad4"];
      var SEARCH_TOOL_KEY = ["Digit5", "Numpad5"];
      var SHOW_SHORTCUTS_CLASS = "accessibility-show-shortcuts";
      var AVAILABLE_KEYS = [
        "KeyA",
        "KeyB",
        "KeyC",
        "KeyD",
        "KeyE",
        "KeyF",
        "KeyG",
        "KeyH",
        "KeyI",
        "KeyJ",
        "KeyK",
        "KeyL",
        "KeyM",
        "KeyN",
        "KeyO",
        "KeyP",
        "KeyQ",
        "KeyR",
        "KeyS",
        "KeyT",
        "KeyU",
        "KeyV",
        "KeyX",
        "KeyY",
        "KeyZ"
      ];
      var HEADER_TOOL_KEYS = [SELECTION_TOOL_KEY, DELETION_TOOL_KEY, MARQUEE_TOOL_KEY, VALIDATION_TOOL_KEY, SEARCH_TOOL_KEY];
      var KeyboardToolPalette = class KeyboardToolPalette extends tool_palette_1.ToolPalette {
        constructor() {
          super(...arguments);
          this.keyboardIndexButtonMapping = /* @__PURE__ */ new Map();
          this.headerToolsButtonMapping = /* @__PURE__ */ new Map();
        }
        get interactablePaletteItems() {
          return this.paletteItems.sort(tool_palette_1.compare).map((item) => {
            var _a, _b;
            return (_b = (_a = item.children) === null || _a === void 0 ? void 0 : _a.sort(tool_palette_1.compare)) !== null && _b !== void 0 ? _b : [item];
          }).reduce((acc, val) => acc.concat(val), []);
        }
        initializeContents(_containerElement) {
          this.containerElement.setAttribute("aria-label", "Tool Palette");
          this.containerElement.tabIndex = 20;
          this.containerElement.classList.add("accessibility-tool-palette");
          this.createHeader();
          this.createBody();
          this.lastActiveButton = this.defaultToolsButton;
          this.containerElement.onkeyup = (ev) => {
            this.clearToolOnEscape(ev);
            if (this.isShortcutsVisible()) {
              this.selectItemOnCharacter(ev);
              this.triggerHeaderToolsByKey(ev);
            }
          };
        }
        handle(action) {
          if (action.kind === tool_palette_1.EnableToolPaletteAction.KIND) {
            const requestAction = sprotty_1.RequestContextActions.create({
              contextId: tool_palette_1.ToolPalette.ID,
              editorContext: {
                selectedElementIds: []
              }
            });
            this.actionDispatcher.requestUntil(requestAction).then((response) => {
              if (sprotty_1.SetContextActions.is(response)) {
                this.paletteItems = response.actions.map((e) => e);
                this.actionDispatcher.dispatchAll([
                  sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: tool_palette_1.ToolPalette.ID, visible: !this.editorContext.isReadonly })
                ]);
              }
            });
          } else if (action.kind === tool_1.EnableDefaultToolsAction.KIND) {
            this.changeActiveButton();
            this.restoreFocus();
          } else if (actions_1.FocusDomAction.is(action) && action.id === tool_palette_1.ToolPalette.ID) {
            if (this.containerElement.contains(document.activeElement)) {
              this.toggleShortcutVisibility();
            } else {
              this.showShortcuts();
            }
            this.containerElement.focus();
          }
        }
        addMinimizePaletteButton() {
          const baseDiv = document.getElementById(this.options.baseDiv);
          const minPaletteDiv = document.createElement("div");
          minPaletteDiv.classList.add("minimize-palette-button");
          this.containerElement.classList.add("collapsible-palette");
          if (baseDiv) {
            const insertedDiv = baseDiv.insertBefore(minPaletteDiv, baseDiv.firstChild);
            const minimizeIcon = (0, tool_palette_1.createIcon)(CHEVRON_DOWN_ICON_ID);
            this.updateMinimizePaletteButtonTooltip(minPaletteDiv);
            minimizeIcon.onclick = (_event) => {
              if (this.isPaletteMaximized()) {
                this.containerElement.style.overflow = "hidden";
                this.containerElement.style.maxHeight = "0px";
              } else {
                this.containerElement.style.overflow = "visible";
                this.containerElement.style.maxHeight = PALETTE_HEIGHT;
              }
              this.updateMinimizePaletteButtonTooltip(minPaletteDiv);
              (0, tool_palette_1.changeCodiconClass)(minimizeIcon, PALETTE_ICON_ID);
              (0, tool_palette_1.changeCodiconClass)(minimizeIcon, CHEVRON_DOWN_ICON_ID);
            };
            insertedDiv.appendChild(minimizeIcon);
          }
        }
        createBody() {
          const bodyDiv = document.createElement("div");
          bodyDiv.classList.add("palette-body");
          const tabIndex = 21;
          let toolButtonCounter = 0;
          this.keyboardIndexButtonMapping.clear();
          this.paletteItems.sort(tool_palette_1.compare).forEach((item) => {
            if (item.children) {
              const group = (0, tool_palette_1.createToolGroup)(item);
              item.children.sort(tool_palette_1.compare).forEach((child) => {
                const button = this.createKeyboardToolButton(child, tabIndex, toolButtonCounter);
                group.appendChild(button);
                this.keyboardIndexButtonMapping.set(toolButtonCounter, button);
                toolButtonCounter++;
              });
              bodyDiv.appendChild(group);
            } else {
              const button = this.createKeyboardToolButton(item, tabIndex, toolButtonCounter);
              bodyDiv.appendChild(button);
              this.keyboardIndexButtonMapping.set(toolButtonCounter, button);
              toolButtonCounter++;
            }
          });
          if (this.paletteItems.length === 0) {
            const noResultsDiv = document.createElement("div");
            noResultsDiv.innerText = "No results found.";
            noResultsDiv.classList.add("tool-button");
            bodyDiv.appendChild(noResultsDiv);
          }
          if (this.bodyDiv) {
            this.containerElement.removeChild(this.bodyDiv);
          }
          this.containerElement.appendChild(bodyDiv);
          this.bodyDiv = bodyDiv;
        }
        createHeaderTools() {
          this.headerToolsButtonMapping.clear();
          const headerTools = document.createElement("div");
          headerTools.classList.add("header-tools");
          this.defaultToolsButton = this.createDefaultToolButton();
          this.headerToolsButtonMapping.set(0, this.defaultToolsButton);
          headerTools.appendChild(this.defaultToolsButton);
          this.deleteToolButton = this.createMouseDeleteToolButton();
          this.headerToolsButtonMapping.set(1, this.deleteToolButton);
          headerTools.appendChild(this.deleteToolButton);
          this.marqueeToolButton = this.createMarqueeToolButton();
          this.headerToolsButtonMapping.set(2, this.marqueeToolButton);
          headerTools.appendChild(this.marqueeToolButton);
          this.validateToolButton = this.createValidateButton();
          this.headerToolsButtonMapping.set(3, this.validateToolButton);
          headerTools.appendChild(this.validateToolButton);
          this.searchToolButton = this.createSearchButton();
          this.headerToolsButtonMapping.set(4, this.searchToolButton);
          headerTools.appendChild(this.searchToolButton);
          return headerTools;
        }
        createDefaultToolButton() {
          const button = (0, tool_palette_1.createIcon)("inspect");
          button.id = "btn_default_tools";
          button.title = "Enable selection tool";
          button.onclick = this.onClickStaticToolButton(button);
          button.appendChild(this.createKeyboardShotcut(SELECTION_TOOL_KEY[0]));
          return button;
        }
        createMouseDeleteToolButton() {
          const deleteToolButton = (0, tool_palette_1.createIcon)("chrome-close");
          deleteToolButton.title = "Enable deletion tool";
          deleteToolButton.onclick = this.onClickStaticToolButton(deleteToolButton, delete_tool_1.MouseDeleteTool.ID);
          deleteToolButton.appendChild(this.createKeyboardShotcut(DELETION_TOOL_KEY[0]));
          return deleteToolButton;
        }
        createMarqueeToolButton() {
          const marqueeToolButton = (0, tool_palette_1.createIcon)("screen-full");
          marqueeToolButton.title = "Enable marquee tool";
          const toastMessageAction = toast_handler_1.ShowToastMessageAction.createWithTimeout({
            id: Symbol.for(diagram_navigation_tool_1.ElementNavigatorKeyListener.name),
            message: messages.tool_palette.marqueeTool
          });
          marqueeToolButton.onclick = this.onClickStaticToolButton(marqueeToolButton, marquee_mouse_tool_1.MarqueeMouseTool.ID, toastMessageAction);
          marqueeToolButton.appendChild(this.createKeyboardShotcut(MARQUEE_TOOL_KEY[0]));
          return marqueeToolButton;
        }
        createValidateButton() {
          const validateToolButton = (0, tool_palette_1.createIcon)("pass");
          validateToolButton.title = "Validate model";
          validateToolButton.onclick = (_event) => {
            const modelIds = [this.modelRootId];
            this.actionDispatcher.dispatch(sprotty_1.RequestMarkersAction.create(modelIds));
          };
          validateToolButton.appendChild(this.createKeyboardShotcut(VALIDATION_TOOL_KEY[0]));
          return validateToolButton;
        }
        onClickStaticToolButton(button, toolId, action) {
          return (_ev) => {
            if (!this.editorContext.isReadonly) {
              const defaultAction = toolId ? tool_1.EnableToolsAction.create([toolId]) : tool_1.EnableDefaultToolsAction.create();
              if (action) {
                this.actionDispatcher.dispatchAll([defaultAction, action]);
              } else {
                this.actionDispatcher.dispatchAll([defaultAction]);
              }
              this.changeActiveButton(button);
              button.focus();
            }
          };
        }
        createSearchButton() {
          const searchIcon = (0, tool_palette_1.createIcon)(SEARCH_ICON_ID);
          searchIcon.onclick = (_ev) => {
            const searchField = document.getElementById(this.containerElement.id + "_search_field");
            if (searchField) {
              if (searchField.style.display === "none") {
                searchField.style.display = "";
                searchField.focus();
              } else {
                searchField.style.display = "none";
              }
            }
          };
          searchIcon.classList.add("search-icon");
          searchIcon.title = "Filter palette entries";
          searchIcon.appendChild(this.createKeyboardShotcut(SEARCH_TOOL_KEY[0]));
          return searchIcon;
        }
        createHeaderSearchField() {
          const searchField = document.createElement("input");
          searchField.classList.add("search-input");
          searchField.tabIndex = 21;
          searchField.id = this.containerElement.id + "_search_field";
          searchField.type = "text";
          searchField.placeholder = " Search...";
          searchField.style.display = "none";
          searchField.onkeyup = (ev) => {
            this.requestFilterUpdate(this.searchField.value);
            ev.stopPropagation();
            if (searchField.value === "") {
              this.focusToolPaletteOnEscape(ev);
            } else {
              this.clearOnEscape(ev);
            }
          };
          return searchField;
        }
        focusToolPaletteOnEscape(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            this.containerElement.focus();
          }
        }
        createKeyboardShotcut(keyShortcut) {
          const hint = document.createElement("div");
          hint.classList.add("key-shortcut");
          let keyShortcutValue = keyShortcut.toString();
          if (keyShortcut.includes("Key")) {
            keyShortcutValue = keyShortcut.toString().substring(3);
          } else if (keyShortcut.includes("Digit")) {
            keyShortcutValue = keyShortcut.toString().substring(5);
          }
          hint.innerHTML = keyShortcutValue;
          return hint;
        }
        createKeyboardToolButton(item, tabIndex, buttonIndex) {
          const button = document.createElement("div");
          if (buttonIndex < AVAILABLE_KEYS.length) {
            button.appendChild(this.createKeyboardShotcut(AVAILABLE_KEYS[buttonIndex]));
          }
          button.tabIndex = tabIndex;
          button.classList.add("tool-button");
          if (item.icon) {
            button.appendChild((0, tool_palette_1.createIcon)(item.icon));
          }
          button.insertAdjacentText("beforeend", item.label);
          button.onclick = this.onClickCreateToolButton(button, item);
          button.onkeydown = (ev) => {
            this.clickToolOnEnter(ev, button, item);
            this.clearToolOnEscape(ev);
            if ((0, keyboard_1.matchesKeystroke)(ev, "ArrowDown")) {
              if (buttonIndex + 1 > this.keyboardIndexButtonMapping.size - 1) {
                this.selectItemViaArrowKey(this.keyboardIndexButtonMapping.get(0));
              } else {
                this.selectItemViaArrowKey(this.keyboardIndexButtonMapping.get(buttonIndex + 1));
              }
            } else if ((0, keyboard_1.matchesKeystroke)(ev, "ArrowUp")) {
              if (buttonIndex - 1 < 0) {
                this.selectItemViaArrowKey(this.keyboardIndexButtonMapping.get(this.keyboardIndexButtonMapping.size - 1));
              } else {
                this.selectItemViaArrowKey(this.keyboardIndexButtonMapping.get(buttonIndex - 1));
              }
            }
          };
          return button;
        }
        clickToolOnEnter(event, button, item) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Enter")) {
            if (!this.editorContext.isReadonly) {
              this.actionDispatcher.dispatchAll(item.actions);
              this.changeActiveButton(button);
              this.selectItemOnCharacter(event);
            }
          }
        }
        selectItemOnCharacter(event) {
          var _a;
          let index = void 0;
          const items = this.interactablePaletteItems;
          const itemsCount = items.length < AVAILABLE_KEYS.length ? items.length : AVAILABLE_KEYS.length;
          for (let i = 0; i < itemsCount; i++) {
            const keycode = AVAILABLE_KEYS[i];
            if ((0, keyboard_1.matchesKeystroke)(event, keycode)) {
              index = i;
              break;
            }
          }
          if (index !== void 0) {
            if (items[index].actions.some((a) => a.kind === sprotty_1.TriggerNodeCreationAction.KIND)) {
              this.actionDispatcher.dispatchAll([
                ...items[index].actions,
                sprotty_1.SetUIExtensionVisibilityAction.create({
                  extensionId: constants_1.KeyboardNodeGridMetadata.ID,
                  visible: true,
                  contextElementsId: []
                })
              ]);
            } else {
              this.actionDispatcher.dispatchAll([
                ...items[index].actions,
                sprotty_1.SetUIExtensionVisibilityAction.create({
                  extensionId: edge_autocomplete_palette_1.EdgeAutocompletePaletteMetadata.ID,
                  visible: true,
                  contextElementsId: []
                })
              ]);
            }
            this.changeActiveButton(this.keyboardIndexButtonMapping.get(index));
            (_a = this.keyboardIndexButtonMapping.get(index)) === null || _a === void 0 ? void 0 : _a.focus();
          }
        }
        triggerHeaderToolsByKey(event) {
          var _a;
          let index = void 0;
          for (let i = 0; i < HEADER_TOOL_KEYS.length; i++) {
            for (let j = 0; j < HEADER_TOOL_KEYS[i].length; j++) {
              const keycode = HEADER_TOOL_KEYS[i][j];
              if ((0, keyboard_1.matchesKeystroke)(event, keycode)) {
                event.stopPropagation();
                event.preventDefault();
                index = i;
                break;
              }
            }
          }
          if (index !== void 0) {
            (_a = this.headerToolsButtonMapping.get(index)) === null || _a === void 0 ? void 0 : _a.click();
          }
        }
        selectItemViaArrowKey(currentButton) {
          if (currentButton !== void 0) {
            this.changeActiveButton(currentButton);
            currentButton === null || currentButton === void 0 ? void 0 : currentButton.focus();
          }
        }
        clearToolOnEscape(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            if (event.target instanceof HTMLElement) {
              event.target.blur();
            }
            this.actionDispatcher.dispatch(tool_1.EnableDefaultToolsAction.create());
          }
        }
        toggleShortcutVisibility() {
          if (this.isShortcutsVisible()) {
            this.hideShortcuts();
          } else {
            this.showShortcuts();
          }
        }
        isShortcutsVisible() {
          return this.containerElement.classList.contains(SHOW_SHORTCUTS_CLASS);
        }
        showShortcuts() {
          this.containerElement.classList.add(SHOW_SHORTCUTS_CLASS);
        }
        hideShortcuts() {
          this.containerElement.classList.remove(SHOW_SHORTCUTS_CLASS);
        }
      };
      exports.KeyboardToolPalette = KeyboardToolPalette;
      exports.KeyboardToolPalette = KeyboardToolPalette = __decorate([
        (0, inversify_1.injectable)()
      ], KeyboardToolPalette);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-tool-palette/keyboard-tool-palette-module.js
  var require_keyboard_tool_palette_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-tool-palette/keyboard-tool-palette-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureKeyboardToolPaletteTool = exports.keyboardToolPaletteModule = void 0;
      require_8();
      var sprotty_1 = require_lib5();
      var tool_palette_1 = require_tool_palette2();
      var keyboard_tool_palette_1 = require_keyboard_tool_palette();
      var actions_1 = require_actions3();
      var tool_1 = require_tool();
      exports.keyboardToolPaletteModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureKeyboardToolPaletteTool(context);
      });
      function configureKeyboardToolPaletteTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_tool_palette_1.KeyboardToolPalette);
        context.bind(sprotty_1.TYPES.IDiagramStartup).toService(keyboard_tool_palette_1.KeyboardToolPalette);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, keyboard_tool_palette_1.KeyboardToolPalette);
        (0, sprotty_1.configureActionHandler)(context, actions_1.FocusDomAction.KIND, keyboard_tool_palette_1.KeyboardToolPalette);
        (0, sprotty_1.configureActionHandler)(context, tool_palette_1.EnableToolPaletteAction.KIND, keyboard_tool_palette_1.KeyboardToolPalette);
      }
      exports.configureKeyboardToolPaletteTool = configureKeyboardToolPaletteTool;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/constants.js
  var require_constants2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardPointerMetadata = void 0;
      var KeyboardPointerMetadata;
      (function(KeyboardPointerMetadata2) {
        KeyboardPointerMetadata2.ID = "keyboard-pointer";
        KeyboardPointerMetadata2.CRICLE_HEIGHT = 16;
        KeyboardPointerMetadata2.CIRCLE_WIDTH = 16;
        KeyboardPointerMetadata2.TAB_INDEX = 10;
      })(KeyboardPointerMetadata || (exports.KeyboardPointerMetadata = KeyboardPointerMetadata = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/global-keylistener-tool.js
  var require_global_keylistener_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/global-keylistener-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var GlobalKeyListenerTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GlobalKeyListenerTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var keyboard_1 = require_keyboard();
      var tool_palette_1 = require_tool_palette2();
      var actions_1 = require_actions3();
      var constants_1 = require_constants();
      var constants_2 = require_constants2();
      var accessible_key_shortcut_1 = require_accessible_key_shortcut();
      var action_dispatcher_1 = require_action_dispatcher2();
      var keyboard_tool_palette_1 = require_keyboard_tool_palette();
      var GlobalKeyListenerTool = GlobalKeyListenerTool_1 = class GlobalKeyListenerTool {
        constructor() {
          this.isEditTool = false;
          this.alreadyRegistered = false;
        }
        get id() {
          return GlobalKeyListenerTool_1.ID;
        }
        enable() {
          if (!this.alreadyRegistered) {
            this.alreadyRegistered = true;
            document.addEventListener("keyup", this.trigger.bind(this));
            this.registerShortcutKey();
          }
        }
        disable() {
        }
        registerShortcutKey() {
          this.actionDispatcher.onceModelInitialized().then(() => {
            this.actionDispatcher.dispatchAll([
              accessible_key_shortcut_1.SetAccessibleKeyShortcutAction.create({
                token: keyboard_tool_palette_1.KeyboardToolPalette.name,
                keys: [{ shortcuts: ["ALT", "P"], description: "Focus on tool palette", group: "Tool-Palette", position: 0 }]
              }),
              accessible_key_shortcut_1.SetAccessibleKeyShortcutAction.create({
                token: "Graph",
                keys: [{ shortcuts: ["ALT", "G"], description: "Focus on graph", group: "Graph", position: 0 }]
              })
            ]);
          });
        }
        trigger(event) {
          this.actionDispatcher.dispatchAll(this.handleKeyEvent(event));
        }
        handleKeyEvent(event) {
          if (this.matchesSetFocusOnToolPalette(event)) {
            return [actions_1.FocusDomAction.create(tool_palette_1.ToolPalette.ID)];
          } else if (this.matchesSetFocusOnDiagram(event)) {
            return [actions_1.FocusDomAction.create("graph")];
          } else if (this.matchesReleaseFocusFromToolPalette(event)) {
            return [
              sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: constants_2.KeyboardPointerMetadata.ID, visible: false, contextElementsId: [] }),
              sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: constants_1.KeyboardGridMetadata.ID, visible: false, contextElementsId: [] }),
              sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: constants_1.KeyboardNodeGridMetadata.ID, visible: false, contextElementsId: [] })
            ];
          }
          return [];
        }
        matchesSetFocusOnToolPalette(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "KeyP", "alt");
        }
        matchesSetFocusOnDiagram(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "KeyG", "alt");
        }
        matchesReleaseFocusFromToolPalette(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Escape");
        }
      };
      exports.GlobalKeyListenerTool = GlobalKeyListenerTool;
      GlobalKeyListenerTool.ID = "glsp.global-key-listener";
      __decorate([
        (0, inversify_1.inject)(action_dispatcher_1.GLSPActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], GlobalKeyListenerTool.prototype, "actionDispatcher", void 0);
      exports.GlobalKeyListenerTool = GlobalKeyListenerTool = GlobalKeyListenerTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], GlobalKeyListenerTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/actions.js
  var require_actions4 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetKeyboardPointerRenderPositionAction = void 0;
      var sprotty_1 = require_lib5();
      var SetKeyboardPointerRenderPositionAction;
      (function(SetKeyboardPointerRenderPositionAction2) {
        SetKeyboardPointerRenderPositionAction2.KIND = "setKeyboardPointerRenderPositionAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, SetKeyboardPointerRenderPositionAction2.KIND) && (0, sprotty_1.hasNumberProp)(object, "x") && (0, sprotty_1.hasNumberProp)(object, "y");
        }
        SetKeyboardPointerRenderPositionAction2.is = is;
        function create(x, y) {
          return { kind: SetKeyboardPointerRenderPositionAction2.KIND, x, y };
        }
        SetKeyboardPointerRenderPositionAction2.create = create;
      })(SetKeyboardPointerRenderPositionAction || (exports.SetKeyboardPointerRenderPositionAction = SetKeyboardPointerRenderPositionAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-listener.js
  var require_keyboard_pointer_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardPointerKeyboardListener = void 0;
      var sprotty_1 = require_lib5();
      var keyboard_1 = require_keyboard();
      var constants_1 = require_constants();
      var constants_2 = require_constants2();
      var tool_1 = require_tool();
      var css_feedback_1 = require_css_feedback();
      var KeyboardPointerKeyboardListener = class {
        get position() {
          return this.keyboardPointer.getPosition;
        }
        constructor(keyboardPointer, actionDispatcher) {
          this.keyboardPointer = keyboardPointer;
          this.actionDispatcher = actionDispatcher;
        }
        keyDown(event) {
          this.moveIfArrows(event);
          this.createIfEnterEvent(event);
          this.hideIfEscapeEvent(event);
        }
        moveIfArrows(event) {
          if (this.matchesMovePointerDown(event)) {
            this.position.renderPosition = this.position.calcRelativeRenderPosition(0, 10);
            this.keyboardPointer.render();
          } else if (this.matchesMovePointerUp(event)) {
            this.position.renderPosition = this.position.calcRelativeRenderPosition(0, -10);
            this.keyboardPointer.render();
          } else if (this.matchesMovePointerRight(event)) {
            this.position.renderPosition = this.position.calcRelativeRenderPosition(10, 0);
            this.keyboardPointer.render();
          } else if (this.matchesMovePointerLeft(event)) {
            this.position.renderPosition = this.position.calcRelativeRenderPosition(-10, 0);
            this.keyboardPointer.render();
          }
        }
        createIfEnterEvent(event) {
          const elementTypeId = this.keyboardPointer.triggerAction.elementTypeId;
          const { container, status } = this.position.containableParentAtDiagramPosition(elementTypeId);
          if (container !== void 0 && status === css_feedback_1.CursorCSS.NODE_CREATION) {
            if (this.matchesConfirmPointerPosition(event)) {
              const containerId = container.id;
              const location2 = this.position.diagramPosition;
              this.actionDispatcher.dispatchAll([
                sprotty_1.SetUIExtensionVisibilityAction.create({
                  extensionId: constants_2.KeyboardPointerMetadata.ID,
                  visible: false,
                  contextElementsId: []
                }),
                sprotty_1.SetUIExtensionVisibilityAction.create({
                  extensionId: constants_1.KeyboardNodeGridMetadata.ID,
                  visible: false,
                  contextElementsId: []
                }),
                sprotty_1.CreateNodeOperation.create(elementTypeId, { location: location2, containerId, args: this.keyboardPointer.triggerAction.args }),
                tool_1.EnableDefaultToolsAction.create()
              ]);
            } else if (this.matchesConfirmPointerPositionAndStayInMode(event)) {
              const containerId = container.id;
              const location2 = this.position.diagramPosition;
              this.actionDispatcher.dispatch(sprotty_1.CreateNodeOperation.create(elementTypeId, { location: location2, containerId, args: this.keyboardPointer.triggerAction.args }));
            }
          }
        }
        hideIfEscapeEvent(event) {
          if (this.matchesDeactivatePointer(event)) {
            this.keyboardPointer.hide();
          }
        }
        matchesDeactivatePointer(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Escape");
        }
        matchesConfirmPointerPosition(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Enter");
        }
        matchesConfirmPointerPositionAndStayInMode(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Enter", "ctrl");
        }
        matchesMovePointerLeft(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowLeft");
        }
        matchesMovePointerRight(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowRight");
        }
        matchesMovePointerUp(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowUp");
        }
        matchesMovePointerDown(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "ArrowDown");
        }
      };
      exports.KeyboardPointerKeyboardListener = KeyboardPointerKeyboardListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-position.js
  var require_keyboard_pointer_position = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-position.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardPointerPosition = void 0;
      var sprotty_1 = require_lib5();
      var model_1 = require_model20();
      var viewpoint_util_1 = require_viewpoint_util();
      var constants_1 = require_constants2();
      var css_feedback_1 = require_css_feedback();
      var KeyboardPointerPosition = class {
        constructor(keyboardPointer) {
          this.keyboardPointer = keyboardPointer;
          this.renderPosition = { x: 20, y: 20 };
        }
        get centerizedRenderPosition() {
          return {
            x: this.renderPosition.x + constants_1.KeyboardPointerMetadata.CIRCLE_WIDTH / 2,
            y: this.renderPosition.y + constants_1.KeyboardPointerMetadata.CRICLE_HEIGHT / 2
          };
        }
        get diagramPosition() {
          return (0, viewpoint_util_1.getAbsolutePositionByPoint)(this.keyboardPointer.editorContextService.modelRoot, this.centerizedRenderPosition);
        }
        childrenAtDiagramPosition() {
          const position = this.diagramPosition;
          return [
            this.keyboardPointer.editorContextService.modelRoot,
            ...(0, sprotty_1.findChildrenAtPosition)(this.keyboardPointer.editorContextService.modelRoot, position)
          ];
        }
        containableParentAtDiagramPosition(elementTypeId) {
          const children = this.childrenAtDiagramPosition();
          return this.containableParentOf(children.reverse()[0], elementTypeId);
        }
        calcRelativeRenderPosition(x, y) {
          return {
            x: this.renderPosition.x + x,
            y: this.renderPosition.y + y
          };
        }
        containableParentOf(target, elementTypeId) {
          const container = (0, sprotty_1.findParentByFeature)(target, model_1.isContainable);
          return {
            container,
            status: this.isCreationAllowed(container, elementTypeId) ? css_feedback_1.CursorCSS.NODE_CREATION : css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED
          };
        }
        isCreationAllowed(container, elementTypeId) {
          return container && container.isContainableElement(elementTypeId);
        }
      };
      exports.KeyboardPointerPosition = KeyboardPointerPosition;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer.js
  var require_keyboard_pointer = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardPointer = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var actions_1 = require_actions4();
      var constants_1 = require_constants2();
      var keyboard_pointer_listener_1 = require_keyboard_pointer_listener();
      var keyboard_pointer_position_1 = require_keyboard_pointer_position();
      var action_1 = require_action2();
      var editor_context_service_1 = require_editor_context_service();
      var css_feedback_1 = require_css_feedback();
      var KeyboardPointer = class KeyboardPointer extends sprotty_1.AbstractUIExtension {
        constructor(actionDispatcher) {
          super();
          this.actionDispatcher = actionDispatcher;
          this._triggerAction = {
            elementTypeId: "task:automated",
            kind: "triggerNodeCreation"
          };
          this.position = new keyboard_pointer_position_1.KeyboardPointerPosition(this);
          this.keyListener = new keyboard_pointer_listener_1.KeyboardPointerKeyboardListener(this, actionDispatcher);
        }
        get triggerAction() {
          return this._triggerAction;
        }
        get isVisible() {
          var _a;
          return ((_a = this.containerElement) === null || _a === void 0 ? void 0 : _a.style.visibility) === "visible";
        }
        get getPosition() {
          return this.position;
        }
        get getKeyListener() {
          return this.keyListener;
        }
        id() {
          return constants_1.KeyboardPointerMetadata.ID;
        }
        containerClass() {
          return constants_1.KeyboardPointerMetadata.ID;
        }
        initializeContents(containerElement) {
          containerElement.style.position = "absolute";
          containerElement.style.height = `${constants_1.KeyboardPointerMetadata.CRICLE_HEIGHT}px`;
          containerElement.style.width = `${constants_1.KeyboardPointerMetadata.CIRCLE_WIDTH}px`;
          containerElement.style.borderRadius = "100%";
        }
        onBeforeShow(containerElement, root, ...selectedElementIds) {
          this.render();
        }
        handle(action) {
          if (sprotty_1.TriggerNodeCreationAction.is(action)) {
            this._triggerAction = action;
          } else if (actions_1.SetKeyboardPointerRenderPositionAction.is(action)) {
            this.position.renderPosition = { x: action.x, y: action.y };
            this.render();
          } else if (action_1.KeyboardGridCellSelectedAction.is(action) && action.options.originId === constants_1.KeyboardPointerMetadata.ID) {
            this.position.renderPosition = action.options.centerCellPosition;
            this.render();
          }
        }
        render() {
          if (this.containerElement !== void 0) {
            const { x, y } = this.position.renderPosition;
            this.containerElement.style.left = `${x}px`;
            this.containerElement.style.top = `${y}px`;
            const { status } = this.position.containableParentAtDiagramPosition(this._triggerAction.elementTypeId);
            this.containerElement.style.borderStyle = "solid";
            this.containerElement.style.borderWidth = "thick";
            switch (status) {
              case css_feedback_1.CursorCSS.NODE_CREATION: {
                this.containerElement.style.borderColor = "green";
                break;
              }
              case css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED: {
                this.containerElement.style.borderColor = "red";
                break;
              }
            }
          }
        }
      };
      exports.KeyboardPointer = KeyboardPointer;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], KeyboardPointer.prototype, "editorContextService", void 0);
      exports.KeyboardPointer = KeyboardPointer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher)),
        __metadata("design:paramtypes", [Object])
      ], KeyboardPointer);
    }
  });

  // node_modules/@eclipse-glsp/client/css/keyboard.css
  var require_9 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/keyboard.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-grid.js
  var require_keyboard_grid = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-grid.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardGrid = void 0;
      require_9();
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var keyboard_1 = require_keyboard();
      var constants_1 = require_constants();
      var action_1 = require_action2();
      var KeyboardGrid = class KeyboardGrid extends sprotty_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.triggerActions = [];
        }
        id() {
          return constants_1.KeyboardGridMetadata.ID;
        }
        containerClass() {
          return constants_1.KeyboardGridMetadata.ID;
        }
        handle(action) {
          if (action_1.EnableKeyboardGridAction.is(action)) {
            this.triggerActions = action.options.triggerActions;
            this.originId = action.options.originId;
            this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({
              extensionId: constants_1.KeyboardGridMetadata.ID,
              visible: true
            }));
          }
        }
        initializeContents(containerElement) {
          containerElement.tabIndex = constants_1.KeyboardGridMetadata.TAB_INDEX;
          containerElement.classList.add("grid-container");
          for (let i = 1; i <= 9; i++) {
            const gridNumber = document.createElement("div");
            const gridItem = document.createElement("div");
            gridItem.classList.add("grid-item");
            gridItem.id = `keyboard-grid-item-${i}`;
            gridNumber.classList.add("grid-item-number");
            gridNumber.innerHTML = i.toString();
            gridItem.appendChild(gridNumber);
            containerElement.appendChild(gridItem);
          }
          this.containerElement.onkeydown = (ev) => {
            this.onKeyDown(ev);
          };
        }
        onKeyDown(event) {
          this.activateCellIfDigitEvent(event);
          this.hideIfEscapeEvent(event);
          this.actionDispatcher.dispatch(action_1.KeyboardGridKeyboardEventAction.create({
            originId: this.originId,
            event
          }));
        }
        setContainerVisible(visible) {
          if (this.containerElement) {
            if (visible) {
              this.containerElement.style.visibility = "visible";
              this.containerElement.style.opacity = "0.7";
            } else {
              this.containerElement.style.visibility = "hidden";
              this.containerElement.style.opacity = "0";
            }
          }
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.containerElement.focus();
        }
        hideIfEscapeEvent(event) {
          if (this.matchesDeactivateGrid(event)) {
            this.hide();
          }
        }
        activateCellIfDigitEvent(event) {
          let index = void 0;
          for (let i = 1; i <= 9; i++) {
            if (this.matchesGridBoxAtIndex(event, i)) {
              index = i;
              break;
            }
          }
          if (index !== void 0) {
            const position = this.centerPositionOfCell(index);
            this.dispatchActionsForCell(index, position);
          }
        }
        dispatchActionsForCell(index, cellCenter) {
          this.actionDispatcher.dispatchAll([
            ...this.triggerActions,
            action_1.KeyboardGridCellSelectedAction.create({
              originId: this.originId,
              cellId: index.toString(),
              centerCellPosition: cellCenter
            })
          ]);
        }
        centerPositionOfCell(index) {
          let x = 0;
          let y = 0;
          const activeGridCell = document.getElementById(`keyboard-grid-item-${index}`);
          if (activeGridCell !== null) {
            const positions = this.getCenterOfCell(activeGridCell);
            x = positions[0];
            y = positions[1];
          }
          return {
            x,
            y
          };
        }
        matchesDeactivateGrid(event) {
          return (0, keyboard_1.matchesKeystroke)(event, "Escape");
        }
        matchesGridBoxAtIndex(event, index) {
          return (0, keyboard_1.matchesKeystroke)(event, "Digit" + index) || (0, keyboard_1.matchesKeystroke)(event, "Numpad" + index);
        }
        // https://www.delftstack.com/howto/javascript/get-position-of-element-in-javascript/
        getOffset(el) {
          let _x = 0;
          let _y = 0;
          while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
            _x += el.offsetLeft - el.scrollLeft;
            _y += el.offsetTop - el.scrollTop;
            el = el.offsetParent;
          }
          return { top: _y, left: _x };
        }
        getCenterOfCell(cell) {
          const cellLeft = this.getOffset(cell).left;
          const cellTop = this.getOffset(cell).top;
          const cellWidth = cell.offsetWidth;
          const cellHeight = cell.offsetHeight;
          const newCellWidth = cellWidth / 2;
          const newCellHeight = cellHeight / 2;
          return [cellLeft + newCellWidth, cellTop + newCellHeight];
        }
      };
      exports.KeyboardGrid = KeyboardGrid;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", sprotty_1.ActionDispatcher)
      ], KeyboardGrid.prototype, "actionDispatcher", void 0);
      exports.KeyboardGrid = KeyboardGrid = __decorate([
        (0, inversify_1.injectable)()
      ], KeyboardGrid);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-tool.js
  var require_edge_autocomplete_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      var EdgeAutocompletePaletteTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeAutocompletePaletteKeyListener = exports.EdgeAutocompletePaletteTool = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var keyboard_1 = require_keyboard();
      var edge_autocomplete_palette_1 = require_edge_autocomplete_palette();
      var EdgeAutocompletePaletteTool = EdgeAutocompletePaletteTool_1 = class EdgeAutocompletePaletteTool {
        constructor() {
          this.keyListener = new EdgeAutocompletePaletteKeyListener();
        }
        get id() {
          return EdgeAutocompletePaletteTool_1.ID;
        }
        enable() {
          this.keyTool.register(this.keyListener);
        }
        disable() {
          this.keyTool.deregister(this.keyListener);
        }
      };
      exports.EdgeAutocompletePaletteTool = EdgeAutocompletePaletteTool;
      EdgeAutocompletePaletteTool.ID = "glsp.edge-autocomplete-palette-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], EdgeAutocompletePaletteTool.prototype, "keyTool", void 0);
      exports.EdgeAutocompletePaletteTool = EdgeAutocompletePaletteTool = EdgeAutocompletePaletteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeAutocompletePaletteTool);
      var EdgeAutocompletePaletteKeyListener = class extends sprotty_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            return [
              sprotty_1.SetUIExtensionVisibilityAction.create({
                extensionId: edge_autocomplete_palette_1.EdgeAutocompletePaletteMetadata.ID,
                visible: false,
                contextElementsId: []
              })
            ];
          }
          return [];
        }
      };
      exports.EdgeAutocompletePaletteKeyListener = EdgeAutocompletePaletteKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-grid-search-palette.js
  var require_keyboard_grid_search_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-grid-search-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GridRevealNamedElementSuggestionProvider = exports.GridRevealEdgeSuggestionProvider = exports.GridSearchPalette = exports.GridSearchPaletteMetadata = void 0;
      require_9();
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var search_palette_1 = require_search_palette();
      var constants_1 = require_constants();
      var GridSearchPaletteMetadata;
      (function(GridSearchPaletteMetadata2) {
        GridSearchPaletteMetadata2.ID = "grid-search-palette";
      })(GridSearchPaletteMetadata || (exports.GridSearchPaletteMetadata = GridSearchPaletteMetadata = {}));
      var GridSearchPalette = class GridSearchPalette extends search_palette_1.SearchAutocompletePalette {
        id() {
          return GridSearchPaletteMetadata.ID;
        }
        getSuggestionProviders(root, input) {
          return [new GridRevealNamedElementSuggestionProvider(), new GridRevealEdgeSuggestionProvider()];
        }
      };
      exports.GridSearchPalette = GridSearchPalette;
      exports.GridSearchPalette = GridSearchPalette = __decorate([
        (0, inversify_1.injectable)()
      ], GridSearchPalette);
      var GridRevealEdgeSuggestionProvider = class extends search_palette_1.RevealEdgeElementAutocompleteSuggestionProvider {
        getActions(edge) {
          return [
            ...super.getActions(edge),
            sprotty_1.SetUIExtensionVisibilityAction.create({
              extensionId: constants_1.KeyboardGridMetadata.ID,
              visible: true
            })
          ];
        }
      };
      exports.GridRevealEdgeSuggestionProvider = GridRevealEdgeSuggestionProvider;
      var GridRevealNamedElementSuggestionProvider = class extends search_palette_1.RevealNamedElementAutocompleteSuggestionProvider {
        getActions(nameable) {
          return [
            ...super.getActions(nameable),
            sprotty_1.SetUIExtensionVisibilityAction.create({
              extensionId: constants_1.KeyboardGridMetadata.ID,
              visible: true
            })
          ];
        }
      };
      exports.GridRevealNamedElementSuggestionProvider = GridRevealNamedElementSuggestionProvider;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-node-grid.js
  var require_keyboard_node_grid = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-node-grid.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardNodeGrid = void 0;
      require_9();
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var keyboard_1 = require_keyboard();
      var keyboard_pointer_1 = require_keyboard_pointer();
      var constants_1 = require_constants2();
      var keyboard_grid_search_palette_1 = require_keyboard_grid_search_palette();
      var keyboard_grid_1 = require_keyboard_grid();
      var constants_2 = require_constants();
      var KeyboardNodeGrid = class KeyboardNodeGrid extends keyboard_grid_1.KeyboardGrid {
        constructor() {
          super(...arguments);
          this.triggerActions = [sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: constants_1.KeyboardPointerMetadata.ID, visible: true })];
          this.originId = constants_1.KeyboardPointerMetadata.ID;
        }
        id() {
          return constants_2.KeyboardNodeGridMetadata.ID;
        }
        handle(action) {
        }
        onKeyDown(event) {
          super.onKeyDown(event);
          this.showSearchOnEvent(event);
          if (this.keyboardPointer.isVisible) {
            this.keyboardPointer.getKeyListener.keyDown(event);
          }
        }
        showSearchOnEvent(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyF", "ctrl")) {
            event.preventDefault();
            this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({
              extensionId: keyboard_grid_search_palette_1.GridSearchPaletteMetadata.ID,
              visible: true
            }));
            this.hide();
          }
        }
      };
      exports.KeyboardNodeGrid = KeyboardNodeGrid;
      __decorate([
        (0, inversify_1.inject)(keyboard_pointer_1.KeyboardPointer),
        __metadata("design:type", keyboard_pointer_1.KeyboardPointer)
      ], KeyboardNodeGrid.prototype, "keyboardPointer", void 0);
      exports.KeyboardNodeGrid = KeyboardNodeGrid = __decorate([
        (0, inversify_1.injectable)()
      ], KeyboardNodeGrid);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-module.js
  var require_keyboard_pointer_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureKeyboardControlTools = exports.keyboardControlModule = void 0;
      var sprotty_1 = require_lib5();
      var global_keylistener_tool_1 = require_global_keylistener_tool();
      var keyboard_pointer_1 = require_keyboard_pointer();
      var keyboard_grid_1 = require_keyboard_grid();
      var actions_1 = require_actions4();
      var edge_autocomplete_palette_1 = require_edge_autocomplete_palette();
      var edge_autocomplete_tool_1 = require_edge_autocomplete_tool();
      var action_1 = require_action3();
      var keyboard_grid_search_palette_1 = require_keyboard_grid_search_palette();
      var keyboard_node_grid_1 = require_keyboard_node_grid();
      var action_2 = require_action2();
      exports.keyboardControlModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureKeyboardControlTools(context);
      });
      function configureKeyboardControlTools(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, global_keylistener_tool_1.GlobalKeyListenerTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_pointer_1.KeyboardPointer);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_grid_1.KeyboardGrid);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_node_grid_1.KeyboardNodeGrid);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.TriggerNodeCreationAction.KIND, keyboard_pointer_1.KeyboardPointer);
        (0, sprotty_1.configureActionHandler)(context, actions_1.SetKeyboardPointerRenderPositionAction.KIND, keyboard_pointer_1.KeyboardPointer);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, edge_autocomplete_palette_1.EdgeAutocompletePalette);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, edge_autocomplete_tool_1.EdgeAutocompletePaletteTool);
        (0, sprotty_1.configureActionHandler)(context, action_2.EnableKeyboardGridAction.KIND, keyboard_grid_1.KeyboardGrid);
        (0, sprotty_1.configureActionHandler)(context, action_2.KeyboardGridCellSelectedAction.KIND, keyboard_pointer_1.KeyboardPointer);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.TriggerEdgeCreationAction.KIND, edge_autocomplete_palette_1.EdgeAutocompletePalette);
        (0, sprotty_1.configureActionHandler)(context, action_1.SetEdgeTargetSelectionAction.KIND, edge_autocomplete_palette_1.EdgeAutocompletePalette);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_grid_search_palette_1.GridSearchPalette);
      }
      exports.configureKeyboardControlTools = configureKeyboardControlTools;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/position-navigator.js
  var require_position_navigator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/position-navigator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PositionNavigator = void 0;
      var inversify_1 = require_inversify();
      var iterable_1 = require_iterable();
      var sprotty_1 = require_lib5();
      var action_dispatcher_1 = require_action_dispatcher2();
      var PositionNavigator = class PositionNavigator {
        previous(root, current, previousCurrent, predicate) {
          return this.getNearestElement(root, current, (e) => this.bounds(root, e).x < this.bounds(root, current).x);
        }
        next(root, current, previousCurrent, predicate) {
          return this.getNearestElement(root, current, (e) => this.bounds(root, e).x > this.bounds(root, current).x);
        }
        up(root, current, previousCurrent, predicate) {
          return this.getNearestElement(root, current, (e) => this.bounds(root, e).y < this.bounds(root, current).y);
        }
        down(root, current, previousCurrent, predicate) {
          return this.getNearestElement(root, current, (e) => this.bounds(root, e).y > this.bounds(root, current).y);
        }
        getNearestElement(root, current, filter) {
          const elements = this.boundElements(root).filter(filter);
          return this.sortByDistance(root, current, elements)[0];
        }
        sortByDistance(root, current, elements) {
          const distance = (coor1, coor2) => {
            const x = coor2.x - coor1.x;
            const y = coor2.y - coor1.y;
            return Math.sqrt(x * x + y * y);
          };
          return elements.sort((a, b) => distance(this.bounds(root, a), this.bounds(root, current)) - distance(this.bounds(root, b), this.bounds(root, current)));
        }
        boundElements(root) {
          return (0, iterable_1.toArray)(root.index.all().filter((e) => e instanceof sprotty_1.GNode && (0, sprotty_1.isSelectable)(e) && (0, sprotty_1.isBoundsAware)(e)));
        }
        bounds(root, element) {
          return this.boundsInViewport(element, element.bounds, root);
        }
        boundsInViewport(element, bounds, viewport) {
          if (element instanceof sprotty_1.GChildElement && element.parent !== viewport) {
            return this.boundsInViewport(element.parent, element.parent.localToParent(bounds), viewport);
          } else {
            return bounds;
          }
        }
      };
      exports.PositionNavigator = PositionNavigator;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], PositionNavigator.prototype, "actionDispatcher", void 0);
      exports.PositionNavigator = PositionNavigator = __decorate([
        (0, inversify_1.injectable)()
      ], PositionNavigator);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/local-element-navigator.js
  var require_local_element_navigator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/local-element-navigator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __metadata = exports && exports.__metadata || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalElementNavigator = void 0;
      var sprotty_1 = require_lib5();
      var inversify_1 = require_inversify();
      var action_dispatcher_1 = require_action_dispatcher2();
      var css_feedback_1 = require_css_feedback();
      var model_1 = require_model21();
      var LocalElementNavigator = class LocalElementNavigator {
        constructor() {
          this.navigableElementCSS = "navigable-element";
        }
        previous(root, current, previousCurrent, predicate) {
          return this.getPreviousElement(current, predicate);
        }
        next(root, current, previousCurrent, predicate) {
          return this.getNextElement(current, predicate);
        }
        up(root, current, previousCurrent, predicate) {
          return this.getIterable(current, previousCurrent, predicate);
        }
        down(root, current, previousCurrent, predicate) {
          return this.getIterable(current, previousCurrent, predicate);
        }
        process(root, current, target, previousCurrent, predicate) {
          let elements = [];
          if (target instanceof model_1.GEdge) {
            if (current instanceof model_1.GEdge) {
              elements = this.getIterables(target, current.source === target.source ? current.source : current.target, predicate);
            } else {
              elements = this.getIterables(target, current, predicate);
            }
          }
          elements.filter((e) => e.id !== target.id).forEach((e) => this.actionDispatcher.dispatch((0, css_feedback_1.applyCssClasses)(e, this.navigableElementCSS)));
        }
        clean(root, current, previousCurrent) {
          root.index.all().forEach((e) => this.actionDispatcher.dispatch((0, css_feedback_1.deleteCssClasses)(e, this.navigableElementCSS)));
        }
        getIterables(current, previousCurrent, predicate = () => true) {
          var _a, _b;
          const elements = [];
          if (current instanceof model_1.GEdge) {
            if (current.target === previousCurrent) {
              (_a = current.target) === null || _a === void 0 ? void 0 : _a.incomingEdges.forEach((e) => elements.push(e));
            } else {
              (_b = current.source) === null || _b === void 0 ? void 0 : _b.outgoingEdges.forEach((e) => elements.push(e));
            }
          }
          return elements.filter(predicate);
        }
        getIterable(current, previousCurrent, predicate = () => true) {
          return this.getIterables(current, previousCurrent, predicate).filter((e) => e.id !== current.id)[0];
        }
        getNextElement(current, predicate = () => true) {
          const elements = [];
          if (current instanceof sprotty_1.GConnectableElement) {
            current.outgoingEdges.forEach((e) => elements.push(e));
          } else if (current instanceof model_1.GEdge) {
            const target = current.target;
            elements.push(target);
          }
          return elements.filter(predicate)[0];
        }
        getPreviousElement(current, predicate = () => true) {
          const elements = [];
          if (current instanceof sprotty_1.GConnectableElement) {
            current.incomingEdges.forEach((e) => elements.push(e));
          } else if (current instanceof model_1.GEdge) {
            const source = current.source;
            elements.push(source);
          }
          return elements.filter(predicate)[0];
        }
      };
      exports.LocalElementNavigator = LocalElementNavigator;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], LocalElementNavigator.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.GLSPActionDispatcher)
      ], LocalElementNavigator.prototype, "actionDispatcher", void 0);
      exports.LocalElementNavigator = LocalElementNavigator = __decorate([
        (0, inversify_1.injectable)()
      ], LocalElementNavigator);
    }
  });

  // node_modules/@eclipse-glsp/client/css/navigation.css
  var require_10 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/navigation.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/element-navigation-module.js
  var require_element_navigation_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/element-navigation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureElementNavigationTool = exports.glspElementNavigationModule = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      var position_navigator_1 = require_position_navigator();
      var local_element_navigator_1 = require_local_element_navigator();
      var diagram_navigation_tool_1 = require_diagram_navigation_tool();
      require_10();
      exports.glspElementNavigationModule = new inversify_1.ContainerModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureElementNavigationTool(context);
      });
      function configureElementNavigationTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, diagram_navigation_tool_1.ElementNavigatorTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IElementNavigator, position_navigator_1.PositionNavigator);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ILocalElementNavigator, local_element_navigator_1.LocalElementNavigator);
      }
      exports.configureElementNavigationTool = configureElementNavigationTool;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/focus-tracker/focus-tracker-module.js
  var require_focus_tracker_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/focus-tracker/focus-tracker-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureFocusTrackerTool = exports.glspFocusTrackerModule = void 0;
      var inversify_1 = require_inversify();
      var focus_tracker_tool_1 = require_focus_tracker_tool();
      var sprotty_1 = require_lib5();
      exports.glspFocusTrackerModule = new inversify_1.ContainerModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureFocusTrackerTool(context);
      });
      function configureFocusTrackerTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, focus_tracker_tool_1.FocusTrackerTool);
      }
      exports.configureFocusTrackerTool = configureFocusTrackerTool;
    }
  });

  // node_modules/@eclipse-glsp/client/css/toast.css
  var require_11 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/toast.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-module.js
  var require_toast_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureToastTool = exports.glspToastModule = void 0;
      var inversify_1 = require_inversify();
      var sprotty_1 = require_lib5();
      require_11();
      var toast_handler_1 = require_toast_handler();
      var toast_tool_1 = require_toast_tool();
      exports.glspToastModule = new inversify_1.ContainerModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureToastTool(context);
      });
      function configureToastTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, toast_tool_1.Toast);
        context.bind(sprotty_1.TYPES.IDiagramStartup).toService(toast_tool_1.Toast);
        (0, sprotty_1.configureActionHandler)(context, toast_handler_1.ShowToastMessageAction.KIND, toast_tool_1.Toast);
        (0, sprotty_1.configureActionHandler)(context, toast_handler_1.HideToastAction.KIND, toast_tool_1.Toast);
      }
      exports.configureToastTool = configureToastTool;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/accessibility-module.js
  var require_accessibility_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/accessibility-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.accessibilityModule = void 0;
      var sprotty_1 = require_lib5();
      var di_config_1 = require_di_config23();
      var move_zoom_module_1 = require_move_zoom_module();
      var resize_key_module_1 = require_resize_key_module();
      var search_palette_module_1 = require_search_palette_module();
      var view_key_tools_module_1 = require_view_key_tools_module();
      var keyboard_tool_palette_module_1 = require_keyboard_tool_palette_module();
      var keyboard_pointer_module_1 = require_keyboard_pointer_module();
      var element_navigation_module_1 = require_element_navigation_module();
      var focus_tracker_module_1 = require_focus_tracker_module();
      var toast_module_1 = require_toast_module();
      exports.accessibilityModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, resize_key_module_1.configureResizeTools)(context);
        (0, view_key_tools_module_1.configureViewKeyTools)(context);
        (0, move_zoom_module_1.configureMoveZoom)(context);
        (0, search_palette_module_1.configureSearchPaletteModule)(context);
        (0, di_config_1.configureShortcutHelpTool)(context);
        (0, keyboard_tool_palette_module_1.configureKeyboardToolPaletteTool)(context);
        (0, keyboard_pointer_module_1.configureKeyboardControlTools)(context);
        (0, element_navigation_module_1.configureElementNavigationTool)(context);
        (0, focus_tracker_module_1.configureFocusTrackerTool)(context);
        (0, toast_module_1.configureToastTool)(context);
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_lib5(), exports);
      __exportStar(require_action_dispatcher2(), exports);
      __exportStar(require_action_handler_registry(), exports);
      __exportStar(require_args_feature(), exports);
      __exportStar(require_auto_complete_actions(), exports);
      __exportStar(require_auto_complete_widget(), exports);
      __exportStar(require_validation_decorator(), exports);
      __exportStar(require_command_stack2(), exports);
      __exportStar(require_drag_aware_mouse_listener(), exports);
      __exportStar(require_editor_context_service(), exports);
      __exportStar(require_feedback_action_dispatcher(), exports);
      __exportStar(require_feedback_command(), exports);
      __exportStar(require_update_model_command(), exports);
      __exportStar(require_focus_state_change_action(), exports);
      __exportStar(require_focus_tracker(), exports);
      __exportStar(require_diagram_loader(), exports);
      __exportStar(require_glsp_model_source(), exports);
      __exportStar(require_model_initialization_constraint(), exports);
      __exportStar(require_model_registry(), exports);
      __exportStar(require_ranked(), exports);
      __exportStar(require_selection_clearing_mouse_listener(), exports);
      __exportStar(require_selection_service(), exports);
      __exportStar(require_tool(), exports);
      __exportStar(require_tool_manager(), exports);
      __exportStar(require_mouse_tool2(), exports);
      __exportStar(require_view_registry(), exports);
      __exportStar(require_css_feedback(), exports);
      __exportStar(require_mouse_tool2(), exports);
      __exportStar(require_diagram_navigation_tool(), exports);
      __exportStar(require_focus_tracker_tool(), exports);
      __exportStar(require_accessible_key_shortcut_tool(), exports);
      __exportStar(require_resize_key_tool(), exports);
      __exportStar(require_toast_tool(), exports);
      __exportStar(require_deselect_key_tool(), exports);
      __exportStar(require_movement_key_tool(), exports);
      __exportStar(require_zoom_key_tool(), exports);
      __exportStar(require_freeform_layout(), exports);
      __exportStar(require_glsp_hidden_bounds_updater(), exports);
      __exportStar(require_hbox_layout2(), exports);
      __exportStar(require_layouter(), exports);
      __exportStar(require_vbox_layout2(), exports);
      __exportStar(require_model22(), exports);
      __exportStar(require_movement_restrictor(), exports);
      __exportStar(require_snap2(), exports);
      __exportStar(require_command_palette_tool(), exports);
      __exportStar(require_server_command_palette_provider(), exports);
      __exportStar(require_delete_element_context_menu(), exports);
      __exportStar(require_glsp_context_menu_mouse_listener(), exports);
      __exportStar(require_server_context_menu_provider(), exports);
      __exportStar(require_copy_paste_context_menu(), exports);
      __exportStar(require_copy_paste_handler(), exports);
      __exportStar(require_decoration_placer2(), exports);
      __exportStar(require_glsp_svg_exporter(), exports);
      __exportStar(require_model20(), exports);
      __exportStar(require_type_hint_provider(), exports);
      __exportStar(require_hover2(), exports);
      __exportStar(require_edit_label_tool(), exports);
      __exportStar(require_edit_label_validator(), exports);
      __exportStar(require_layout_elements_action(), exports);
      __exportStar(require_navigation_action_handler(), exports);
      __exportStar(require_navigation_target_resolver(), exports);
      __exportStar(require_model23(), exports);
      __exportStar(require_glsp_manhattan_edge_router(), exports);
      __exportStar(require_save_keylistener(), exports);
      __exportStar(require_select_feedback_command(), exports);
      __exportStar(require_select_mouse_listener(), exports);
      __exportStar(require_source_model_changed_action_handler(), exports);
      __exportStar(require_status_overlay(), exports);
      __exportStar(require_metadata_placer(), exports);
      __exportStar(require_tool_palette2(), exports);
      __exportStar(require_base_tools(), exports);
      __exportStar(require_change_bounds_tool(), exports);
      __exportStar(require_change_bounds_tool_feedback(), exports);
      __exportStar(require_view3(), exports);
      __exportStar(require_delete_tool(), exports);
      __exportStar(require_edge_creation_tool(), exports);
      __exportStar(require_edge_creation_tool_feedback(), exports);
      __exportStar(require_view2(), exports);
      __exportStar(require_edge_edit_tool(), exports);
      __exportStar(require_edge_edit_tool_feedback(), exports);
      __exportStar(require_marquee_behavior(), exports);
      __exportStar(require_marquee_mouse_tool(), exports);
      __exportStar(require_marquee_tool(), exports);
      __exportStar(require_marquee_tool_feedback(), exports);
      __exportStar(require_model24(), exports);
      __exportStar(require_view4(), exports);
      __exportStar(require_node_creation_tool(), exports);
      __exportStar(require_undo_redo_key_listener(), exports);
      __exportStar(require_issue_marker(), exports);
      __exportStar(require_marker_navigator(), exports);
      __exportStar(require_validate(), exports);
      __exportStar(require_glsp_scroll_mouse_listener(), exports);
      __exportStar(require_default_modules(), exports);
      __exportStar(require_model21(), exports);
      __exportStar(require_standalone_modules(), exports);
      __exportStar(require_argument_utils(), exports);
      __exportStar(require_gmodel_util(), exports);
      __exportStar(require_html_utils(), exports);
      __exportStar(require_layout_utils(), exports);
      __exportStar(require_marker(), exports);
      __exportStar(require_viewpoint_util(), exports);
      __exportStar(require_views7(), exports);
      __exportStar(require_default_module(), exports);
      __exportStar(require_accessibility_module(), exports);
      __exportStar(require_element_navigation_module(), exports);
      __exportStar(require_focus_tracker_module(), exports);
      __exportStar(require_move_zoom_module(), exports);
      __exportStar(require_resize_key_module(), exports);
      __exportStar(require_search_palette_module(), exports);
      __exportStar(require_toast_module(), exports);
      __exportStar(require_view_key_tools_module(), exports);
      __exportStar(require_command_palette_module(), exports);
      __exportStar(require_context_menu_module(), exports);
      __exportStar(require_copy_paste_modules(), exports);
      __exportStar(require_decoration_module(), exports);
      __exportStar(require_export_modules(), exports);
      __exportStar(require_type_hints_module(), exports);
      __exportStar(require_hover_module(), exports);
      __exportStar(require_label_edit_module(), exports);
      __exportStar(require_layout_module(), exports);
      __exportStar(require_navigation_module(), exports);
      __exportStar(require_routing_module(), exports);
      __exportStar(require_save_module(), exports);
      __exportStar(require_select_module(), exports);
      __exportStar(require_source_model_wacher_module(), exports);
      __exportStar(require_status_module(), exports);
      __exportStar(require_svg_metadata_module(), exports);
      __exportStar(require_tool_palette_module(), exports);
      __exportStar(require_change_boounds_tool_module(), exports);
      __exportStar(require_deletion_tool_module(), exports);
      __exportStar(require_edege_creation_module(), exports);
      __exportStar(require_edge_edit_module(), exports);
      __exportStar(require_marquee_selection_module(), exports);
      __exportStar(require_node_creation_module(), exports);
      __exportStar(require_tool_focus_loss_module(), exports);
      __exportStar(require_undo_redo_module(), exports);
      __exportStar(require_validation_modules(), exports);
      __exportStar(require_viewport_modules(), exports);
    }
  });

  // node_modules/reflect-metadata/Reflect.js
  var Reflect2;
  (function(Reflect3) {
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
      var exporter = makeExporter(Reflect3);
      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect3;
      } else {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory(exporter);
      function makeExporter(target, previous) {
        return function(key, value) {
          if (typeof target[key] !== "function") {
            Object.defineProperty(target, key, { configurable: true, writable: true, value });
          }
          if (previous)
            previous(key, value);
        };
      }
    })(function(exporter) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
      var supportsCreate = typeof Object.create === "function";
      var supportsProto = { __proto__: [] } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        create: supportsCreate ? function() {
          return MakeDictionary(/* @__PURE__ */ Object.create(null));
        } : supportsProto ? function() {
          return MakeDictionary({ __proto__: null });
        } : function() {
          return MakeDictionary({});
        },
        has: downLevel ? function(map, key) {
          return hasOwn.call(map, key);
        } : function(map, key) {
          return key in map;
        },
        get: downLevel ? function(map, key) {
          return hasOwn.call(map, key) ? map[key] : void 0;
        } : function(map, key) {
          return map[key];
        }
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
      var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
      var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
      var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
      var Metadata = new _WeakMap();
      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators))
            throw new TypeError();
          if (!IsObject(target))
            throw new TypeError();
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
            throw new TypeError();
          if (IsNull(attributes))
            attributes = void 0;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators))
            throw new TypeError();
          if (!IsConstructor(target))
            throw new TypeError();
          return DecorateConstructor(decorators, target);
        }
      }
      exporter("decorate", decorate);
      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
            throw new TypeError();
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
      }
      exporter("metadata", metadata);
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter("defineMetadata", defineMetadata);
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasMetadata", hasMetadata);
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasOwnMetadata", hasOwnMetadata);
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter("getMetadata", getMetadata);
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("getOwnMetadata", getOwnMetadata);
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter("getMetadataKeys", getMetadataKeys);
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter("getOwnMetadataKeys", getOwnMetadataKeys);
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        var metadataMap = GetOrCreateMetadataMap(
          target,
          propertyKey,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(metadataKey))
          return false;
        if (metadataMap.size > 0)
          return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(propertyKey);
        if (targetMetadata.size > 0)
          return true;
        Metadata.delete(target);
        return true;
      }
      exporter("deleteMetadata", deleteMetadata);
      function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated))
              throw new TypeError();
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target, propertyKey, descriptor);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated))
              throw new TypeError();
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          Metadata.set(O, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P, metadataMap);
        }
        return metadataMap;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryGetMetadata(MetadataKey, parent, P);
        return void 0;
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
          return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
          return ownKeys;
        if (ownKeys.length <= 0)
          return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(
          O,
          P,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (!next) {
            keys.length = k;
            return keys;
          }
          var nextValue = IteratorValue(next);
          try {
            keys[k] = nextValue;
          } catch (e) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e;
            }
          }
          k++;
        }
      }
      function Type(x) {
        if (x === null)
          return 1;
        switch (typeof x) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return x === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined(x) {
        return x === void 0;
      }
      function IsNull(x) {
        return x === null;
      }
      function IsSymbol(x) {
        return typeof x === "symbol";
      }
      function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
            return input;
          case 1:
            return input;
          case 2:
            return input;
          case 3:
            return input;
          case 4:
            return input;
          case 5:
            return input;
        }
        var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== void 0) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result))
            throw new TypeError();
          return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result))
              return result;
          }
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
        } else {
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
          var toString_2 = O.toString;
          if (IsCallable(toString_2)) {
            var result = toString_2.call(O);
            if (!IsObject(result))
              return result;
          }
        }
        throw new TypeError();
      }
      function ToBoolean(argument) {
        return !!argument;
      }
      function ToString(argument) {
        return "" + argument;
      }
      function ToPropertyKey(argument) {
        var key = ToPrimitive(
          argument,
          3
          /* String */
        );
        if (IsSymbol(key))
          return key;
        return ToString(key);
      }
      function IsArray(argument) {
        return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
      }
      function IsCallable(argument) {
        return typeof argument === "function";
      }
      function IsConstructor(argument) {
        return typeof argument === "function";
      }
      function IsPropertyKey(argument) {
        switch (Type(argument)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function GetMethod(V, P) {
        var func = V[P];
        if (func === void 0 || func === null)
          return void 0;
        if (!IsCallable(func))
          throw new TypeError();
        return func;
      }
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
          throw new TypeError();
        var iterator = method.call(obj);
        if (!IsObject(iterator))
          throw new TypeError();
        return iterator;
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
      }
      function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
          f.call(iterator);
      }
      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
          return proto;
        if (proto !== functionPrototype)
          return proto;
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
          return proto;
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
          return proto;
        if (constructor === O)
          return proto;
        return constructor;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (
          /** @class */
          function() {
            function MapIterator2(keys, values, selector) {
              this._index = 0;
              this._keys = keys;
              this._values = values;
              this._selector = selector;
            }
            MapIterator2.prototype["@@iterator"] = function() {
              return this;
            };
            MapIterator2.prototype[iteratorSymbol] = function() {
              return this;
            };
            MapIterator2.prototype.next = function() {
              var index = this._index;
              if (index >= 0 && index < this._keys.length) {
                var result = this._selector(this._keys[index], this._values[index]);
                if (index + 1 >= this._keys.length) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                } else {
                  this._index++;
                }
                return { value: result, done: false };
              }
              return { value: void 0, done: true };
            };
            MapIterator2.prototype.throw = function(error) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              throw error;
            };
            MapIterator2.prototype.return = function(value) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              return { value, done: true };
            };
            return MapIterator2;
          }()
        );
        return (
          /** @class */
          function() {
            function Map2() {
              this._keys = [];
              this._values = [];
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            Object.defineProperty(Map2.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: true,
              configurable: true
            });
            Map2.prototype.has = function(key) {
              return this._find(
                key,
                /*insert*/
                false
              ) >= 0;
            };
            Map2.prototype.get = function(key) {
              var index = this._find(
                key,
                /*insert*/
                false
              );
              return index >= 0 ? this._values[index] : void 0;
            };
            Map2.prototype.set = function(key, value) {
              var index = this._find(
                key,
                /*insert*/
                true
              );
              this._values[index] = value;
              return this;
            };
            Map2.prototype.delete = function(key) {
              var index = this._find(
                key,
                /*insert*/
                false
              );
              if (index >= 0) {
                var size = this._keys.length;
                for (var i = index + 1; i < size; i++) {
                  this._keys[i - 1] = this._keys[i];
                  this._values[i - 1] = this._values[i];
                }
                this._keys.length--;
                this._values.length--;
                if (key === this._cacheKey) {
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                return true;
              }
              return false;
            };
            Map2.prototype.clear = function() {
              this._keys.length = 0;
              this._values.length = 0;
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            };
            Map2.prototype.keys = function() {
              return new MapIterator(this._keys, this._values, getKey);
            };
            Map2.prototype.values = function() {
              return new MapIterator(this._keys, this._values, getValue);
            };
            Map2.prototype.entries = function() {
              return new MapIterator(this._keys, this._values, getEntry);
            };
            Map2.prototype["@@iterator"] = function() {
              return this.entries();
            };
            Map2.prototype[iteratorSymbol] = function() {
              return this.entries();
            };
            Map2.prototype._find = function(key, insert) {
              if (this._cacheKey !== key) {
                this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
              }
              if (this._cacheIndex < 0 && insert) {
                this._cacheIndex = this._keys.length;
                this._keys.push(key);
                this._values.push(void 0);
              }
              return this._cacheIndex;
            };
            return Map2;
          }()
        );
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      function CreateSetPolyfill() {
        return (
          /** @class */
          function() {
            function Set2() {
              this._map = new _Map();
            }
            Object.defineProperty(Set2.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: true,
              configurable: true
            });
            Set2.prototype.has = function(value) {
              return this._map.has(value);
            };
            Set2.prototype.add = function(value) {
              return this._map.set(value, value), this;
            };
            Set2.prototype.delete = function(value) {
              return this._map.delete(value);
            };
            Set2.prototype.clear = function() {
              this._map.clear();
            };
            Set2.prototype.keys = function() {
              return this._map.keys();
            };
            Set2.prototype.values = function() {
              return this._map.values();
            };
            Set2.prototype.entries = function() {
              return this._map.entries();
            };
            Set2.prototype["@@iterator"] = function() {
              return this.keys();
            };
            Set2.prototype[iteratorSymbol] = function() {
              return this.keys();
            };
            return Set2;
          }()
        );
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (
          /** @class */
          function() {
            function WeakMap2() {
              this._key = CreateUniqueKey();
            }
            WeakMap2.prototype.has = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? HashMap.has(table, this._key) : false;
            };
            WeakMap2.prototype.get = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? HashMap.get(table, this._key) : void 0;
            };
            WeakMap2.prototype.set = function(target, value) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                true
              );
              table[this._key] = value;
              return this;
            };
            WeakMap2.prototype.delete = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? delete table[this._key] : false;
            };
            WeakMap2.prototype.clear = function() {
              this._key = CreateUniqueKey();
            };
            return WeakMap2;
          }()
        );
        function CreateUniqueKey() {
          var key;
          do
            key = "@@WeakMap@@" + CreateUUID();
          while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create)
              return void 0;
            Object.defineProperty(target, rootKey, { value: HashMap.create() });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i = 0; i < size; ++i)
            buffer[i] = Math.random() * 255 | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            if (typeof crypto !== "undefined")
              return crypto.getRandomValues(new Uint8Array(size));
            if (typeof msCrypto !== "undefined")
              return msCrypto.getRandomValues(new Uint8Array(size));
            return FillRandomBytes(new Uint8Array(size), size);
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = data[6] & 79 | 64;
          data[8] = data[8] & 191 | 128;
          var result = "";
          for (var offset = 0; offset < UUID_SIZE; ++offset) {
            var byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8)
              result += "-";
            if (byte < 16)
              result += "0";
            result += byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        obj.__ = void 0;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect2 || (Reflect2 = {}));

  // index.ts
  var import_sprotty10 = __toESM(require_lib2());

  // di.config.ts
  var import_inversify9 = __toESM(require_inversify());
  var import_sprotty9 = __toESM(require_lib2());

  // views.tsx
  var import_jsx = __toESM(require_jsx());
  var import_inversify = __toESM(require_inversify());
  var import_sprotty = __toESM(require_lib2());
  var import_sprotty_protocol = __toESM(require_lib());
  var Node4diacView = class extends import_sprotty.ShapeView {
    render(node, context, args) {
      if (!this.isVisible(node, context)) {
        return void 0;
      }
      let d = 20;
      let path = `M 0 0 H${node.size.width} v${d} h${-d} v${d} h${d} V ${node.size.height} H0 V${d * 2} h${d} v${-d} h${-d} Z`;
      return /* @__PURE__ */ (0, import_jsx.svg)("g", { "class-b4diac": true }, /* @__PURE__ */ (0, import_jsx.svg)("path", { d: path, fill: "transparent" }), context.renderChildren(node));
    }
  };
  Node4diacView = __decorateClass([
    (0, import_inversify.injectable)()
  ], Node4diacView);
  var PortViewWithExternalLabel = class extends import_sprotty.ShapeView {
    render(node, context) {
      if (!this.isVisible(node, context)) {
        return void 0;
      }
      const bboxElement = /* @__PURE__ */ (0, import_jsx.svg)(
        "rect",
        {
          "class-sprotty-port": true,
          "class-mouseover": node.hoverFeedback,
          "class-selected": node.selected,
          x: "0",
          y: "0",
          width: Math.max(node.size.width, 0),
          height: Math.max(node.size.height, 0)
        }
      );
      return /* @__PURE__ */ (0, import_jsx.svg)("g", null, bboxElement, context.renderChildren(node));
    }
  };
  PortViewWithExternalLabel = __decorateClass([
    (0, import_inversify.injectable)()
  ], PortViewWithExternalLabel);
  var WorkflowEdgeView = class extends import_sprotty.PolylineEdgeViewWithGapsOnIntersections {
    renderAdditionals(edge, segments, context) {
      const additionals = super.renderAdditionals(edge, segments, context);
      const p1 = segments[segments.length - 2];
      const p2 = segments[segments.length - 1];
      const arrow = /* @__PURE__ */ (0, import_jsx.svg)(
        "path",
        {
          "class-sprotty-edge": true,
          "class-arrow": true,
          d: "M 1,0 L 10,-4 L 10,4 Z",
          transform: `rotate(${(0, import_sprotty_protocol.toDegrees)((0, import_sprotty_protocol.angleOfPoint)({ x: p1.x - p2.x, y: p1.y - p2.y }))} ${p2.x} ${p2.y}) translate(${p2.x} ${p2.y})`
        }
      );
      additionals.push(arrow);
      return additionals;
    }
  };
  WorkflowEdgeView = __decorateClass([
    (0, import_inversify.injectable)()
  ], WorkflowEdgeView);

  // models.ts
  var import_sprotty2 = __toESM(require_lib2());
  var Node4diac = class extends import_sprotty2.RectangularNode {
  };
  Node4diac.DEFAULT_FEATURES = [
    import_sprotty2.selectFeature,
    import_sprotty2.moveFeature,
    import_sprotty2.boundsFeature
  ];

  // model-source.ts
  var import_sprotty4 = __toESM(require_lib2());
  var import_inversify3 = __toESM(require_inversify());

  // features/creatingNodes/creatingNodes.ts
  var import_client = __toESM(require_lib6());
  var import_sprotty3 = __toESM(require_lib2());
  var import_inversify2 = __toESM(require_inversify());
  var CreatingInpAction;
  ((CreatingInpAction2) => {
    CreatingInpAction2.KIND = "CreatingInp";
    function create(parentId) {
      return {
        kind: CreatingInpAction2.KIND,
        parentId
      };
    }
    CreatingInpAction2.create = create;
  })(CreatingInpAction || (CreatingInpAction = {}));
  var CreatingFbAction;
  ((CreatingFbAction2) => {
    CreatingFbAction2.KIND = "CreatingFb";
    function create(point) {
      return {
        kind: CreatingFbAction2.KIND,
        point
      };
    }
    CreatingFbAction2.create = create;
  })(CreatingFbAction || (CreatingFbAction = {}));
  var DroppableMouseListener = class extends import_client.MouseListener {
    //   @inject(NodeCreator) nodeCreator: (point: Point, type: string) => void;
    dragOver(target, event) {
      event.preventDefault();
      return [];
    }
    drop(target, e) {
      let actions = [];
      let type = e.dataTransfer.getData("text/plain");
      if (type == "INP") {
        if (!(target instanceof Node4diac)) {
          target = (0, import_sprotty3.findParent)(target, (item) => item.type == "node4diac");
        }
        if (target instanceof Node4diac) {
          actions = [
            CreatingInpAction.create(target.id)
            // CreatingNodeAction.create(),
          ];
        }
      } else if (type == "FB") {
        let point = { x: e.offsetX, y: e.offsetY };
        actions = [CreatingFbAction.create(point)];
      }
      return actions;
    }
  };
  DroppableMouseListener = __decorateClass([
    (0, import_inversify2.injectable)()
  ], DroppableMouseListener);

  // model-source.ts
  var ClassDiagramModelSource = class extends import_sprotty4.LocalModelSource {
    constructor() {
      super();
      this.currentRoot = this.initializeModel();
    }
    initialize(registry) {
      super.initialize(registry);
      registry.register(CreatingFbAction.KIND, this);
      registry.register(CreatingInpAction.KIND, this);
    }
    handle(action) {
      switch (action.kind) {
        case CreatingInpAction.KIND:
          this.creatingInp(action);
          break;
        case CreatingFbAction.KIND:
          this.creatingFb(action);
          break;
        default:
          super.handle(action);
      }
    }
    async creatingFb(action) {
      await this.actionDispatcher.dispatch(import_sprotty4.CommitModelAction.create());
      let point = action.point;
      const viewport = await this.getViewport();
      const adjust = (offset) => {
        return offset / viewport.zoom - 100 / 2;
      };
      let position = {
        x: viewport.scroll.x + adjust(point.x),
        y: viewport.scroll.y + adjust(point.y)
      };
      let id = (0, import_sprotty4.createRandomId)();
      let newNode = {
        id,
        type: "node4diac",
        position,
        size: { width: 100, height: 100 },
        layoutOptions: {
          resizeContainer: true
        },
        children: [
          {
            id: `${id}_title`,
            text: "FB #" + (this.model.children.filter((item) => item.type == "node4diac").length + 1),
            type: "node4diac:title",
            position: { x: 20, y: 0 }
          },
          {
            id: `${id}_inputs`,
            position: { x: 0, y: 50 },
            type: "node4diac:inputs",
            layout: "vbox",
            layoutOptions: {
              hAlign: "left",
              resizeContainer: true
            },
            children: []
          }
        ]
      };
      this.addElements([{ element: newNode, parentId: this.model.id }]);
    }
    async creatingInp(action) {
      await this.actionDispatcher.dispatch(import_sprotty4.CommitModelAction.create());
      let id = (0, import_sprotty4.createRandomId)();
      let parent = this.model.children.find((item) => item.id == action.parentId);
      if (parent) {
        let inputs = parent.children.find(
          (item) => item.type == "node4diac:inputs"
        );
        if (inputs) {
          this.addElements([
            {
              element: {
                type: "node4diac:port",
                id,
                children: [
                  {
                    id: `${id}_title`,
                    text: "INP",
                    type: "node4diac:port_title"
                  }
                ]
              },
              parentId: inputs.id
            }
          ]);
          this.updateModel();
        }
      }
    }
    initializeModel() {
      let node1 = {
        id: "node1",
        type: "node4diac",
        position: {
          x: 100,
          y: 100
        },
        size: { width: 100, height: 100 },
        // layout: "vbox",
        // layoutOptions: {
        //   resizeContainer: true,
        // },
        children: [
          {
            id: "node1_title",
            text: "FB #1",
            type: "node4diac:title",
            position: { x: 20, y: 0 }
          },
          {
            id: "node1_inputs",
            position: { x: 0, y: 50 },
            type: "node4diac:inputs",
            layout: "vbox",
            layoutOptions: {
              hAlign: "left",
              resizeContainer: true
            },
            children: [
              {
                id: "node1_port1",
                type: "node4diac:port",
                // anchorKind: "diamond",
                children: [
                  {
                    id: "node1_port_title1",
                    text: "INP",
                    type: "node4diac:port_title"
                  }
                ]
              },
              {
                id: "node1_port2",
                type: "node4diac:port",
                // anchorKind: "diamond",
                children: [
                  {
                    id: "node1_port_title2",
                    text: "INP",
                    type: "node4diac:port_title"
                  }
                ]
              }
            ]
          }
        ]
      };
      let node2 = {
        id: "node2",
        type: "node4diac",
        position: {
          x: 300,
          y: 300
        },
        size: { width: 100, height: 100 },
        children: [
          {
            id: "node2_title",
            text: "FB #2",
            type: "node4diac:title",
            position: { x: 20, y: 0 }
          },
          {
            id: "node2_inputs",
            position: { x: 0, y: 50 },
            type: "node4diac:inputs",
            layout: "vbox",
            layoutOptions: {
              hAlign: "left"
            },
            children: [
              {
                id: "node2_port1",
                type: "node4diac:port",
                // anchorKind: "diamond",
                children: [
                  {
                    id: "node2_port_title1",
                    text: "INP",
                    type: "node4diac:port_title"
                  }
                ]
              },
              {
                id: "node2_port2",
                type: "node4diac:port",
                // anchorKind: "diamond",
                children: [
                  {
                    id: "node2_port_title2",
                    text: "INP",
                    type: "node4diac:port_title"
                  }
                ]
              }
            ]
          }
        ]
      };
      const graph = {
        id: "root",
        type: "graph",
        children: [node1, node2],
        layoutOptions: {
          // hGap: 5,
          // paddingLeft: 7,
          // paddingRight: 7,
          // paddingTop: 7,
          // paddingBottom: 7,
        }
      };
      return graph;
    }
  };
  ClassDiagramModelSource = __decorateClass([
    (0, import_inversify3.injectable)()
  ], ClassDiagramModelSource);

  // features/creatingEdge/di.config.ts
  var import_inversify7 = __toESM(require_inversify());

  // features/creatingEdge/creatingEdge.ts
  var import_inversify6 = __toESM(require_inversify());
  var import_sprotty7 = __toESM(require_lib2());

  // features/creatingEdge/model.ts
  var creatingEdgeFeature = Symbol("creatingEdgeFeature");
  function isCreatableEdge(element) {
    return element.hasFeature(creatingEdgeFeature);
  }

  // features/creatingEdge/creatingEdge.ts
  var import_client3 = __toESM(require_lib6());

  // features/edge-creation/dangling-edge-feedback.ts
  var import_inversify5 = __toESM(require_inversify());
  var import_sprotty6 = __toESM(require_lib5());

  // features/edge-creation/view.tsx
  var import_inversify4 = __toESM(require_inversify());
  var import_sprotty5 = __toESM(require_lib5());
  var FeedbackEdgeEndView = class {
    render(model, context) {
      var _a;
      const position = (_a = model.position) != null ? _a : import_sprotty5.Point.ORIGIN;
      return /* @__PURE__ */ (0, import_sprotty5.svg)("g", { x: position.x, y: position.y });
    }
  };
  FeedbackEdgeEndView = __decorateClass([
    (0, import_inversify4.injectable)()
  ], FeedbackEdgeEndView);

  // features/edge-creation/dangling-edge-feedback.ts
  var import_client2 = __toESM(require_lib6());
  var DrawFeedbackEdgeAction;
  ((DrawFeedbackEdgeAction2) => {
    DrawFeedbackEdgeAction2.KIND = "drawFeedbackEdge";
    function is(object) {
      return import_sprotty6.Action.hasKind(object, DrawFeedbackEdgeAction2.KIND);
    }
    DrawFeedbackEdgeAction2.is = is;
    function create(options) {
      return {
        kind: DrawFeedbackEdgeAction2.KIND,
        ...options
      };
    }
    DrawFeedbackEdgeAction2.create = create;
  })(DrawFeedbackEdgeAction || (DrawFeedbackEdgeAction = {}));
  var DrawFeedbackEdgeCommand = class extends import_client2.FeedbackCommand {
    constructor(action) {
      super();
      this.action = action;
    }
    execute(context) {
      drawFeedbackEdge(
        context,
        this.action.sourceId,
        this.action.elementTypeId,
        this.action.edgeSchema
      );
      return context.root;
    }
  };
  DrawFeedbackEdgeCommand.KIND = DrawFeedbackEdgeAction.KIND;
  DrawFeedbackEdgeCommand = __decorateClass([
    (0, import_inversify5.injectable)(),
    __decorateParam(0, (0, import_inversify5.inject)(import_sprotty6.TYPES.Action))
  ], DrawFeedbackEdgeCommand);
  var RemoveFeedbackEdgeAction;
  ((RemoveFeedbackEdgeAction2) => {
    RemoveFeedbackEdgeAction2.KIND = "removeFeedbackEdgeCommand";
    function is(object) {
      return import_sprotty6.Action.hasKind(object, RemoveFeedbackEdgeAction2.KIND);
    }
    RemoveFeedbackEdgeAction2.is = is;
    function create() {
      return { kind: RemoveFeedbackEdgeAction2.KIND };
    }
    RemoveFeedbackEdgeAction2.create = create;
  })(RemoveFeedbackEdgeAction || (RemoveFeedbackEdgeAction = {}));
  var RemoveFeedbackEdgeCommand = class extends import_client2.FeedbackCommand {
    execute(context) {
      removeDanglingFeedbackEdge(context.root);
      return context.root;
    }
  };
  RemoveFeedbackEdgeCommand.KIND = RemoveFeedbackEdgeAction.KIND;
  RemoveFeedbackEdgeCommand = __decorateClass([
    (0, import_inversify5.injectable)()
  ], RemoveFeedbackEdgeCommand);
  var _FeedbackEdgeEnd = class extends import_sprotty6.GDanglingAnchor {
    constructor(sourceId, elementTypeId, feedbackEdge = void 0, type = _FeedbackEdgeEnd.TYPE) {
      super();
      this.sourceId = sourceId;
      this.elementTypeId = elementTypeId;
      this.feedbackEdge = feedbackEdge;
      this.type = type;
    }
  };
  var FeedbackEdgeEnd = _FeedbackEdgeEnd;
  FeedbackEdgeEnd.TYPE = "feedback-edge-end";
  function feedbackEdgeId(root) {
    return root.id + "_feedback_edge";
  }
  function feedbackEdgeEndId(root) {
    return root.id + "_feedback_anchor";
  }
  var defaultFeedbackEdgeSchema = {
    cssClasses: ["feedback-edge"],
    opacity: 0.3
  };
  function drawFeedbackEdge(context, sourceId, elementTypeId, edgeTemplate) {
    const root = context.root;
    const sourceChild = root.index.getById(sourceId);
    if (!sourceChild) {
      return;
    }
    const source = (0, import_sprotty6.findParentByFeature)(sourceChild, import_sprotty6.isConnectable);
    if (!source || !(0, import_sprotty6.isBoundsAware)(source)) {
      return;
    }
    const edgeEnd = new FeedbackEdgeEnd(source.id, elementTypeId);
    edgeEnd.id = feedbackEdgeEndId(root);
    edgeEnd.position = (0, import_client2.toAbsolutePosition)(source);
    const edgeSchema = {
      id: feedbackEdgeId(root),
      type: elementTypeId,
      sourceId: source.id,
      targetId: edgeEnd.id,
      ...defaultFeedbackEdgeSchema,
      ...edgeTemplate
    };
    const feedbackEdge = context.modelFactory.createElement(edgeSchema);
    if ((0, import_client2.isRoutable)(feedbackEdge)) {
      edgeEnd.feedbackEdge = feedbackEdge;
      root.add(edgeEnd);
      root.add(feedbackEdge);
    }
  }
  function removeDanglingFeedbackEdge(root) {
    const feedbackEdge = root.index.getById(feedbackEdgeId(root));
    const feedbackEdgeEnd = root.index.getById(feedbackEdgeEndId(root));
    if (feedbackEdge instanceof import_sprotty6.GChildElement) {
      root.remove(feedbackEdge);
    }
    if (feedbackEdgeEnd instanceof import_sprotty6.GChildElement) {
      root.remove(feedbackEdgeEnd);
    }
  }
  function configureDanglingFeedbackEdge(context) {
    if (!context.isBound(DrawFeedbackEdgeCommand) && !context.isBound(RemoveFeedbackEdgeCommand) && !context.isBound(FeedbackEdgeEndView)) {
      (0, import_sprotty6.configureCommand)(context, DrawFeedbackEdgeCommand);
      (0, import_sprotty6.configureCommand)(context, RemoveFeedbackEdgeCommand);
      (0, import_sprotty6.configureView)(context, FeedbackEdgeEnd.TYPE, FeedbackEdgeEndView);
    }
  }

  // features/creatingEdge/creatingEdge.ts
  var CreatingEdgeAction;
  ((CreatingEdgeAction2) => {
    CreatingEdgeAction2.KIND = "CreatingEdge";
    function create(sourceId) {
      return {
        kind: CreatingEdgeAction2.KIND,
        sourceId
      };
    }
    CreatingEdgeAction2.create = create;
  })(CreatingEdgeAction || (CreatingEdgeAction = {}));
  var CreateEdgeCommand = class extends import_sprotty7.Command {
    constructor(action) {
      super();
      this.action = action;
    }
    execute(context) {
      this.id = (0, import_sprotty7.createRandomId)();
      return this.redo(context);
    }
    undo(context) {
      if (this.id) {
        const model = context.root;
        let element = model.index.getById(this.id);
        if (element instanceof import_client3.GChildElement) {
          context.root.remove(element);
        }
        return context.root;
      }
    }
    redo(context) {
      let a = this.action;
      let element = context.modelFactory.createElement({
        sourceId: a.sourceElementId,
        targetId: a.targetElementId,
        routerKind: "manhattan",
        type: import_client3.DefaultTypes.EDGE,
        id: this.id
      });
      const model = context.root;
      model.add(element);
      return context.root;
    }
  };
  CreateEdgeCommand.KIND = import_client3.CreateEdgeOperation.KIND;
  CreateEdgeCommand = __decorateClass([
    (0, import_inversify6.injectable)(),
    __decorateParam(0, (0, import_inversify6.inject)(import_sprotty7.TYPES.Action))
  ], CreateEdgeCommand);
  var CreatingEdgeCommand = class extends import_sprotty7.Command {
    constructor(action) {
      super();
      this.action = action;
    }
    execute(context) {
      const model = context.root;
      let element = model.index.getById(this.action.sourceId);
      if (element && isCreatableEdge(element)) {
        element.selected = !element.selected;
      }
      return this.redo(context);
    }
    undo(context) {
      return context.root;
    }
    redo(context) {
      return context.root;
    }
  };
  CreatingEdgeCommand.KIND = CreatingEdgeAction.KIND;
  CreatingEdgeCommand = __decorateClass([
    (0, import_inversify6.injectable)(),
    __decorateParam(0, (0, import_inversify6.inject)(import_sprotty7.TYPES.Action))
  ], CreatingEdgeCommand);
  var CreatingEdgeMouseListener = class extends import_client3.DragAwareMouseListener {
    constructor() {
      super(...arguments);
      this.allowedTarget = false;
      this.pendingDynamicCheck = false;
      this.wasSelected = false;
      this.constructing = false;
    }
    reinitialize() {
      this.source = void 0;
      this.target = void 0;
      this.currentTarget = void 0;
      this.allowedTarget = false;
    }
    // override doubleClick(target: SModelElementImpl, event: MouseEvent): Action[] {
    mouseDown(target, event) {
      let creatableEdge = getCreatableEdge(target);
      if (!creatableEdge) {
        creatableEdge = (0, import_sprotty7.findParentByFeature)(target, isCreatableEdge);
      }
      if (creatableEdge) {
        this.constructing = true;
        this.source = creatableEdge.id;
        return [
          DrawFeedbackEdgeAction.create({
            elementTypeId: import_client3.DefaultTypes.EDGE,
            sourceId: creatableEdge.id
          })
        ];
      }
      return [];
    }
    nonDraggingMouseUp(target, event) {
      if (this.constructing) {
        this.constructing = false;
        const root = target.root;
        let edgeEnd = root.index.getById(target.id);
        let connectable = false;
        if (edgeEnd) {
          edgeEnd = (0, import_sprotty7.findParentByFeature)(edgeEnd, import_sprotty7.isConnectable);
          if (edgeEnd) {
            connectable = true;
          }
        }
        if (connectable && edgeEnd.id != this.source) {
          return [
            import_client3.CreateEdgeOperation.create({
              elementTypeId: import_client3.DefaultTypes.EDGE,
              sourceElementId: this.source,
              targetElementId: edgeEnd.id
              // args: this.triggerAction.args,
            }),
            RemoveFeedbackEdgeAction.create(),
            import_sprotty7.CommitModelAction.create()
          ];
        } else {
          return [RemoveFeedbackEdgeAction.create()];
        }
      }
      return [];
    }
    mouseMove(target, event) {
      if (this.constructing) {
        const root = target.root;
        const edgeEnd = root.index.getById(feedbackEdgeEndId(root));
        if (!(edgeEnd instanceof FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
          return [];
        }
        const edge = edgeEnd.feedbackEdge;
        const position = (0, import_client3.getAbsolutePosition)(edgeEnd, event);
        const endAtMousePosition = (0, import_sprotty7.findChildrenAtPosition)(target.root, position).reverse().find(
          (element) => (0, import_sprotty7.isConnectable)(element) && element.canConnect(edge, "target")
        );
        if (endAtMousePosition instanceof import_client3.GConnectableElement && edge.source && (0, import_sprotty7.isBoundsAware)(edge.source)) {
          const anchor = this.computeAbsoluteAnchor(
            endAtMousePosition,
            import_client3.Bounds.center((0, import_client3.toAbsoluteBounds)(edge.source))
          );
          if (import_client3.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
            let actions = [
              import_client3.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], {
                animate: false
              })
            ];
            return actions;
          }
        } else {
          return [
            import_client3.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], {
              animate: false
            })
          ];
        }
      }
      return [];
    }
    computeAbsoluteAnchor(element, absoluteReferencePoint, offset) {
      const referencePointInParent = (0, import_client3.absoluteToParent)(
        element,
        absoluteReferencePoint
      );
      const anchorComputer = this.anchorRegistry.get(
        import_sprotty7.PolylineEdgeRouter.KIND,
        element.anchorKind
      );
      let anchor = anchorComputer.getAnchor(
        element,
        referencePointInParent,
        offset
      );
      if (element.parent !== element.root) {
        const parent = (0, import_sprotty7.findParentByFeature)(element.parent, import_sprotty7.isBoundsAware);
        if (parent) {
          const absoluteParentPosition = (0, import_client3.toAbsoluteBounds)(parent);
          anchor = import_client3.Point.add(absoluteParentPosition, anchor);
        }
      }
      return anchor;
    }
    isSourceSelected() {
      return this.source !== void 0;
    }
    isTargetSelected() {
      return this.target !== void 0;
    }
    decorate(vnode, element) {
      let selectableTarget = getCreatableEdge(element);
      if (selectableTarget !== void 0) {
        (0, import_sprotty7.setClass)(vnode, "selected", selectableTarget.selected);
      }
      return vnode;
    }
  };
  __decorateClass([
    (0, import_inversify6.inject)(import_sprotty7.ButtonHandlerRegistry),
    (0, import_inversify6.optional)()
  ], CreatingEdgeMouseListener.prototype, "buttonHandlerRegistry", 2);
  __decorateClass([
    (0, import_inversify6.inject)(import_sprotty7.AnchorComputerRegistry)
  ], CreatingEdgeMouseListener.prototype, "anchorRegistry", 2);
  function getCreatableEdge(element) {
    if (isCreatableEdge(element)) {
      return element;
    }
    return void 0;
  }

  // features/creatingEdge/di.config.ts
  var import_sprotty8 = __toESM(require_lib2());
  var import_client4 = __toESM(require_lib6());
  var creatingEdgeModule = new import_inversify7.ContainerModule(
    (bind, unbind, isBound, rebind) => {
      const context = { bind, unbind, isBound, rebind };
      (0, import_sprotty8.configureCommand)({ bind, isBound }, CreatingEdgeCommand);
      (0, import_sprotty8.configureCommand)({ bind, isBound }, CreateEdgeCommand);
      bind(CreatingEdgeMouseListener).toSelf().inSingletonScope();
      bind(import_client4.TYPES.MouseListener).toService(CreatingEdgeMouseListener);
      configureDanglingFeedbackEdge(context);
    }
  );
  var di_config_default = creatingEdgeModule;

  // features/creatingNodes/di.config.ts
  var import_inversify8 = __toESM(require_inversify());
  var import_client5 = __toESM(require_lib6());
  var creatingEdgeModule2 = new import_inversify8.ContainerModule(
    (bind, unbind, isBound, rebind) => {
      const context = { bind, unbind, isBound, rebind };
      bind(DroppableMouseListener).toSelf().inSingletonScope();
      bind(import_client5.TYPES.MouseListener).toService(DroppableMouseListener);
    }
  );
  var di_config_default2 = creatingEdgeModule2;

  // di.config.ts
  var import_client6 = __toESM(require_lib6());
  var createContainer = (containerId) => {
    const myModule = new import_inversify9.ContainerModule((bind, unbind, isBound, rebind) => {
      const context = { bind, unbind, isBound, rebind };
      bind(import_client6.TYPES.ModelSource).to(ClassDiagramModelSource).inSingletonScope();
      rebind(import_client6.TYPES.ILogger).to(import_sprotty9.ConsoleLogger).inSingletonScope();
      rebind(import_client6.TYPES.LogLevel).toConstantValue(import_sprotty9.LogLevel.log);
      (0, import_sprotty9.configureModelElement)(context, "graph", import_sprotty9.SGraphImpl, import_sprotty9.SGraphView);
      (0, import_sprotty9.configureModelElement)(context, "node4diac", Node4diac, Node4diacView, {
        // enable: [withEditLabelFeature, layoutableChildFeature], // плюсуются к SNodeImpl.DEFAULT_FEATURES
        // disable: [hoverFeedbackFeature, popupFeature, connectableFeature],
      });
      (0, import_sprotty9.configureModelElement)(context, "node4diac:title", import_sprotty9.SLabelImpl, import_sprotty9.SLabelView, {
        enable: [import_sprotty9.editLabelFeature]
      });
      (0, import_sprotty9.configureModelElement)(
        context,
        "node4diac:inputs",
        import_sprotty9.SCompartmentImpl,
        import_sprotty9.SCompartmentView
      );
      (0, import_sprotty9.configureModelElement)(
        context,
        "node4diac:port",
        import_sprotty9.SPortImpl,
        PortViewWithExternalLabel,
        {
          enable: [import_sprotty9.layoutableChildFeature, creatingEdgeFeature],
          disable: [import_sprotty9.hoverFeedbackFeature, import_sprotty9.popupFeature]
        }
      );
      (0, import_sprotty9.configureModelElement)(
        context,
        "node4diac:port_title",
        import_sprotty9.SLabelImpl,
        import_sprotty9.SLabelView
      );
      (0, import_sprotty9.configureModelElement)(context, import_client6.DefaultTypes.EDGE, import_client6.GEdge, WorkflowEdgeView);
      (0, import_sprotty9.configureModelElement)(
        context,
        "routing-point",
        import_sprotty9.SRoutingHandleImpl,
        import_sprotty9.SRoutingHandleView
      );
      (0, import_sprotty9.configureModelElement)(
        context,
        "volatile-routing-point",
        import_sprotty9.SRoutingHandleImpl,
        import_sprotty9.SRoutingHandleView
      );
      (0, import_sprotty9.configureViewerOptions)(context, {
        needsClientLayout: true,
        baseDiv: containerId
      });
    });
    const container = new import_inversify9.Container();
    (0, import_sprotty9.loadDefaultModules)(container, { exclude: [import_sprotty9.expandModule, import_sprotty9.fadeModule] });
    container.load(
      myModule,
      import_sprotty9.edgeIntersectionModule,
      di_config_default,
      di_config_default2
    );
    return container;
  };

  // index.ts
  function run() {
    var _a;
    const container = createContainer("sprotty-container");
    const modelSource = container.get(import_sprotty10.TYPES.ModelSource);
    modelSource.updateModel();
    let btnExport = (_a = document.getElementsByClassName("btnExport")) == null ? void 0 : _a.item(0);
    btnExport.addEventListener("click", async (e) => {
      let str = JSON.stringify(modelSource.model, null, " ");
      console.log(str);
      alert(str);
    });
  }
  document.addEventListener("DOMContentLoaded", () => run());
})();
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=index.js.map
